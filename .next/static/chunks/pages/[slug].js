/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/[slug]"],{

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzM3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGtCQUFrQjtBQUNsQix5QkFBeUI7O0FBRXpCO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanM/OTAxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICB2YXIgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIEJ1ZmZlci5mcm9tKGJ1ZikuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanM/ZWJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "./node_modules/next-seo/lib/next-seo.module.js":
/*!******************************************************!*\
  !*** ./node_modules/next-seo/lib/next-seo.module.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArticleJsonLd\": function() { return /* binding */ ArticleJsonLd; },\n/* harmony export */   \"BrandJsonLd\": function() { return /* binding */ BrandJsonLd; },\n/* harmony export */   \"BreadcrumbJsonLd\": function() { return /* binding */ BreadCrumbJsonLd; },\n/* harmony export */   \"CarouselJsonLd\": function() { return /* binding */ CarouselJsonLd; },\n/* harmony export */   \"CollectionPageJsonLd\": function() { return /* binding */ CollectionPageJsonLd; },\n/* harmony export */   \"CorporateContactJsonLd\": function() { return /* binding */ CorporateContactJsonLd; },\n/* harmony export */   \"CourseJsonLd\": function() { return /* binding */ CourseJsonLd; },\n/* harmony export */   \"DatasetJsonLd\": function() { return /* binding */ DatasetJsonLd; },\n/* harmony export */   \"DefaultSeo\": function() { return /* binding */ DefaultSeo; },\n/* harmony export */   \"EventJsonLd\": function() { return /* binding */ EventJsonLd; },\n/* harmony export */   \"FAQPageJsonLd\": function() { return /* binding */ FAQPageJsonLd; },\n/* harmony export */   \"HowToJsonLd\": function() { return /* binding */ howToJsonLd; },\n/* harmony export */   \"ImageJsonLd\": function() { return /* binding */ ImageJsonLd; },\n/* harmony export */   \"JobPostingJsonLd\": function() { return /* binding */ JobPostingJsonLd; },\n/* harmony export */   \"LocalBusinessJsonLd\": function() { return /* binding */ LocalBusinessJsonLd; },\n/* harmony export */   \"LogoJsonLd\": function() { return /* binding */ LogoJsonLd; },\n/* harmony export */   \"NewsArticleJsonLd\": function() { return /* binding */ NewsArticleJsonLd; },\n/* harmony export */   \"NextSeo\": function() { return /* binding */ NextSeo; },\n/* harmony export */   \"OrganizationJsonLd\": function() { return /* binding */ OrganizationJsonLd; },\n/* harmony export */   \"ProductJsonLd\": function() { return /* binding */ ProductJsonLd; },\n/* harmony export */   \"ProfilePageJsonLd\": function() { return /* binding */ ProfilePageJsonLd; },\n/* harmony export */   \"QAPageJsonLd\": function() { return /* binding */ QAPageJsonLd; },\n/* harmony export */   \"RecipeJsonLd\": function() { return /* binding */ RecipeJsonLd; },\n/* harmony export */   \"SiteLinksSearchBoxJsonLd\": function() { return /* binding */ SiteLinksSearchBoxJsonLd; },\n/* harmony export */   \"SocialProfileJsonLd\": function() { return /* binding */ SocialProfileJsonLd; },\n/* harmony export */   \"SoftwareAppJsonLd\": function() { return /* binding */ SoftwareAppJsonLd; },\n/* harmony export */   \"VideoGameJsonLd\": function() { return /* binding */ VideoGameJsonLd; },\n/* harmony export */   \"VideoJsonLd\": function() { return /* binding */ VideoJsonLd; },\n/* harmony export */   \"WebPageJsonLd\": function() { return /* binding */ WebPageJsonLd; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nvar _excluded$x = [\"keyOverride\"];\nvar defaults = {\n  templateTitle: '',\n  noindex: false,\n  nofollow: false,\n  defaultOpenGraphImageWidth: 0,\n  defaultOpenGraphImageHeight: 0,\n  defaultOpenGraphVideoWidth: 0,\n  defaultOpenGraphVideoHeight: 0\n};\nvar buildOpenGraphMediaTags = function buildOpenGraphMediaTags(mediaType, media, _temp) {\n  if (media === void 0) {\n    media = [];\n  }\n  var _ref = _temp === void 0 ? {} : _temp,\n    defaultWidth = _ref.defaultWidth,\n    defaultHeight = _ref.defaultHeight;\n  return media.reduce(function (tags, medium, index) {\n    tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n      key: \"og:\" + mediaType + \":0\" + index,\n      property: \"og:\" + mediaType,\n      content: medium.url\n    }));\n    if (medium.alt) {\n      tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:\" + mediaType + \":alt0\" + index,\n        property: \"og:\" + mediaType + \":alt\",\n        content: medium.alt\n      }));\n    }\n    if (medium.secureUrl) {\n      tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:\" + mediaType + \":secure_url0\" + index,\n        property: \"og:\" + mediaType + \":secure_url\",\n        content: medium.secureUrl.toString()\n      }));\n    }\n    if (medium.type) {\n      tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:\" + mediaType + \":type0\" + index,\n        property: \"og:\" + mediaType + \":type\",\n        content: medium.type.toString()\n      }));\n    }\n    if (medium.width) {\n      tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:\" + mediaType + \":width0\" + index,\n        property: \"og:\" + mediaType + \":width\",\n        content: medium.width.toString()\n      }));\n    } else if (defaultWidth) {\n      tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:\" + mediaType + \":width0\" + index,\n        property: \"og:\" + mediaType + \":width\",\n        content: defaultWidth.toString()\n      }));\n    }\n    if (medium.height) {\n      tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:\" + mediaType + \":height\" + index,\n        property: \"og:\" + mediaType + \":height\",\n        content: medium.height.toString()\n      }));\n    } else if (defaultHeight) {\n      tags.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:\" + mediaType + \":height\" + index,\n        property: \"og:\" + mediaType + \":height\",\n        content: defaultHeight.toString()\n      }));\n    }\n    return tags;\n  }, []);\n};\nvar buildTags = function buildTags(config) {\n  var _config$openGraph, _config$openGraph3, _config$additionalLin;\n  var tagsToRender = [];\n  if (config.titleTemplate) {\n    defaults.templateTitle = config.titleTemplate;\n  }\n  var updatedTitle = '';\n  if (config.title) {\n    updatedTitle = config.title;\n    if (defaults.templateTitle) {\n      updatedTitle = defaults.templateTitle.replace(/%s/g, function () {\n        return updatedTitle;\n      });\n    }\n  } else if (config.defaultTitle) {\n    updatedTitle = config.defaultTitle;\n  }\n  if (updatedTitle) {\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"title\", {\n      key: \"title\"\n    }, updatedTitle));\n  }\n  var noindex = config.noindex || defaults.noindex || config.dangerouslySetAllPagesToNoIndex;\n  var nofollow = config.nofollow || defaults.nofollow || config.dangerouslySetAllPagesToNoFollow;\n  var robotsParams = '';\n  if (config.robotsProps) {\n    var _config$robotsProps = config.robotsProps,\n      nosnippet = _config$robotsProps.nosnippet,\n      maxSnippet = _config$robotsProps.maxSnippet,\n      maxImagePreview = _config$robotsProps.maxImagePreview,\n      maxVideoPreview = _config$robotsProps.maxVideoPreview,\n      noarchive = _config$robotsProps.noarchive,\n      noimageindex = _config$robotsProps.noimageindex,\n      notranslate = _config$robotsProps.notranslate,\n      unavailableAfter = _config$robotsProps.unavailableAfter;\n    robotsParams = \"\" + (nosnippet ? ',nosnippet' : '') + (maxSnippet ? \",max-snippet:\" + maxSnippet : '') + (maxImagePreview ? \",max-image-preview:\" + maxImagePreview : '') + (noarchive ? ',noarchive' : '') + (unavailableAfter ? \",unavailable_after:\" + unavailableAfter : '') + (noimageindex ? ',noimageindex' : '') + (maxVideoPreview ? \",max-video-preview:\" + maxVideoPreview : '') + (notranslate ? ',notranslate' : '');\n  }\n  if (noindex || nofollow) {\n    if (config.dangerouslySetAllPagesToNoIndex) {\n      defaults.noindex = true;\n    }\n    if (config.dangerouslySetAllPagesToNoFollow) {\n      defaults.nofollow = true;\n    }\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n      key: \"robots\",\n      name: \"robots\",\n      content: (noindex ? 'noindex' : 'index') + \",\" + (nofollow ? 'nofollow' : 'follow') + robotsParams\n    }));\n  } else {\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n      key: \"robots\",\n      name: \"robots\",\n      content: \"index,follow\" + robotsParams\n    }));\n  }\n  if (config.description) {\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n      key: \"description\",\n      name: \"description\",\n      content: config.description\n    }));\n  }\n  if (config.themeColor) {\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n      key: \"theme-color\",\n      name: \"theme-color\",\n      content: config.themeColor\n    }));\n  }\n  if (config.mobileAlternate) {\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"link\", {\n      rel: \"alternate\",\n      key: \"mobileAlternate\",\n      media: config.mobileAlternate.media,\n      href: config.mobileAlternate.href\n    }));\n  }\n  if (config.languageAlternates && config.languageAlternates.length > 0) {\n    config.languageAlternates.forEach(function (languageAlternate) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"link\", {\n        rel: \"alternate\",\n        key: \"languageAlternate-\" + languageAlternate.hrefLang,\n        hrefLang: languageAlternate.hrefLang,\n        href: languageAlternate.href\n      }));\n    });\n  }\n  if (config.twitter) {\n    if (config.twitter.cardType) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"twitter:card\",\n        name: \"twitter:card\",\n        content: config.twitter.cardType\n      }));\n    }\n    if (config.twitter.site) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"twitter:site\",\n        name: \"twitter:site\",\n        content: config.twitter.site\n      }));\n    }\n    if (config.twitter.handle) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"twitter:creator\",\n        name: \"twitter:creator\",\n        content: config.twitter.handle\n      }));\n    }\n  }\n  if (config.facebook) {\n    if (config.facebook.appId) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"fb:app_id\",\n        property: \"fb:app_id\",\n        content: config.facebook.appId\n      }));\n    }\n  }\n  if ((_config$openGraph = config.openGraph) != null && _config$openGraph.title || updatedTitle) {\n    var _config$openGraph2;\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n      key: \"og:title\",\n      property: \"og:title\",\n      content: ((_config$openGraph2 = config.openGraph) == null ? void 0 : _config$openGraph2.title) || updatedTitle\n    }));\n  }\n  if ((_config$openGraph3 = config.openGraph) != null && _config$openGraph3.description || config.description) {\n    var _config$openGraph4;\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n      key: \"og:description\",\n      property: \"og:description\",\n      content: ((_config$openGraph4 = config.openGraph) == null ? void 0 : _config$openGraph4.description) || config.description\n    }));\n  }\n  if (config.openGraph) {\n    if (config.openGraph.url || config.canonical) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:url\",\n        property: \"og:url\",\n        content: config.openGraph.url || config.canonical\n      }));\n    }\n    if (config.openGraph.type) {\n      var type = config.openGraph.type.toLowerCase();\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:type\",\n        property: \"og:type\",\n        content: type\n      }));\n      if (type === 'profile' && config.openGraph.profile) {\n        if (config.openGraph.profile.firstName) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"profile:first_name\",\n            property: \"profile:first_name\",\n            content: config.openGraph.profile.firstName\n          }));\n        }\n        if (config.openGraph.profile.lastName) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"profile:last_name\",\n            property: \"profile:last_name\",\n            content: config.openGraph.profile.lastName\n          }));\n        }\n        if (config.openGraph.profile.username) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"profile:username\",\n            property: \"profile:username\",\n            content: config.openGraph.profile.username\n          }));\n        }\n        if (config.openGraph.profile.gender) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"profile:gender\",\n            property: \"profile:gender\",\n            content: config.openGraph.profile.gender\n          }));\n        }\n      } else if (type === 'book' && config.openGraph.book) {\n        if (config.openGraph.book.authors && config.openGraph.book.authors.length) {\n          config.openGraph.book.authors.forEach(function (author, index) {\n            tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n              key: \"book:author:0\" + index,\n              property: \"book:author\",\n              content: author\n            }));\n          });\n        }\n        if (config.openGraph.book.isbn) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"book:isbn\",\n            property: \"book:isbn\",\n            content: config.openGraph.book.isbn\n          }));\n        }\n        if (config.openGraph.book.releaseDate) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"book:release_date\",\n            property: \"book:release_date\",\n            content: config.openGraph.book.releaseDate\n          }));\n        }\n        if (config.openGraph.book.tags && config.openGraph.book.tags.length) {\n          config.openGraph.book.tags.forEach(function (tag, index) {\n            tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n              key: \"book:tag:0\" + index,\n              property: \"book:tag\",\n              content: tag\n            }));\n          });\n        }\n      } else if (type === 'article' && config.openGraph.article) {\n        if (config.openGraph.article.publishedTime) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"article:published_time\",\n            property: \"article:published_time\",\n            content: config.openGraph.article.publishedTime\n          }));\n        }\n        if (config.openGraph.article.modifiedTime) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"article:modified_time\",\n            property: \"article:modified_time\",\n            content: config.openGraph.article.modifiedTime\n          }));\n        }\n        if (config.openGraph.article.expirationTime) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"article:expiration_time\",\n            property: \"article:expiration_time\",\n            content: config.openGraph.article.expirationTime\n          }));\n        }\n        if (config.openGraph.article.authors && config.openGraph.article.authors.length) {\n          config.openGraph.article.authors.forEach(function (author, index) {\n            tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n              key: \"article:author:0\" + index,\n              property: \"article:author\",\n              content: author\n            }));\n          });\n        }\n        if (config.openGraph.article.section) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"article:section\",\n            property: \"article:section\",\n            content: config.openGraph.article.section\n          }));\n        }\n        if (config.openGraph.article.tags && config.openGraph.article.tags.length) {\n          config.openGraph.article.tags.forEach(function (tag, index) {\n            tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n              key: \"article:tag:0\" + index,\n              property: \"article:tag\",\n              content: tag\n            }));\n          });\n        }\n      } else if ((type === 'video.movie' || type === 'video.episode' || type === 'video.tv_show' || type === 'video.other') && config.openGraph.video) {\n        if (config.openGraph.video.actors && config.openGraph.video.actors.length) {\n          config.openGraph.video.actors.forEach(function (actor, index) {\n            if (actor.profile) {\n              tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n                key: \"video:actor:0\" + index,\n                property: \"video:actor\",\n                content: actor.profile\n              }));\n            }\n            if (actor.role) {\n              tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n                key: \"video:actor:role:0\" + index,\n                property: \"video:actor:role\",\n                content: actor.role\n              }));\n            }\n          });\n        }\n        if (config.openGraph.video.directors && config.openGraph.video.directors.length) {\n          config.openGraph.video.directors.forEach(function (director, index) {\n            tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n              key: \"video:director:0\" + index,\n              property: \"video:director\",\n              content: director\n            }));\n          });\n        }\n        if (config.openGraph.video.writers && config.openGraph.video.writers.length) {\n          config.openGraph.video.writers.forEach(function (writer, index) {\n            tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n              key: \"video:writer:0\" + index,\n              property: \"video:writer\",\n              content: writer\n            }));\n          });\n        }\n        if (config.openGraph.video.duration) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"video:duration\",\n            property: \"video:duration\",\n            content: config.openGraph.video.duration.toString()\n          }));\n        }\n        if (config.openGraph.video.releaseDate) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"video:release_date\",\n            property: \"video:release_date\",\n            content: config.openGraph.video.releaseDate\n          }));\n        }\n        if (config.openGraph.video.tags && config.openGraph.video.tags.length) {\n          config.openGraph.video.tags.forEach(function (tag, index) {\n            tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n              key: \"video:tag:0\" + index,\n              property: \"video:tag\",\n              content: tag\n            }));\n          });\n        }\n        if (config.openGraph.video.series) {\n          tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n            key: \"video:series\",\n            property: \"video:series\",\n            content: config.openGraph.video.series\n          }));\n        }\n      }\n    }\n    // images\n    if (config.defaultOpenGraphImageWidth) {\n      defaults.defaultOpenGraphImageWidth = config.defaultOpenGraphImageWidth;\n    }\n    if (config.defaultOpenGraphImageHeight) {\n      defaults.defaultOpenGraphImageHeight = config.defaultOpenGraphImageHeight;\n    }\n    if (config.openGraph.images && config.openGraph.images.length) {\n      tagsToRender.push.apply(tagsToRender, buildOpenGraphMediaTags('image', config.openGraph.images, {\n        defaultWidth: defaults.defaultOpenGraphImageWidth,\n        defaultHeight: defaults.defaultOpenGraphImageHeight\n      }));\n    }\n    // videos\n    if (config.defaultOpenGraphVideoWidth) {\n      defaults.defaultOpenGraphVideoWidth = config.defaultOpenGraphVideoWidth;\n    }\n    if (config.defaultOpenGraphVideoHeight) {\n      defaults.defaultOpenGraphVideoHeight = config.defaultOpenGraphVideoHeight;\n    }\n    if (config.openGraph.videos && config.openGraph.videos.length) {\n      tagsToRender.push.apply(tagsToRender, buildOpenGraphMediaTags('video', config.openGraph.videos, {\n        defaultWidth: defaults.defaultOpenGraphVideoWidth,\n        defaultHeight: defaults.defaultOpenGraphVideoHeight\n      }));\n    }\n    // audio\n    if (config.openGraph.audio) {\n      tagsToRender.push.apply(tagsToRender, buildOpenGraphMediaTags('audio', config.openGraph.audio));\n    }\n    if (config.openGraph.locale) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:locale\",\n        property: \"og:locale\",\n        content: config.openGraph.locale\n      }));\n    }\n    if (config.openGraph.siteName || config.openGraph.site_name) {\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", {\n        key: \"og:site_name\",\n        property: \"og:site_name\",\n        content: config.openGraph.siteName || config.openGraph.site_name\n      }));\n    }\n  }\n  if (config.canonical) {\n    tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"link\", {\n      rel: \"canonical\",\n      href: config.canonical,\n      key: \"canonical\"\n    }));\n  }\n  if (config.additionalMetaTags && config.additionalMetaTags.length > 0) {\n    config.additionalMetaTags.forEach(function (_ref2) {\n      var _ref3, _ref4;\n      var keyOverride = _ref2.keyOverride,\n        tag = _objectWithoutPropertiesLoose(_ref2, _excluded$x);\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"meta\", _extends({\n        key: \"meta:\" + ((_ref3 = (_ref4 = keyOverride != null ? keyOverride : tag.name) != null ? _ref4 : tag.property) != null ? _ref3 : tag.httpEquiv)\n      }, tag)));\n    });\n  }\n  if ((_config$additionalLin = config.additionalLinkTags) != null && _config$additionalLin.length) {\n    config.additionalLinkTags.forEach(function (tag) {\n      var _tag$keyOverride;\n      tagsToRender.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"link\", _extends({\n        key: \"link\" + ((_tag$keyOverride = tag.keyOverride) != null ? _tag$keyOverride : tag.href) + tag.rel\n      }, tag)));\n    });\n  }\n  return tagsToRender;\n};\n\nvar WithHead = function WithHead(props) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((next_head__WEBPACK_IMPORTED_MODULE_1___default()), null, buildTags(props));\n};\n\nvar DefaultSeo = function DefaultSeo(_ref) {\n  var title = _ref.title,\n    titleTemplate = _ref.titleTemplate,\n    defaultTitle = _ref.defaultTitle,\n    themeColor = _ref.themeColor,\n    _ref$dangerouslySetAl = _ref.dangerouslySetAllPagesToNoIndex,\n    dangerouslySetAllPagesToNoIndex = _ref$dangerouslySetAl === void 0 ? false : _ref$dangerouslySetAl,\n    _ref$dangerouslySetAl2 = _ref.dangerouslySetAllPagesToNoFollow,\n    dangerouslySetAllPagesToNoFollow = _ref$dangerouslySetAl2 === void 0 ? false : _ref$dangerouslySetAl2,\n    description = _ref.description,\n    canonical = _ref.canonical,\n    facebook = _ref.facebook,\n    openGraph = _ref.openGraph,\n    additionalMetaTags = _ref.additionalMetaTags,\n    twitter = _ref.twitter,\n    defaultOpenGraphImageWidth = _ref.defaultOpenGraphImageWidth,\n    defaultOpenGraphImageHeight = _ref.defaultOpenGraphImageHeight,\n    defaultOpenGraphVideoWidth = _ref.defaultOpenGraphVideoWidth,\n    defaultOpenGraphVideoHeight = _ref.defaultOpenGraphVideoHeight,\n    mobileAlternate = _ref.mobileAlternate,\n    languageAlternates = _ref.languageAlternates,\n    additionalLinkTags = _ref.additionalLinkTags,\n    robotsProps = _ref.robotsProps;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(WithHead, {\n    title: title,\n    titleTemplate: titleTemplate,\n    defaultTitle: defaultTitle,\n    themeColor: themeColor,\n    dangerouslySetAllPagesToNoIndex: dangerouslySetAllPagesToNoIndex,\n    dangerouslySetAllPagesToNoFollow: dangerouslySetAllPagesToNoFollow,\n    description: description,\n    canonical: canonical,\n    facebook: facebook,\n    openGraph: openGraph,\n    additionalMetaTags: additionalMetaTags,\n    twitter: twitter,\n    defaultOpenGraphImageWidth: defaultOpenGraphImageWidth,\n    defaultOpenGraphImageHeight: defaultOpenGraphImageHeight,\n    defaultOpenGraphVideoWidth: defaultOpenGraphVideoWidth,\n    defaultOpenGraphVideoHeight: defaultOpenGraphVideoHeight,\n    mobileAlternate: mobileAlternate,\n    languageAlternates: languageAlternates,\n    additionalLinkTags: additionalLinkTags,\n    robotsProps: robotsProps\n  });\n};\n\nvar NextSeo = function NextSeo(_ref) {\n  var title = _ref.title,\n    themeColor = _ref.themeColor,\n    _ref$noindex = _ref.noindex,\n    noindex = _ref$noindex === void 0 ? false : _ref$noindex,\n    nofollow = _ref.nofollow,\n    robotsProps = _ref.robotsProps,\n    description = _ref.description,\n    canonical = _ref.canonical,\n    openGraph = _ref.openGraph,\n    facebook = _ref.facebook,\n    twitter = _ref.twitter,\n    additionalMetaTags = _ref.additionalMetaTags,\n    titleTemplate = _ref.titleTemplate,\n    defaultTitle = _ref.defaultTitle,\n    mobileAlternate = _ref.mobileAlternate,\n    languageAlternates = _ref.languageAlternates,\n    additionalLinkTags = _ref.additionalLinkTags,\n    _ref$useAppDir = _ref.useAppDir,\n    useAppDir = _ref$useAppDir === void 0 ? false : _ref$useAppDir;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, useAppDir ? buildTags({\n    title: title,\n    themeColor: themeColor,\n    noindex: noindex,\n    nofollow: nofollow,\n    robotsProps: robotsProps,\n    description: description,\n    canonical: canonical,\n    facebook: facebook,\n    openGraph: openGraph,\n    additionalMetaTags: additionalMetaTags,\n    twitter: twitter,\n    titleTemplate: titleTemplate,\n    defaultTitle: defaultTitle,\n    mobileAlternate: mobileAlternate,\n    languageAlternates: languageAlternates,\n    additionalLinkTags: additionalLinkTags\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(WithHead, {\n    title: title,\n    themeColor: themeColor,\n    noindex: noindex,\n    nofollow: nofollow,\n    robotsProps: robotsProps,\n    description: description,\n    canonical: canonical,\n    facebook: facebook,\n    openGraph: openGraph,\n    additionalMetaTags: additionalMetaTags,\n    twitter: twitter,\n    titleTemplate: titleTemplate,\n    defaultTitle: defaultTitle,\n    mobileAlternate: mobileAlternate,\n    languageAlternates: languageAlternates,\n    additionalLinkTags: additionalLinkTags\n  }));\n};\n\nvar toJson = function toJson(type, jsonld) {\n  var data = jsonld;\n  if (Array.isArray(data) && data.length === 1) {\n    data = _extends({}, jsonld[0]);\n  }\n  var jsonLdObject = Array.isArray(data) ? data.map(function (item) {\n    return formatObjectForSchema(type, item);\n  }) : formatObjectForSchema(type, data);\n  return {\n    __html: JSON.stringify(jsonLdObject, safeJsonLdReplacer)\n  };\n};\nvar formatObjectForSchema = function formatObjectForSchema(type, jsonld) {\n  var _jsonld$id = jsonld.id,\n    id = _jsonld$id === void 0 ? undefined : _jsonld$id;\n  var updated = _extends({}, id ? {\n    '@id': jsonld.id\n  } : {}, jsonld);\n  delete updated.id;\n  return _extends({\n    '@context': 'https://schema.org',\n    '@type': type\n  }, updated);\n};\nvar ESCAPE_ENTITIES = Object.freeze({\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&apos;'\n});\nvar ESCAPE_REGEX = new RegExp(\"[\" + Object.keys(ESCAPE_ENTITIES).join('') + \"]\", 'g');\nvar ESCAPE_REPLACER = function ESCAPE_REPLACER(t) {\n  return ESCAPE_ENTITIES[t];\n};\n/**\r\n * A replacer for JSON.stringify to strip JSON-LD of illegal HTML entities\r\n * per https://www.w3.org/TR/json-ld11/#restrictions-for-contents-of-json-ld-script-elements\r\n */\nvar safeJsonLdReplacer = function () {\n  // Replace per https://www.w3.org/TR/json-ld11/#restrictions-for-contents-of-json-ld-script-elements\n  // Solution from https://stackoverflow.com/a/5499821/864313\n  return function (_, value) {\n    switch (typeof value) {\n      case 'object':\n        // Omit null values.\n        if (value === null) {\n          return undefined;\n        }\n        return value;\n      // JSON.stringify will recursively call replacer.\n      case 'number':\n      case 'boolean':\n      case 'bigint':\n        return value;\n      // These values are not risky.\n      case 'string':\n        return value.replace(ESCAPE_REGEX, ESCAPE_REPLACER);\n      default:\n        {\n          // JSON.stringify will remove this element.\n          return undefined;\n        }\n    }\n  };\n}();\n\nvar _excluded$w = [\"type\", \"keyOverride\", \"scriptKey\", \"scriptId\", \"dataArray\", \"useAppDir\"];\nfunction JsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Thing' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    scriptKey = _ref.scriptKey,\n    _ref$scriptId = _ref.scriptId,\n    scriptId = _ref$scriptId === void 0 ? undefined : _ref$scriptId,\n    dataArray = _ref.dataArray,\n    _ref$useAppDir = _ref.useAppDir,\n    useAppDir = _ref$useAppDir === void 0 ? false : _ref$useAppDir,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$w);\n  var JsonLdScript = function JsonLdScript() {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"script\", {\n      type: \"application/ld+json\",\n      id: scriptId,\n      \"data-testid\": scriptId,\n      dangerouslySetInnerHTML: toJson(type, dataArray === undefined ? _extends({}, rest) : dataArray),\n      key: \"jsonld-\" + scriptKey + (keyOverride ? \"-\" + keyOverride : '')\n    });\n  };\n  if (useAppDir) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLdScript, null);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((next_head__WEBPACK_IMPORTED_MODULE_1___default()), null, JsonLdScript());\n}\n\n/**\r\n * Generate author information\r\n * @param author\r\n * @returns\r\n */\nfunction generateAuthorInfo(author) {\n  if (typeof author === 'string') {\n    return {\n      '@type': 'Person',\n      name: author\n    };\n  } else if (!!author.name) {\n    var _author$type;\n    return {\n      '@type': (_author$type = author == null ? void 0 : author.type) != null ? _author$type : 'Person',\n      name: author.name,\n      url: author == null ? void 0 : author.url\n    };\n  }\n  return;\n}\nfunction setAuthor(author) {\n  if (Array.isArray(author)) {\n    return author.map(function (item) {\n      return generateAuthorInfo(item);\n    }).filter(function (item) {\n      return !!item;\n    });\n  } else if (author) {\n    return generateAuthorInfo(author);\n  }\n  return;\n}\n\nfunction setImage(image) {\n  if (image) {\n    return {\n      '@type': 'ImageObject',\n      url: image\n    };\n  }\n  return undefined;\n}\n\nfunction setPublisher(publisherName, publisherLogo) {\n  if (!publisherName) {\n    return undefined;\n  }\n  return {\n    '@type': 'Organization',\n    name: publisherName,\n    logo: setImage(publisherLogo)\n  };\n}\n\nfunction setReviewRating(rating) {\n  if (rating) {\n    return _extends({}, rating, {\n      '@type': 'Rating'\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$v = [\"reviewRating\", \"author\", \"publisher\"];\nfunction setReviews(reviews) {\n  function mapReview(_ref) {\n    var reviewRating = _ref.reviewRating,\n      author = _ref.author,\n      publisher = _ref.publisher,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded$v);\n    return _extends({}, rest, {\n      '@type': 'Review'\n    }, author && {\n      author: setAuthor(author)\n    }, reviewRating && {\n      reviewRating: setReviewRating(reviewRating)\n    }, publisher && {\n      publisher: setPublisher(publisher.name)\n    });\n  }\n  if (Array.isArray(reviews)) {\n    return reviews.map(mapReview);\n  } else if (reviews) {\n    return mapReview(reviews);\n  }\n  return undefined;\n}\n\nfunction setNutrition(calories) {\n  if (calories) {\n    return {\n      '@type': 'NutritionInformation',\n      calories: calories + \" calories\"\n    };\n  }\n  return undefined;\n}\n\nfunction setAggregateRating(aggregateRating) {\n  if (aggregateRating) {\n    return {\n      '@type': 'AggregateRating',\n      ratingCount: aggregateRating.ratingCount,\n      reviewCount: aggregateRating.reviewCount,\n      bestRating: aggregateRating.bestRating,\n      ratingValue: aggregateRating.ratingValue\n    };\n  }\n  return undefined;\n}\n\nfunction setClip(clips) {\n  function mapClip(clip) {\n    return _extends({}, clip, {\n      '@type': 'Clip'\n    });\n  }\n  if (Array.isArray(clips)) {\n    return clips.map(mapClip);\n  } else if (clips) {\n    return mapClip(clips);\n  }\n  return undefined;\n}\n\nfunction setInteractionStatistic(watchCount) {\n  if (watchCount) {\n    return {\n      '@type': 'InteractionCounter',\n      interactionType: 'https://schema.org/WatchAction',\n      userInteractionCount: watchCount\n    };\n  }\n  return undefined;\n}\n\nfunction setBroadcastEvent(publication) {\n  function mapBroadcastEvent(publication) {\n    return _extends({}, publication, {\n      '@type': 'BroadcastEvent'\n    });\n  }\n  if (publication) {\n    if (Array.isArray(publication)) {\n      return publication.map(mapBroadcastEvent);\n    }\n    return mapBroadcastEvent(publication);\n  }\n  return undefined;\n}\n\nvar _excluded$u = [\"thumbnailUrls\", \"hasPart\", \"watchCount\", \"publication\"];\nfunction setVideo(video, setContext) {\n  if (setContext === void 0) {\n    setContext = false;\n  }\n  function mapVideo(_ref, context) {\n    var thumbnailUrls = _ref.thumbnailUrls,\n      hasPart = _ref.hasPart,\n      watchCount = _ref.watchCount,\n      publication = _ref.publication,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded$u);\n    return _extends({}, rest, {\n      '@type': 'VideoObject'\n    }, context && {\n      '@context': 'https://schema.org'\n    }, {\n      thumbnailUrl: thumbnailUrls,\n      hasPart: setClip(hasPart),\n      interactionStatistic: setInteractionStatistic(watchCount),\n      publication: setBroadcastEvent(publication)\n    });\n  }\n  if (video) {\n    return mapVideo(video, setContext);\n  }\n  return undefined;\n}\n\nfunction setInstruction(instruction) {\n  if (instruction) {\n    return _extends({}, instruction, {\n      '@type': 'HowToStep'\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$t = [\"type\", \"keyOverride\", \"ofType\", \"data\"],\n  _excluded2$1 = [\"authorName\", \"images\", \"yields\", \"category\", \"calories\", \"aggregateRating\", \"video\", \"ingredients\", \"instructions\", \"cuisine\"];\nfunction CarouselJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Carousel' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    ofType = _ref.ofType,\n    data = _ref.data,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$t);\n  function generateList(data, ofType) {\n    switch (ofType) {\n      case 'default':\n        return data.map(function (item, index) {\n          return {\n            '@type': 'ListItem',\n            position: \"\" + (index + 1),\n            url: item.url\n          };\n        });\n      case 'course':\n        return data.map(function (item, index) {\n          return {\n            '@type': 'ListItem',\n            position: \"\" + (index + 1),\n            item: {\n              '@context': 'https://schema.org',\n              '@type': 'Course',\n              url: item.url,\n              name: item.courseName,\n              description: item.description,\n              provider: {\n                '@type': 'Organization',\n                name: item.providerName,\n                sameAs: item.providerUrl\n              }\n            }\n          };\n        });\n      case 'movie':\n        return data.map(function (item, index) {\n          return {\n            '@type': 'ListItem',\n            position: \"\" + (index + 1),\n            item: {\n              '@context': 'https://schema.org',\n              '@type': 'Movie',\n              name: item.name,\n              url: item.url,\n              image: item.image,\n              dateCreated: item.dateCreated,\n              director: item.director ? Array.isArray(item.director) ? item.director.map(function (director) {\n                return {\n                  '@type': 'Person',\n                  name: director.name\n                };\n              }) : {\n                '@type': 'Person',\n                name: item.director.name\n              } : undefined,\n              review: setReviews(item.review)\n            }\n          };\n        });\n      case 'recipe':\n        return data.map(function (_ref2, index) {\n          var authorName = _ref2.authorName,\n            images = _ref2.images,\n            yields = _ref2.yields,\n            category = _ref2.category,\n            calories = _ref2.calories,\n            aggregateRating = _ref2.aggregateRating,\n            video = _ref2.video,\n            ingredients = _ref2.ingredients,\n            instructions = _ref2.instructions,\n            cuisine = _ref2.cuisine,\n            rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);\n          return {\n            '@type': 'ListItem',\n            position: \"\" + (index + 1),\n            item: _extends({\n              '@context': 'https://schema.org',\n              '@type': 'Recipe'\n            }, rest, {\n              author: setAuthor(authorName),\n              image: images,\n              recipeYield: yields,\n              recipeCategory: category,\n              recipeCuisine: cuisine,\n              nutrition: setNutrition(calories),\n              aggregateRating: setAggregateRating(aggregateRating),\n              video: setVideo(video),\n              recipeIngredient: ingredients,\n              recipeInstructions: instructions.map(setInstruction)\n            })\n          };\n        });\n    }\n  }\n  var jsonLdData = _extends({\n    '@type': 'ItemList',\n    itemListElement: generateList(data, ofType)\n  }, rest);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, jsonLdData, {\n    scriptKey: \"Carousel\"\n  }));\n}\n\nvar _excluded$s = [\"type\", \"keyOverride\", \"url\", \"title\", \"images\", \"section\", \"dateCreated\", \"datePublished\", \"dateModified\", \"authorName\", \"authorType\", \"publisherName\", \"publisherLogo\", \"body\", \"isAccessibleForFree\"];\nfunction NewsArticleJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'NewsArticle' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    url = _ref.url,\n    title = _ref.title,\n    images = _ref.images,\n    section = _ref.section,\n    dateCreated = _ref.dateCreated,\n    datePublished = _ref.datePublished,\n    dateModified = _ref.dateModified,\n    authorName = _ref.authorName,\n    publisherName = _ref.publisherName,\n    publisherLogo = _ref.publisherLogo,\n    body = _ref.body,\n    isAccessibleForFree = _ref.isAccessibleForFree,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$s);\n  var data = _extends({}, rest, {\n    mainEntityOfPage: {\n      '@type': 'WebPage',\n      '@id': url\n    },\n    headline: title,\n    image: images,\n    articleSection: section,\n    dateCreated: dateCreated || datePublished,\n    datePublished: datePublished,\n    dateModified: dateModified || datePublished,\n    author: setAuthor(authorName),\n    publisher: setPublisher(publisherName, publisherLogo),\n    articleBody: body,\n    isAccessibleForFree: isAccessibleForFree\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"NewsArticle\"\n  }));\n}\n\nvar _excluded$r = [\"type\", \"keyOverride\", \"baseSalary\", \"hiringOrganization\", \"applicantLocationRequirements\", \"experienceRequirements\", \"jobLocation\"];\nfunction JobPostingJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'JobPosting' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    baseSalary = _ref.baseSalary,\n    hiringOrganization = _ref.hiringOrganization,\n    applicantLocationRequirements = _ref.applicantLocationRequirements,\n    experienceRequirements = _ref.experienceRequirements,\n    jobLocation = _ref.jobLocation,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$r);\n  function setBaseSalary(baseSalary) {\n    if (baseSalary) {\n      return {\n        '@type': 'MonetaryAmount',\n        currency: baseSalary.currency,\n        value: _extends({\n          '@type': 'QuantitativeValue',\n          unitText: baseSalary.unitText\n        }, Array.isArray(baseSalary.value) ? {\n          minValue: baseSalary.value[0],\n          maxValue: baseSalary.value[1]\n        } : {\n          value: baseSalary.value\n        })\n      };\n    }\n    return undefined;\n  }\n  function setHiringOrganization(org) {\n    return {\n      '@type': 'Organization',\n      name: org.name,\n      sameAs: org.sameAs,\n      logo: org.logo\n    };\n  }\n  function setJobLocation(location) {\n    if (location) {\n      return {\n        '@type': 'Place',\n        address: {\n          '@type': 'PostalAddress',\n          addressCountry: location.addressCountry,\n          addressLocality: location.addressLocality,\n          addressRegion: location.addressRegion,\n          postalCode: location.postalCode,\n          streetAddress: location.streetAddress\n        }\n      };\n    }\n    return undefined;\n  }\n  function setApplicantLocationRequirements(requirements) {\n    if (requirements) {\n      return {\n        '@type': 'Country',\n        name: requirements\n      };\n    }\n    return undefined;\n  }\n  function setOccupationalExperienceRequirements(requirements) {\n    if (requirements) {\n      return {\n        '@type': requirements['@type'] ? requirements['@type'] : 'OccupationalExperienceRequirements',\n        monthsOfExperience: requirements.minimumMonthsOfExperience\n      };\n    }\n    return undefined;\n  }\n  function setEducationalOccupationalCredential(requirements) {\n    if (requirements) {\n      return {\n        '@type': requirements['@type'] ? requirements['@type'] : 'EducationalOccupationalCredential',\n        credentialCategory: requirements.credentialCategory\n      };\n    }\n    return undefined;\n  }\n  var data = _extends({}, rest, {\n    baseSalary: setBaseSalary(baseSalary),\n    hiringOrganization: setHiringOrganization(hiringOrganization),\n    jobLocation: setJobLocation(jobLocation),\n    applicantLocationRequirements: setApplicantLocationRequirements(applicantLocationRequirements),\n    experienceRequirements: setOccupationalExperienceRequirements(experienceRequirements == null ? void 0 : experienceRequirements.occupational),\n    educationRequirements: setEducationalOccupationalCredential(experienceRequirements == null ? void 0 : experienceRequirements.educational),\n    experienceInPlaceOfEducation: experienceRequirements == null ? void 0 : experienceRequirements.experienceInPlaceOfEducation\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"JobPosting\"\n  }));\n}\n\nfunction setAddress(address) {\n  if (!address) return undefined;\n  if (!Array.isArray(address)) return toPostalAddress(address);\n  // If array of one address, replace with single address\n  if (address.length === 1) return toPostalAddress(address[0]);\n  // If array, return mapped array of PostalAddresses\n  return address.map(toPostalAddress);\n}\nfunction toPostalAddress(address) {\n  if (typeof address === 'string') return address;\n  return _extends({\n    '@type': 'PostalAddress'\n  }, address);\n}\n\nfunction setGeo(geo) {\n  if (geo) {\n    return _extends({}, geo, {\n      '@type': 'GeoCoordinates'\n    });\n  }\n  return undefined;\n}\n\nfunction setAction(action) {\n  if (action) {\n    return {\n      '@type': action.actionType,\n      name: action.actionName,\n      target: action.target\n    };\n  }\n  return undefined;\n}\n\nfunction setGeoCircle(geoCircle) {\n  if (geoCircle) {\n    return {\n      '@type': 'GeoCircle',\n      geoMidpoint: {\n        '@type': 'GeoCoordinates',\n        latitude: geoCircle.geoMidpoint.latitude,\n        longitude: geoCircle.geoMidpoint.longitude\n      },\n      geoRadius: geoCircle.geoRadius\n    };\n  }\n  return undefined;\n}\n\nfunction setOffer(offer) {\n  function setPriceSpecification(priceSpecification) {\n    if (priceSpecification) {\n      return {\n        '@type': priceSpecification.type,\n        priceCurrency: priceSpecification.priceCurrency,\n        price: priceSpecification.price\n      };\n    }\n    return undefined;\n  }\n  function setItemOffered(itemOffered) {\n    if (itemOffered) {\n      return _extends({}, itemOffered, {\n        '@type': 'Service'\n      });\n    }\n    return undefined;\n  }\n  if (offer) {\n    return _extends({}, offer, {\n      '@type': 'Offer',\n      priceSpecification: setPriceSpecification(offer.priceSpecification),\n      itemOffered: setItemOffered(offer.itemOffered)\n    });\n  }\n  return undefined;\n}\n\nfunction setOpeningHours(openingHours) {\n  if (openingHours) {\n    return _extends({}, openingHours, {\n      '@type': 'OpeningHoursSpecification'\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$q = [\"type\", \"keyOverride\", \"address\", \"geo\", \"rating\", \"review\", \"action\", \"areaServed\", \"makesOffer\", \"openingHours\", \"images\"];\nfunction LocalBusinessJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'LocalBusiness' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    address = _ref.address,\n    geo = _ref.geo,\n    rating = _ref.rating,\n    review = _ref.review,\n    action = _ref.action,\n    areaServed = _ref.areaServed,\n    makesOffer = _ref.makesOffer,\n    openingHours = _ref.openingHours,\n    images = _ref.images,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$q);\n  var data = _extends({}, rest, {\n    image: images,\n    address: setAddress(address),\n    geo: setGeo(geo),\n    aggregateRating: setAggregateRating(rating),\n    review: setReviews(review),\n    potentialAction: setAction(action),\n    areaServed: areaServed && areaServed.map(setGeoCircle),\n    makesOffer: makesOffer == null ? void 0 : makesOffer.map(setOffer),\n    openingHoursSpecification: Array.isArray(openingHours) ? openingHours.map(setOpeningHours) : setOpeningHours(openingHours)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"LocalBusiness\"\n  }));\n}\n\nvar _excluded$p = [\"type\", \"keyOverride\", \"mainEntity\"],\n  _excluded2 = [\"upvoteCount\"];\nfunction QAPageJsonLd(_ref) {\n  var _mainEntity$author, _mainEntity$acceptedA, _mainEntity$acceptedA2;\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'QAPage' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    mainEntity = _ref.mainEntity,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$p);\n  var data = _extends({}, rest, {\n    mainEntity: _extends({}, mainEntity, {\n      '@type': 'Question',\n      author: setAuthor((_mainEntity$author = mainEntity.author) == null ? void 0 : _mainEntity$author.name)\n    }, mainEntity.acceptedAnswer && {\n      acceptedAnswer: _extends({}, mainEntity.acceptedAnswer, {\n        '@type': 'Answer',\n        author: setAuthor((_mainEntity$acceptedA = mainEntity.acceptedAnswer) == null ? void 0 : (_mainEntity$acceptedA2 = _mainEntity$acceptedA.author) == null ? void 0 : _mainEntity$acceptedA2.name)\n      })\n    }, mainEntity.suggestedAnswer && {\n      suggestedAnswer: mainEntity.suggestedAnswer.map(function (_ref2) {\n        var _rest$author;\n        var upvoteCount = _ref2.upvoteCount,\n          rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n        return _extends({}, rest, {\n          '@type': 'Answer',\n          upvoteCount: upvoteCount || 0,\n          author: setAuthor((_rest$author = rest.author) == null ? void 0 : _rest$author.name)\n        });\n      })\n    })\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"QAPage\"\n  }));\n}\n\nfunction setItemListElements(items) {\n  if (items && items.length) {\n    return items.map(function (item) {\n      return {\n        '@type': 'ListItem',\n        position: item.position,\n        item: {\n          '@id': item.item,\n          name: item.name\n        }\n      };\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$o = [\"type\", \"keyOverride\", \"breadcrumb\"];\nfunction ProfilePageJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'ProfilePage' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    breadcrumb = _ref.breadcrumb,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$o);\n  var data = _extends({}, rest, {\n    breadcrumb: Array.isArray(breadcrumb) ? {\n      '@type': 'BreadcrumbList',\n      itemListElement: setItemListElements(breadcrumb)\n    } : breadcrumb\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"ProfilePage\"\n  }));\n}\n\nvar _excluded$n = [\"type\", \"keyOverride\", \"potentialActions\"];\nfunction SiteLinksSearchBoxJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'WebSite' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    potentialActions = _ref.potentialActions,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$n);\n  function setPotentialAction(action) {\n    if (action) {\n      var target = action.target,\n        queryInput = action.queryInput;\n      return {\n        '@type': 'SearchAction',\n        target: target + \"={\" + queryInput + \"}\",\n        'query-input': \"required name=\" + queryInput\n      };\n    }\n    return undefined;\n  }\n  var data = _extends({}, rest, {\n    potentialAction: potentialActions.map(setPotentialAction)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"jsonld-siteLinksSearchBox\"\n  }));\n}\n\nvar _excluded$m = [\"type\", \"keyOverride\", \"authorName\", \"images\", \"yields\", \"category\", \"cuisine\", \"calories\", \"aggregateRating\", \"video\", \"ingredients\", \"instructions\"];\nfunction RecipeJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Recipe' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    authorName = _ref.authorName,\n    images = _ref.images,\n    yields = _ref.yields,\n    category = _ref.category,\n    cuisine = _ref.cuisine,\n    calories = _ref.calories,\n    aggregateRating = _ref.aggregateRating,\n    video = _ref.video,\n    ingredients = _ref.ingredients,\n    instructions = _ref.instructions,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$m);\n  var data = _extends({}, rest, {\n    author: setAuthor(authorName),\n    image: images,\n    recipeYield: yields,\n    recipeCategory: category,\n    recipeCuisine: cuisine,\n    nutrition: setNutrition(calories),\n    aggregateRating: setAggregateRating(aggregateRating),\n    video: setVideo(video),\n    recipeIngredient: ingredients,\n    recipeInstructions: instructions ? instructions.map(setInstruction) : undefined\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"recipe\"\n  }));\n}\n\nfunction setLocation(location) {\n  if (!location) {\n    return undefined;\n  }\n  if (typeof location === 'string') {\n    return location;\n  }\n  if ('url' in location) {\n    return setVirtualLocation(location);\n  } else {\n    return setPlace(location);\n  }\n}\nfunction setVirtualLocation(location) {\n  return _extends({}, location, {\n    '@type': 'VirtualLocation'\n  });\n}\nfunction setPlace(location) {\n  return _extends({}, location, {\n    address: setAddress(location.address),\n    '@type': 'Place'\n  });\n}\n\nvar _excluded$l = [\"type\"];\nfunction setPerformer(performer) {\n  if (performer) {\n    var type = performer.type,\n      restPerformer = _objectWithoutPropertiesLoose(performer, _excluded$l);\n    return _extends({}, restPerformer, {\n      '@type': type || 'PerformingGroup'\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$k = [\"seller\"];\nfunction setOffers(offers) {\n  function mapOffer(_ref) {\n    var seller = _ref.seller,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded$k);\n    return _extends({}, rest, {\n      '@type': 'Offer'\n    }, seller && {\n      seller: {\n        '@type': 'Organization',\n        name: seller.name\n      }\n    });\n  }\n  if (Array.isArray(offers)) {\n    return offers.map(mapOffer);\n  } else if (offers) {\n    return mapOffer(offers);\n  }\n  return undefined;\n}\n\nfunction setAggregateOffer(aggregateOffer) {\n  if (aggregateOffer) {\n    return {\n      '@type': 'AggregateOffer',\n      priceCurrency: aggregateOffer.priceCurrency,\n      highPrice: aggregateOffer.highPrice,\n      lowPrice: aggregateOffer.lowPrice,\n      offerCount: aggregateOffer.offerCount,\n      offers: setOffers(aggregateOffer.offers)\n    };\n  }\n  return undefined;\n}\n\nvar _excluded$j = [\"type\"];\nfunction setOrganizer(organizer) {\n  if (organizer) {\n    var type = organizer.type,\n      restOrganizer = _objectWithoutPropertiesLoose(organizer, _excluded$j);\n    return _extends({}, restOrganizer, {\n      '@type': type || 'Person'\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$i = [\"type\", \"keyOverride\", \"location\", \"images\", \"offers\", \"aggregateOffer\", \"performers\", \"organizer\", \"eventStatus\", \"eventAttendanceMode\"];\nfunction EventJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Event' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    location = _ref.location,\n    images = _ref.images,\n    offers = _ref.offers,\n    aggregateOffer = _ref.aggregateOffer,\n    performers = _ref.performers,\n    organizer = _ref.organizer,\n    eventStatus = _ref.eventStatus,\n    eventAttendanceMode = _ref.eventAttendanceMode,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$i);\n  var data = _extends({}, rest, {\n    location: setLocation(location),\n    image: images,\n    offers: offers ? setOffers(offers) : setAggregateOffer(aggregateOffer),\n    performer: Array.isArray(performers) ? performers.map(setPerformer) : setPerformer(performers),\n    organizer: Array.isArray(organizer) ? organizer.map(setOrganizer) : setOrganizer(organizer),\n    eventStatus: eventStatus ? \"https://schema.org/\" + eventStatus : undefined,\n    eventAttendanceMode: eventAttendanceMode ? \"https://schema.org/\" + eventAttendanceMode : undefined\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"Event\"\n  }));\n}\n\nfunction setContactPoint(contactPoint) {\n  if (contactPoint) {\n    return _extends({}, contactPoint, {\n      '@type': 'ContactPoint'\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$h = [\"type\", \"keyOverride\", \"contactPoint\"];\nfunction CorporateContactJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Organization' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    contactPoint = _ref.contactPoint,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$h);\n  var data = _extends({}, rest, {\n    contactPoint: contactPoint.map(setContactPoint)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"CorporateContact\"\n  }));\n}\n\nfunction setCreativeWork(creativeWork) {\n  if (creativeWork) {\n    return _extends({}, creativeWork, {\n      '@type': 'CreativeWork'\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$g = [\"type\", \"keyOverride\", \"hasPart\"];\nfunction CollectionPageJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'CollectionPage' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    hasPart = _ref.hasPart,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$g);\n  var data = _extends({}, rest, {\n    hasPart: hasPart.map(setCreativeWork)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"CollectionPage\"\n  }));\n}\n\nfunction setManufacturer(manufacturer) {\n  if (manufacturer && (manufacturer.manufacturerName || manufacturer.manufacturerLogo)) {\n    return {\n      '@type': 'Organization',\n      name: manufacturer.manufacturerName,\n      logo: setImage(manufacturer.manufacturerLogo)\n    };\n  }\n  return undefined;\n}\n\nfunction setBrand(brand) {\n  if (brand) {\n    return {\n      '@type': 'Brand',\n      name: brand\n    };\n  }\n  return undefined;\n}\n\nvar _excluded$f = [\"type\", \"keyOverride\", \"images\", \"brand\", \"reviews\", \"aggregateRating\", \"manufacturerLogo\", \"manufacturerName\", \"offers\", \"aggregateOffer\", \"productName\"];\nfunction ProductJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Product' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    images = _ref.images,\n    brand = _ref.brand,\n    reviews = _ref.reviews,\n    aggregateRating = _ref.aggregateRating,\n    manufacturerLogo = _ref.manufacturerLogo,\n    manufacturerName = _ref.manufacturerName,\n    offers = _ref.offers,\n    aggregateOffer = _ref.aggregateOffer,\n    productName = _ref.productName,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$f);\n  var data = _extends({}, rest, {\n    image: images,\n    brand: setBrand(brand),\n    review: setReviews(reviews),\n    aggregateRating: setAggregateRating(aggregateRating),\n    manufacturer: setManufacturer({\n      manufacturerLogo: manufacturerLogo,\n      manufacturerName: manufacturerName\n    }),\n    offers: offers ? setOffers(offers) : setAggregateOffer(aggregateOffer),\n    name: productName\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"Product\"\n  }));\n}\n\nvar _excluded$e = [\"type\", \"keyOverride\", \"priceCurrency\", \"price\", \"aggregateRating\", \"review\"];\nfunction SoftwareAppJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'SoftwareApplication' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    priceCurrency = _ref.priceCurrency,\n    price = _ref.price,\n    aggregateRating = _ref.aggregateRating,\n    review = _ref.review,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$e);\n  var data = _extends({}, rest, {\n    offers: {\n      '@type': 'Offer',\n      price: price,\n      priceCurrency: priceCurrency\n    },\n    aggregateRating: setAggregateRating(aggregateRating),\n    review: setReviews(review)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"SoftwareApp\"\n  }));\n}\n\nvar _excluded$d = [\"type\", \"keyOverride\"];\nfunction VideoJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Video' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$d);\n  var data = setVideo(rest, true);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"Video\"\n  }));\n}\n\nfunction setProducer(producer) {\n  if (producer) {\n    return {\n      '@type': 'Organization',\n      sameAs: producer.url,\n      name: producer.name\n    };\n  }\n  return undefined;\n}\n\nfunction setProvider(provider) {\n  if (provider) {\n    return {\n      '@type': provider.type || 'Organization',\n      name: provider.name,\n      sameAs: provider.url\n    };\n  }\n  return undefined;\n}\n\nvar _excluded$c = [\"type\", \"keyOverride\", \"aggregateRating\", \"trailer\", \"reviews\", \"image\", \"authorName\", \"provider\", \"producerName\", \"producerUrl\", \"offers\", \"operatingSystemName\", \"platformName\", \"translatorName\", \"languageName\", \"genreName\", \"publisherName\"];\nfunction VideoGameJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'VideoGame' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    aggregateRating = _ref.aggregateRating,\n    trailer = _ref.trailer,\n    reviews = _ref.reviews,\n    image = _ref.image,\n    authorName = _ref.authorName,\n    provider = _ref.provider,\n    producerName = _ref.producerName,\n    producerUrl = _ref.producerUrl,\n    offers = _ref.offers,\n    operatingSystemName = _ref.operatingSystemName,\n    platformName = _ref.platformName,\n    translatorName = _ref.translatorName,\n    languageName = _ref.languageName,\n    genreName = _ref.genreName,\n    publisherName = _ref.publisherName,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$c);\n  var data = _extends({}, rest, {\n    aggregateRating: setAggregateRating(aggregateRating),\n    trailer: setVideo(trailer),\n    review: setReviews(reviews),\n    image: setImage(image),\n    author: setAuthor(authorName),\n    provider: setProvider(provider),\n    producer: setProducer({\n      name: producerName,\n      url: producerUrl\n    }),\n    offers: setOffers(offers),\n    operatingSystem: operatingSystemName,\n    gamePlatform: platformName,\n    translator: translatorName,\n    inLanguage: languageName,\n    genre: genreName,\n    publisher: publisherName\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"VideoGame\"\n  }));\n}\n\nfunction setContactPoints(contactPoint) {\n  if (contactPoint && contactPoint.length) {\n    return contactPoint.map(function (contactPoint) {\n      return _extends({\n        '@type': 'ContactPoint'\n      }, contactPoint);\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$b = [\"type\", \"keyOverride\", \"address\", \"contactPoints\", \"contactPoint\"];\nfunction OrganizationJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Organization' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    address = _ref.address,\n    contactPoints = _ref.contactPoints,\n    contactPoint = _ref.contactPoint,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$b);\n  var data = _extends({}, rest, {\n    address: setAddress(address),\n    contactPoint: setContactPoints(contactPoint || contactPoints)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"organization\"\n  }));\n}\n\nfunction setQuestions(questions) {\n  if (questions && questions.length) {\n    return questions.map(function (question) {\n      return {\n        '@type': 'Question',\n        name: question.questionName,\n        acceptedAnswer: {\n          '@type': 'Answer',\n          text: question.acceptedAnswerText\n        }\n      };\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$a = [\"type\", \"keyOverride\", \"mainEntity\"];\nfunction FAQPageJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'FAQPage' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    mainEntity = _ref.mainEntity,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$a);\n  var data = _extends({}, rest, {\n    mainEntity: setQuestions(mainEntity)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"faq-page\"\n  }));\n}\n\nvar _excluded$9 = [\"type\", \"keyOverride\"];\nfunction LogoJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Organization' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$9);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, rest, {\n    scriptKey: \"Logo\"\n  }));\n}\n\nvar _excluded$8 = [\"type\", \"keyOverride\"];\nfunction DatasetJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Dataset' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$8);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, rest, {\n    scriptKey: \"dataset\"\n  }));\n}\n\nvar _excluded$7 = [\"type\", \"keyOverride\", \"courseName\", \"provider\"];\nfunction CourseJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Course' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    courseName = _ref.courseName,\n    provider = _ref.provider,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$7);\n  var data = _extends({\n    name: courseName\n  }, rest, {\n    provider: setProvider(provider)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"course\"\n  }));\n}\n\nvar _excluded$6 = [\"type\", \"keyOverride\", \"itemListElements\"];\nfunction BreadCrumbJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'BreadcrumbList' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    itemListElements = _ref.itemListElements,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$6);\n  var data = _extends({}, rest, {\n    itemListElement: setItemListElements(itemListElements)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"breadcrumb\"\n  }));\n}\n\nvar _excluded$5 = [\"type\", \"id\", \"keyOverride\", \"aggregateRating\"];\nfunction BrandJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Brand' : _ref$type,\n    id = _ref.id,\n    keyOverride = _ref.keyOverride,\n    aggregateRating = _ref.aggregateRating,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$5);\n  var data = _extends({\n    aggregateRating: setAggregateRating(aggregateRating),\n    '@id': id\n  }, rest);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"brand\"\n  }));\n}\n\nvar _excluded$4 = [\"type\", \"keyOverride\", \"url\", \"title\", \"images\", \"datePublished\", \"dateModified\", \"authorName\", \"publisherName\", \"publisherLogo\", \"description\", \"isAccessibleForFree\"];\nfunction ArticleJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'Article' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    url = _ref.url,\n    title = _ref.title,\n    images = _ref.images,\n    datePublished = _ref.datePublished,\n    dateModified = _ref.dateModified,\n    authorName = _ref.authorName,\n    _ref$publisherName = _ref.publisherName,\n    publisherName = _ref$publisherName === void 0 ? undefined : _ref$publisherName,\n    _ref$publisherLogo = _ref.publisherLogo,\n    publisherLogo = _ref$publisherLogo === void 0 ? undefined : _ref$publisherLogo,\n    description = _ref.description,\n    isAccessibleForFree = _ref.isAccessibleForFree,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$4);\n  var data = _extends({\n    datePublished: datePublished,\n    description: description,\n    mainEntityOfPage: {\n      '@type': 'WebPage',\n      '@id': url\n    },\n    headline: title,\n    image: images,\n    dateModified: dateModified || datePublished,\n    author: setAuthor(authorName),\n    publisher: setPublisher(publisherName, publisherLogo),\n    isAccessibleForFree: isAccessibleForFree\n  }, rest);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"article\"\n  }));\n}\n\nfunction setReviewedBy(reviewedBy) {\n  if (reviewedBy) {\n    return _extends({\n      '@type': (reviewedBy == null ? void 0 : reviewedBy.type) || 'Organization'\n    }, reviewedBy);\n  }\n  return undefined;\n}\n\nvar _excluded$3 = [\"keyOverride\", \"reviewedBy\"];\nfunction WebPageJsonLd(_ref) {\n  var keyOverride = _ref.keyOverride,\n    reviewedBy = _ref.reviewedBy,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);\n  var data = _extends({}, rest, {\n    reviewedBy: setReviewedBy(reviewedBy)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    keyOverride: keyOverride\n  }, data, {\n    type: \"WebPage\",\n    scriptKey: \"WebPage\"\n  }));\n}\n\nvar _excluded$2 = [\"type\", \"keyOverride\"];\nfunction SocialProfileJsonLd(_ref) {\n  var type = _ref.type,\n    keyOverride = _ref.keyOverride,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, rest, {\n    scriptKey: \"social\"\n  }));\n}\n\nfunction setCost(cost) {\n  if (cost) {\n    return _extends({}, cost, {\n      '@type': 'MonetaryAmount'\n    });\n  }\n  return undefined;\n}\n\nfunction setSupply(supply) {\n  if (supply) {\n    return supply.map(function (supplyItem) {\n      return {\n        '@type': 'HowToSupply',\n        name: supplyItem\n      };\n    });\n  }\n  return undefined;\n}\n\nfunction setTool(tool) {\n  if (tool) {\n    return tool.map(function (toolItem) {\n      return {\n        '@type': 'HowToTool',\n        name: toolItem\n      };\n    });\n  }\n  return undefined;\n}\n\nfunction setStep(step) {\n  if (step) {\n    return step.map(function (stepElement) {\n      var itemListElement = stepElement.itemListElement,\n        image = stepElement.image;\n      var currentListElements = itemListElement == null ? void 0 : itemListElement.map(function (_ref) {\n        var type = _ref.type,\n          text = _ref.text;\n        return {\n          '@type': type,\n          text: text\n        };\n      });\n      return _extends({}, stepElement, {\n        '@type': 'HowToStep',\n        itemListElement: currentListElements,\n        image: setImage(image)\n      });\n    });\n  }\n  return undefined;\n}\n\nvar _excluded$1 = [\"type\", \"keyOverride\", \"image\", \"estimatedCost\", \"supply\", \"tool\", \"step\"];\nfunction howToJsonLd(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'HowTo' : _ref$type,\n    keyOverride = _ref.keyOverride,\n    image = _ref.image,\n    estimatedCost = _ref.estimatedCost,\n    supply = _ref.supply,\n    tool = _ref.tool,\n    step = _ref.step,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n  var data = _extends({}, rest, {\n    image: setImage(image),\n    estimatedCost: setCost(estimatedCost),\n    supply: setSupply(supply),\n    tool: setTool(tool),\n    step: setStep(step)\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({\n    type: type,\n    keyOverride: keyOverride\n  }, data, {\n    scriptKey: \"howTo\"\n  }));\n}\n\nvar _excluded = [\"keyOverride\", \"images\"];\nfunction ImageJsonLd(_ref) {\n  var keyOverride = _ref.keyOverride,\n    images = _ref.images,\n    rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(JsonLd, _extends({}, rest, {\n    type: \"ImageObject\",\n    keyOverride: keyOverride,\n    dataArray: images,\n    scriptKey: \"image\"\n  }));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1zZW8vbGliL25leHQtc2VvLm1vZHVsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDRzs7QUFFN0I7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QiwwREFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw4QkFBOEIsMERBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsOEJBQThCLDBEQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhCQUE4QiwwREFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTiw4QkFBOEIsMERBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsOEJBQThCLDBEQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLDhCQUE4QiwwREFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFtQjtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLG9DQUFvQywwREFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQ0FBb0MsMERBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQywwREFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNDQUFzQywwREFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQ0FBc0MsMERBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwREFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBDQUEwQywwREFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMENBQTBDLDBEQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDBDQUEwQywwREFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLDBDQUEwQywwREFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsMERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMENBQTBDLDBEQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDBDQUEwQywwREFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwREFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMENBQTBDLDBEQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBEQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwREFBbUI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSw4Q0FBOEMsMERBQW1CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBEQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMENBQTBDLDBEQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBEQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSwwQ0FBMEMsMERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMERBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBEQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBEQUFtQjtBQUN6RDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMERBQW1CO0FBQ3pEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMERBQW1CLENBQUMsa0RBQUk7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFtQixDQUFDLHVEQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQkFBaUIsMERBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QiwwREFBbUI7QUFDM0M7QUFDQSxzQkFBc0IsMERBQW1CLENBQUMsa0RBQUk7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQiwwREFBbUI7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQiwwREFBbUI7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLDBEQUFtQjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsMERBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsMERBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLDBEQUFtQjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQW1CLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFd2dCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LXNlby9saWIvbmV4dC1zZW8ubW9kdWxlLmpzPzgzYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIF9leGNsdWRlZCR4ID0gW1wia2V5T3ZlcnJpZGVcIl07XG52YXIgZGVmYXVsdHMgPSB7XG4gIHRlbXBsYXRlVGl0bGU6ICcnLFxuICBub2luZGV4OiBmYWxzZSxcbiAgbm9mb2xsb3c6IGZhbHNlLFxuICBkZWZhdWx0T3BlbkdyYXBoSW1hZ2VXaWR0aDogMCxcbiAgZGVmYXVsdE9wZW5HcmFwaEltYWdlSGVpZ2h0OiAwLFxuICBkZWZhdWx0T3BlbkdyYXBoVmlkZW9XaWR0aDogMCxcbiAgZGVmYXVsdE9wZW5HcmFwaFZpZGVvSGVpZ2h0OiAwXG59O1xudmFyIGJ1aWxkT3BlbkdyYXBoTWVkaWFUYWdzID0gZnVuY3Rpb24gYnVpbGRPcGVuR3JhcGhNZWRpYVRhZ3MobWVkaWFUeXBlLCBtZWRpYSwgX3RlbXApIHtcbiAgaWYgKG1lZGlhID09PSB2b2lkIDApIHtcbiAgICBtZWRpYSA9IFtdO1xuICB9XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgZGVmYXVsdFdpZHRoID0gX3JlZi5kZWZhdWx0V2lkdGgsXG4gICAgZGVmYXVsdEhlaWdodCA9IF9yZWYuZGVmYXVsdEhlaWdodDtcbiAgcmV0dXJuIG1lZGlhLnJlZHVjZShmdW5jdGlvbiAodGFncywgbWVkaXVtLCBpbmRleCkge1xuICAgIHRhZ3MucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOjBcIiArIGluZGV4LFxuICAgICAgcHJvcGVydHk6IFwib2c6XCIgKyBtZWRpYVR5cGUsXG4gICAgICBjb250ZW50OiBtZWRpdW0udXJsXG4gICAgfSkpO1xuICAgIGlmIChtZWRpdW0uYWx0KSB7XG4gICAgICB0YWdzLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOmFsdDBcIiArIGluZGV4LFxuICAgICAgICBwcm9wZXJ0eTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOmFsdFwiLFxuICAgICAgICBjb250ZW50OiBtZWRpdW0uYWx0XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChtZWRpdW0uc2VjdXJlVXJsKSB7XG4gICAgICB0YWdzLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOnNlY3VyZV91cmwwXCIgKyBpbmRleCxcbiAgICAgICAgcHJvcGVydHk6IFwib2c6XCIgKyBtZWRpYVR5cGUgKyBcIjpzZWN1cmVfdXJsXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lZGl1bS5zZWN1cmVVcmwudG9TdHJpbmcoKVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAobWVkaXVtLnR5cGUpIHtcbiAgICAgIHRhZ3MucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAga2V5OiBcIm9nOlwiICsgbWVkaWFUeXBlICsgXCI6dHlwZTBcIiArIGluZGV4LFxuICAgICAgICBwcm9wZXJ0eTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOnR5cGVcIixcbiAgICAgICAgY29udGVudDogbWVkaXVtLnR5cGUudG9TdHJpbmcoKVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAobWVkaXVtLndpZHRoKSB7XG4gICAgICB0YWdzLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOndpZHRoMFwiICsgaW5kZXgsXG4gICAgICAgIHByb3BlcnR5OiBcIm9nOlwiICsgbWVkaWFUeXBlICsgXCI6d2lkdGhcIixcbiAgICAgICAgY29udGVudDogbWVkaXVtLndpZHRoLnRvU3RyaW5nKClcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRXaWR0aCkge1xuICAgICAgdGFncy5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICBrZXk6IFwib2c6XCIgKyBtZWRpYVR5cGUgKyBcIjp3aWR0aDBcIiArIGluZGV4LFxuICAgICAgICBwcm9wZXJ0eTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOndpZHRoXCIsXG4gICAgICAgIGNvbnRlbnQ6IGRlZmF1bHRXaWR0aC50b1N0cmluZygpXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChtZWRpdW0uaGVpZ2h0KSB7XG4gICAgICB0YWdzLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOmhlaWdodFwiICsgaW5kZXgsXG4gICAgICAgIHByb3BlcnR5OiBcIm9nOlwiICsgbWVkaWFUeXBlICsgXCI6aGVpZ2h0XCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lZGl1bS5oZWlnaHQudG9TdHJpbmcoKVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdEhlaWdodCkge1xuICAgICAgdGFncy5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICBrZXk6IFwib2c6XCIgKyBtZWRpYVR5cGUgKyBcIjpoZWlnaHRcIiArIGluZGV4LFxuICAgICAgICBwcm9wZXJ0eTogXCJvZzpcIiArIG1lZGlhVHlwZSArIFwiOmhlaWdodFwiLFxuICAgICAgICBjb250ZW50OiBkZWZhdWx0SGVpZ2h0LnRvU3RyaW5nKClcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH0sIFtdKTtcbn07XG52YXIgYnVpbGRUYWdzID0gZnVuY3Rpb24gYnVpbGRUYWdzKGNvbmZpZykge1xuICB2YXIgX2NvbmZpZyRvcGVuR3JhcGgsIF9jb25maWckb3BlbkdyYXBoMywgX2NvbmZpZyRhZGRpdGlvbmFsTGluO1xuICB2YXIgdGFnc1RvUmVuZGVyID0gW107XG4gIGlmIChjb25maWcudGl0bGVUZW1wbGF0ZSkge1xuICAgIGRlZmF1bHRzLnRlbXBsYXRlVGl0bGUgPSBjb25maWcudGl0bGVUZW1wbGF0ZTtcbiAgfVxuICB2YXIgdXBkYXRlZFRpdGxlID0gJyc7XG4gIGlmIChjb25maWcudGl0bGUpIHtcbiAgICB1cGRhdGVkVGl0bGUgPSBjb25maWcudGl0bGU7XG4gICAgaWYgKGRlZmF1bHRzLnRlbXBsYXRlVGl0bGUpIHtcbiAgICAgIHVwZGF0ZWRUaXRsZSA9IGRlZmF1bHRzLnRlbXBsYXRlVGl0bGUucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlZFRpdGxlO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbmZpZy5kZWZhdWx0VGl0bGUpIHtcbiAgICB1cGRhdGVkVGl0bGUgPSBjb25maWcuZGVmYXVsdFRpdGxlO1xuICB9XG4gIGlmICh1cGRhdGVkVGl0bGUpIHtcbiAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCB7XG4gICAgICBrZXk6IFwidGl0bGVcIlxuICAgIH0sIHVwZGF0ZWRUaXRsZSkpO1xuICB9XG4gIHZhciBub2luZGV4ID0gY29uZmlnLm5vaW5kZXggfHwgZGVmYXVsdHMubm9pbmRleCB8fCBjb25maWcuZGFuZ2Vyb3VzbHlTZXRBbGxQYWdlc1RvTm9JbmRleDtcbiAgdmFyIG5vZm9sbG93ID0gY29uZmlnLm5vZm9sbG93IHx8IGRlZmF1bHRzLm5vZm9sbG93IHx8IGNvbmZpZy5kYW5nZXJvdXNseVNldEFsbFBhZ2VzVG9Ob0ZvbGxvdztcbiAgdmFyIHJvYm90c1BhcmFtcyA9ICcnO1xuICBpZiAoY29uZmlnLnJvYm90c1Byb3BzKSB7XG4gICAgdmFyIF9jb25maWckcm9ib3RzUHJvcHMgPSBjb25maWcucm9ib3RzUHJvcHMsXG4gICAgICBub3NuaXBwZXQgPSBfY29uZmlnJHJvYm90c1Byb3BzLm5vc25pcHBldCxcbiAgICAgIG1heFNuaXBwZXQgPSBfY29uZmlnJHJvYm90c1Byb3BzLm1heFNuaXBwZXQsXG4gICAgICBtYXhJbWFnZVByZXZpZXcgPSBfY29uZmlnJHJvYm90c1Byb3BzLm1heEltYWdlUHJldmlldyxcbiAgICAgIG1heFZpZGVvUHJldmlldyA9IF9jb25maWckcm9ib3RzUHJvcHMubWF4VmlkZW9QcmV2aWV3LFxuICAgICAgbm9hcmNoaXZlID0gX2NvbmZpZyRyb2JvdHNQcm9wcy5ub2FyY2hpdmUsXG4gICAgICBub2ltYWdlaW5kZXggPSBfY29uZmlnJHJvYm90c1Byb3BzLm5vaW1hZ2VpbmRleCxcbiAgICAgIG5vdHJhbnNsYXRlID0gX2NvbmZpZyRyb2JvdHNQcm9wcy5ub3RyYW5zbGF0ZSxcbiAgICAgIHVuYXZhaWxhYmxlQWZ0ZXIgPSBfY29uZmlnJHJvYm90c1Byb3BzLnVuYXZhaWxhYmxlQWZ0ZXI7XG4gICAgcm9ib3RzUGFyYW1zID0gXCJcIiArIChub3NuaXBwZXQgPyAnLG5vc25pcHBldCcgOiAnJykgKyAobWF4U25pcHBldCA/IFwiLG1heC1zbmlwcGV0OlwiICsgbWF4U25pcHBldCA6ICcnKSArIChtYXhJbWFnZVByZXZpZXcgPyBcIixtYXgtaW1hZ2UtcHJldmlldzpcIiArIG1heEltYWdlUHJldmlldyA6ICcnKSArIChub2FyY2hpdmUgPyAnLG5vYXJjaGl2ZScgOiAnJykgKyAodW5hdmFpbGFibGVBZnRlciA/IFwiLHVuYXZhaWxhYmxlX2FmdGVyOlwiICsgdW5hdmFpbGFibGVBZnRlciA6ICcnKSArIChub2ltYWdlaW5kZXggPyAnLG5vaW1hZ2VpbmRleCcgOiAnJykgKyAobWF4VmlkZW9QcmV2aWV3ID8gXCIsbWF4LXZpZGVvLXByZXZpZXc6XCIgKyBtYXhWaWRlb1ByZXZpZXcgOiAnJykgKyAobm90cmFuc2xhdGUgPyAnLG5vdHJhbnNsYXRlJyA6ICcnKTtcbiAgfVxuICBpZiAobm9pbmRleCB8fCBub2ZvbGxvdykge1xuICAgIGlmIChjb25maWcuZGFuZ2Vyb3VzbHlTZXRBbGxQYWdlc1RvTm9JbmRleCkge1xuICAgICAgZGVmYXVsdHMubm9pbmRleCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjb25maWcuZGFuZ2Vyb3VzbHlTZXRBbGxQYWdlc1RvTm9Gb2xsb3cpIHtcbiAgICAgIGRlZmF1bHRzLm5vZm9sbG93ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IFwicm9ib3RzXCIsXG4gICAgICBuYW1lOiBcInJvYm90c1wiLFxuICAgICAgY29udGVudDogKG5vaW5kZXggPyAnbm9pbmRleCcgOiAnaW5kZXgnKSArIFwiLFwiICsgKG5vZm9sbG93ID8gJ25vZm9sbG93JyA6ICdmb2xsb3cnKSArIHJvYm90c1BhcmFtc1xuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogXCJyb2JvdHNcIixcbiAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICBjb250ZW50OiBcImluZGV4LGZvbGxvd1wiICsgcm9ib3RzUGFyYW1zXG4gICAgfSkpO1xuICB9XG4gIGlmIChjb25maWcuZGVzY3JpcHRpb24pIHtcbiAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogXCJkZXNjcmlwdGlvblwiLFxuICAgICAgbmFtZTogXCJkZXNjcmlwdGlvblwiLFxuICAgICAgY29udGVudDogY29uZmlnLmRlc2NyaXB0aW9uXG4gICAgfSkpO1xuICB9XG4gIGlmIChjb25maWcudGhlbWVDb2xvcikge1xuICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBcInRoZW1lLWNvbG9yXCIsXG4gICAgICBuYW1lOiBcInRoZW1lLWNvbG9yXCIsXG4gICAgICBjb250ZW50OiBjb25maWcudGhlbWVDb2xvclxuICAgIH0pKTtcbiAgfVxuICBpZiAoY29uZmlnLm1vYmlsZUFsdGVybmF0ZSkge1xuICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgICAgcmVsOiBcImFsdGVybmF0ZVwiLFxuICAgICAga2V5OiBcIm1vYmlsZUFsdGVybmF0ZVwiLFxuICAgICAgbWVkaWE6IGNvbmZpZy5tb2JpbGVBbHRlcm5hdGUubWVkaWEsXG4gICAgICBocmVmOiBjb25maWcubW9iaWxlQWx0ZXJuYXRlLmhyZWZcbiAgICB9KSk7XG4gIH1cbiAgaWYgKGNvbmZpZy5sYW5ndWFnZUFsdGVybmF0ZXMgJiYgY29uZmlnLmxhbmd1YWdlQWx0ZXJuYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uZmlnLmxhbmd1YWdlQWx0ZXJuYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChsYW5ndWFnZUFsdGVybmF0ZSkge1xuICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlua1wiLCB7XG4gICAgICAgIHJlbDogXCJhbHRlcm5hdGVcIixcbiAgICAgICAga2V5OiBcImxhbmd1YWdlQWx0ZXJuYXRlLVwiICsgbGFuZ3VhZ2VBbHRlcm5hdGUuaHJlZkxhbmcsXG4gICAgICAgIGhyZWZMYW5nOiBsYW5ndWFnZUFsdGVybmF0ZS5ocmVmTGFuZyxcbiAgICAgICAgaHJlZjogbGFuZ3VhZ2VBbHRlcm5hdGUuaHJlZlxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChjb25maWcudHdpdHRlcikge1xuICAgIGlmIChjb25maWcudHdpdHRlci5jYXJkVHlwZSkge1xuICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJ0d2l0dGVyOmNhcmRcIixcbiAgICAgICAgbmFtZTogXCJ0d2l0dGVyOmNhcmRcIixcbiAgICAgICAgY29udGVudDogY29uZmlnLnR3aXR0ZXIuY2FyZFR5cGVcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy50d2l0dGVyLnNpdGUpIHtcbiAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICBrZXk6IFwidHdpdHRlcjpzaXRlXCIsXG4gICAgICAgIG5hbWU6IFwidHdpdHRlcjpzaXRlXCIsXG4gICAgICAgIGNvbnRlbnQ6IGNvbmZpZy50d2l0dGVyLnNpdGVcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy50d2l0dGVyLmhhbmRsZSkge1xuICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJ0d2l0dGVyOmNyZWF0b3JcIixcbiAgICAgICAgbmFtZTogXCJ0d2l0dGVyOmNyZWF0b3JcIixcbiAgICAgICAgY29udGVudDogY29uZmlnLnR3aXR0ZXIuaGFuZGxlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGlmIChjb25maWcuZmFjZWJvb2spIHtcbiAgICBpZiAoY29uZmlnLmZhY2Vib29rLmFwcElkKSB7XG4gICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAga2V5OiBcImZiOmFwcF9pZFwiLFxuICAgICAgICBwcm9wZXJ0eTogXCJmYjphcHBfaWRcIixcbiAgICAgICAgY29udGVudDogY29uZmlnLmZhY2Vib29rLmFwcElkXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGlmICgoX2NvbmZpZyRvcGVuR3JhcGggPSBjb25maWcub3BlbkdyYXBoKSAhPSBudWxsICYmIF9jb25maWckb3BlbkdyYXBoLnRpdGxlIHx8IHVwZGF0ZWRUaXRsZSkge1xuICAgIHZhciBfY29uZmlnJG9wZW5HcmFwaDI7XG4gICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IFwib2c6dGl0bGVcIixcbiAgICAgIHByb3BlcnR5OiBcIm9nOnRpdGxlXCIsXG4gICAgICBjb250ZW50OiAoKF9jb25maWckb3BlbkdyYXBoMiA9IGNvbmZpZy5vcGVuR3JhcGgpID09IG51bGwgPyB2b2lkIDAgOiBfY29uZmlnJG9wZW5HcmFwaDIudGl0bGUpIHx8IHVwZGF0ZWRUaXRsZVxuICAgIH0pKTtcbiAgfVxuICBpZiAoKF9jb25maWckb3BlbkdyYXBoMyA9IGNvbmZpZy5vcGVuR3JhcGgpICE9IG51bGwgJiYgX2NvbmZpZyRvcGVuR3JhcGgzLmRlc2NyaXB0aW9uIHx8IGNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgIHZhciBfY29uZmlnJG9wZW5HcmFwaDQ7XG4gICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IFwib2c6ZGVzY3JpcHRpb25cIixcbiAgICAgIHByb3BlcnR5OiBcIm9nOmRlc2NyaXB0aW9uXCIsXG4gICAgICBjb250ZW50OiAoKF9jb25maWckb3BlbkdyYXBoNCA9IGNvbmZpZy5vcGVuR3JhcGgpID09IG51bGwgPyB2b2lkIDAgOiBfY29uZmlnJG9wZW5HcmFwaDQuZGVzY3JpcHRpb24pIHx8IGNvbmZpZy5kZXNjcmlwdGlvblxuICAgIH0pKTtcbiAgfVxuICBpZiAoY29uZmlnLm9wZW5HcmFwaCkge1xuICAgIGlmIChjb25maWcub3BlbkdyYXBoLnVybCB8fCBjb25maWcuY2Fub25pY2FsKSB7XG4gICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAga2V5OiBcIm9nOnVybFwiLFxuICAgICAgICBwcm9wZXJ0eTogXCJvZzp1cmxcIixcbiAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC51cmwgfHwgY29uZmlnLmNhbm9uaWNhbFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC50eXBlKSB7XG4gICAgICB2YXIgdHlwZSA9IGNvbmZpZy5vcGVuR3JhcGgudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJvZzp0eXBlXCIsXG4gICAgICAgIHByb3BlcnR5OiBcIm9nOnR5cGVcIixcbiAgICAgICAgY29udGVudDogdHlwZVxuICAgICAgfSkpO1xuICAgICAgaWYgKHR5cGUgPT09ICdwcm9maWxlJyAmJiBjb25maWcub3BlbkdyYXBoLnByb2ZpbGUpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5vcGVuR3JhcGgucHJvZmlsZS5maXJzdE5hbWUpIHtcbiAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGtleTogXCJwcm9maWxlOmZpcnN0X25hbWVcIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcInByb2ZpbGU6Zmlyc3RfbmFtZVwiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC5wcm9maWxlLmZpcnN0TmFtZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC5wcm9maWxlLmxhc3ROYW1lKSB7XG4gICAgICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgICAgICBrZXk6IFwicHJvZmlsZTpsYXN0X25hbWVcIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcInByb2ZpbGU6bGFzdF9uYW1lXCIsXG4gICAgICAgICAgICBjb250ZW50OiBjb25maWcub3BlbkdyYXBoLnByb2ZpbGUubGFzdE5hbWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5vcGVuR3JhcGgucHJvZmlsZS51c2VybmFtZSkge1xuICAgICAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAga2V5OiBcInByb2ZpbGU6dXNlcm5hbWVcIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcInByb2ZpbGU6dXNlcm5hbWVcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbmZpZy5vcGVuR3JhcGgucHJvZmlsZS51c2VybmFtZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC5wcm9maWxlLmdlbmRlcikge1xuICAgICAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAga2V5OiBcInByb2ZpbGU6Z2VuZGVyXCIsXG4gICAgICAgICAgICBwcm9wZXJ0eTogXCJwcm9maWxlOmdlbmRlclwiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC5wcm9maWxlLmdlbmRlclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vaycgJiYgY29uZmlnLm9wZW5HcmFwaC5ib29rKSB7XG4gICAgICAgIGlmIChjb25maWcub3BlbkdyYXBoLmJvb2suYXV0aG9ycyAmJiBjb25maWcub3BlbkdyYXBoLmJvb2suYXV0aG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25maWcub3BlbkdyYXBoLmJvb2suYXV0aG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRob3IsIGluZGV4KSB7XG4gICAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvb2s6YXV0aG9yOjBcIiArIGluZGV4LFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJib29rOmF1dGhvclwiLFxuICAgICAgICAgICAgICBjb250ZW50OiBhdXRob3JcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC5ib29rLmlzYm4pIHtcbiAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGtleTogXCJib29rOmlzYm5cIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcImJvb2s6aXNiblwiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC5ib29rLmlzYm5cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5vcGVuR3JhcGguYm9vay5yZWxlYXNlRGF0ZSkge1xuICAgICAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAga2V5OiBcImJvb2s6cmVsZWFzZV9kYXRlXCIsXG4gICAgICAgICAgICBwcm9wZXJ0eTogXCJib29rOnJlbGVhc2VfZGF0ZVwiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC5ib29rLnJlbGVhc2VEYXRlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcub3BlbkdyYXBoLmJvb2sudGFncyAmJiBjb25maWcub3BlbkdyYXBoLmJvb2sudGFncy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25maWcub3BlbkdyYXBoLmJvb2sudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcsIGluZGV4KSB7XG4gICAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvb2s6dGFnOjBcIiArIGluZGV4LFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJib29rOnRhZ1wiLFxuICAgICAgICAgICAgICBjb250ZW50OiB0YWdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXJ0aWNsZScgJiYgY29uZmlnLm9wZW5HcmFwaC5hcnRpY2xlKSB7XG4gICAgICAgIGlmIChjb25maWcub3BlbkdyYXBoLmFydGljbGUucHVibGlzaGVkVGltZSkge1xuICAgICAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAga2V5OiBcImFydGljbGU6cHVibGlzaGVkX3RpbWVcIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcImFydGljbGU6cHVibGlzaGVkX3RpbWVcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbmZpZy5vcGVuR3JhcGguYXJ0aWNsZS5wdWJsaXNoZWRUaW1lXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcub3BlbkdyYXBoLmFydGljbGUubW9kaWZpZWRUaW1lKSB7XG4gICAgICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgICAgICBrZXk6IFwiYXJ0aWNsZTptb2RpZmllZF90aW1lXCIsXG4gICAgICAgICAgICBwcm9wZXJ0eTogXCJhcnRpY2xlOm1vZGlmaWVkX3RpbWVcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbmZpZy5vcGVuR3JhcGguYXJ0aWNsZS5tb2RpZmllZFRpbWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5vcGVuR3JhcGguYXJ0aWNsZS5leHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAga2V5OiBcImFydGljbGU6ZXhwaXJhdGlvbl90aW1lXCIsXG4gICAgICAgICAgICBwcm9wZXJ0eTogXCJhcnRpY2xlOmV4cGlyYXRpb25fdGltZVwiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC5hcnRpY2xlLmV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcub3BlbkdyYXBoLmFydGljbGUuYXV0aG9ycyAmJiBjb25maWcub3BlbkdyYXBoLmFydGljbGUuYXV0aG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25maWcub3BlbkdyYXBoLmFydGljbGUuYXV0aG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRob3IsIGluZGV4KSB7XG4gICAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAga2V5OiBcImFydGljbGU6YXV0aG9yOjBcIiArIGluZGV4LFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJhcnRpY2xlOmF1dGhvclwiLFxuICAgICAgICAgICAgICBjb250ZW50OiBhdXRob3JcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC5hcnRpY2xlLnNlY3Rpb24pIHtcbiAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGtleTogXCJhcnRpY2xlOnNlY3Rpb25cIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcImFydGljbGU6c2VjdGlvblwiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC5hcnRpY2xlLnNlY3Rpb25cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5vcGVuR3JhcGguYXJ0aWNsZS50YWdzICYmIGNvbmZpZy5vcGVuR3JhcGguYXJ0aWNsZS50YWdzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbmZpZy5vcGVuR3JhcGguYXJ0aWNsZS50YWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZywgaW5kZXgpIHtcbiAgICAgICAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXJ0aWNsZTp0YWc6MFwiICsgaW5kZXgsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBcImFydGljbGU6dGFnXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IHRhZ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCh0eXBlID09PSAndmlkZW8ubW92aWUnIHx8IHR5cGUgPT09ICd2aWRlby5lcGlzb2RlJyB8fCB0eXBlID09PSAndmlkZW8udHZfc2hvdycgfHwgdHlwZSA9PT0gJ3ZpZGVvLm90aGVyJykgJiYgY29uZmlnLm9wZW5HcmFwaC52aWRlbykge1xuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC52aWRlby5hY3RvcnMgJiYgY29uZmlnLm9wZW5HcmFwaC52aWRlby5hY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uZmlnLm9wZW5HcmFwaC52aWRlby5hY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0b3IsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYWN0b3IucHJvZmlsZSkge1xuICAgICAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwidmlkZW86YWN0b3I6MFwiICsgaW5kZXgsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IFwidmlkZW86YWN0b3JcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBhY3Rvci5wcm9maWxlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rvci5yb2xlKSB7XG4gICAgICAgICAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIGtleTogXCJ2aWRlbzphY3Rvcjpyb2xlOjBcIiArIGluZGV4LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcInZpZGVvOmFjdG9yOnJvbGVcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBhY3Rvci5yb2xlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC52aWRlby5kaXJlY3RvcnMgJiYgY29uZmlnLm9wZW5HcmFwaC52aWRlby5kaXJlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uZmlnLm9wZW5HcmFwaC52aWRlby5kaXJlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0b3IsIGluZGV4KSB7XG4gICAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAga2V5OiBcInZpZGVvOmRpcmVjdG9yOjBcIiArIGluZGV4LFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJ2aWRlbzpkaXJlY3RvclwiLFxuICAgICAgICAgICAgICBjb250ZW50OiBkaXJlY3RvclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcub3BlbkdyYXBoLnZpZGVvLndyaXRlcnMgJiYgY29uZmlnLm9wZW5HcmFwaC52aWRlby53cml0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbmZpZy5vcGVuR3JhcGgudmlkZW8ud3JpdGVycy5mb3JFYWNoKGZ1bmN0aW9uICh3cml0ZXIsIGluZGV4KSB7XG4gICAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAga2V5OiBcInZpZGVvOndyaXRlcjowXCIgKyBpbmRleCxcbiAgICAgICAgICAgICAgcHJvcGVydHk6IFwidmlkZW86d3JpdGVyXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IHdyaXRlclxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcub3BlbkdyYXBoLnZpZGVvLmR1cmF0aW9uKSB7XG4gICAgICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgICAgICBrZXk6IFwidmlkZW86ZHVyYXRpb25cIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcInZpZGVvOmR1cmF0aW9uXCIsXG4gICAgICAgICAgICBjb250ZW50OiBjb25maWcub3BlbkdyYXBoLnZpZGVvLmR1cmF0aW9uLnRvU3RyaW5nKClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5vcGVuR3JhcGgudmlkZW8ucmVsZWFzZURhdGUpIHtcbiAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGtleTogXCJ2aWRlbzpyZWxlYXNlX2RhdGVcIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcInZpZGVvOnJlbGVhc2VfZGF0ZVwiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC52aWRlby5yZWxlYXNlRGF0ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC52aWRlby50YWdzICYmIGNvbmZpZy5vcGVuR3JhcGgudmlkZW8udGFncy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25maWcub3BlbkdyYXBoLnZpZGVvLnRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnLCBpbmRleCkge1xuICAgICAgICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgICAgICAgIGtleTogXCJ2aWRlbzp0YWc6MFwiICsgaW5kZXgsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBcInZpZGVvOnRhZ1wiLFxuICAgICAgICAgICAgICBjb250ZW50OiB0YWdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC52aWRlby5zZXJpZXMpIHtcbiAgICAgICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGtleTogXCJ2aWRlbzpzZXJpZXNcIixcbiAgICAgICAgICAgIHByb3BlcnR5OiBcInZpZGVvOnNlcmllc1wiLFxuICAgICAgICAgICAgY29udGVudDogY29uZmlnLm9wZW5HcmFwaC52aWRlby5zZXJpZXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaW1hZ2VzXG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3BlbkdyYXBoSW1hZ2VXaWR0aCkge1xuICAgICAgZGVmYXVsdHMuZGVmYXVsdE9wZW5HcmFwaEltYWdlV2lkdGggPSBjb25maWcuZGVmYXVsdE9wZW5HcmFwaEltYWdlV2lkdGg7XG4gICAgfVxuICAgIGlmIChjb25maWcuZGVmYXVsdE9wZW5HcmFwaEltYWdlSGVpZ2h0KSB7XG4gICAgICBkZWZhdWx0cy5kZWZhdWx0T3BlbkdyYXBoSW1hZ2VIZWlnaHQgPSBjb25maWcuZGVmYXVsdE9wZW5HcmFwaEltYWdlSGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC5pbWFnZXMgJiYgY29uZmlnLm9wZW5HcmFwaC5pbWFnZXMubGVuZ3RoKSB7XG4gICAgICB0YWdzVG9SZW5kZXIucHVzaC5hcHBseSh0YWdzVG9SZW5kZXIsIGJ1aWxkT3BlbkdyYXBoTWVkaWFUYWdzKCdpbWFnZScsIGNvbmZpZy5vcGVuR3JhcGguaW1hZ2VzLCB7XG4gICAgICAgIGRlZmF1bHRXaWR0aDogZGVmYXVsdHMuZGVmYXVsdE9wZW5HcmFwaEltYWdlV2lkdGgsXG4gICAgICAgIGRlZmF1bHRIZWlnaHQ6IGRlZmF1bHRzLmRlZmF1bHRPcGVuR3JhcGhJbWFnZUhlaWdodFxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyB2aWRlb3NcbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcGVuR3JhcGhWaWRlb1dpZHRoKSB7XG4gICAgICBkZWZhdWx0cy5kZWZhdWx0T3BlbkdyYXBoVmlkZW9XaWR0aCA9IGNvbmZpZy5kZWZhdWx0T3BlbkdyYXBoVmlkZW9XaWR0aDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3BlbkdyYXBoVmlkZW9IZWlnaHQpIHtcbiAgICAgIGRlZmF1bHRzLmRlZmF1bHRPcGVuR3JhcGhWaWRlb0hlaWdodCA9IGNvbmZpZy5kZWZhdWx0T3BlbkdyYXBoVmlkZW9IZWlnaHQ7XG4gICAgfVxuICAgIGlmIChjb25maWcub3BlbkdyYXBoLnZpZGVvcyAmJiBjb25maWcub3BlbkdyYXBoLnZpZGVvcy5sZW5ndGgpIHtcbiAgICAgIHRhZ3NUb1JlbmRlci5wdXNoLmFwcGx5KHRhZ3NUb1JlbmRlciwgYnVpbGRPcGVuR3JhcGhNZWRpYVRhZ3MoJ3ZpZGVvJywgY29uZmlnLm9wZW5HcmFwaC52aWRlb3MsIHtcbiAgICAgICAgZGVmYXVsdFdpZHRoOiBkZWZhdWx0cy5kZWZhdWx0T3BlbkdyYXBoVmlkZW9XaWR0aCxcbiAgICAgICAgZGVmYXVsdEhlaWdodDogZGVmYXVsdHMuZGVmYXVsdE9wZW5HcmFwaFZpZGVvSGVpZ2h0XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8vIGF1ZGlvXG4gICAgaWYgKGNvbmZpZy5vcGVuR3JhcGguYXVkaW8pIHtcbiAgICAgIHRhZ3NUb1JlbmRlci5wdXNoLmFwcGx5KHRhZ3NUb1JlbmRlciwgYnVpbGRPcGVuR3JhcGhNZWRpYVRhZ3MoJ2F1ZGlvJywgY29uZmlnLm9wZW5HcmFwaC5hdWRpbykpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC5sb2NhbGUpIHtcbiAgICAgIHRhZ3NUb1JlbmRlci5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICBrZXk6IFwib2c6bG9jYWxlXCIsXG4gICAgICAgIHByb3BlcnR5OiBcIm9nOmxvY2FsZVwiLFxuICAgICAgICBjb250ZW50OiBjb25maWcub3BlbkdyYXBoLmxvY2FsZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLm9wZW5HcmFwaC5zaXRlTmFtZSB8fCBjb25maWcub3BlbkdyYXBoLnNpdGVfbmFtZSkge1xuICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgIGtleTogXCJvZzpzaXRlX25hbWVcIixcbiAgICAgICAgcHJvcGVydHk6IFwib2c6c2l0ZV9uYW1lXCIsXG4gICAgICAgIGNvbnRlbnQ6IGNvbmZpZy5vcGVuR3JhcGguc2l0ZU5hbWUgfHwgY29uZmlnLm9wZW5HcmFwaC5zaXRlX25hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbmZpZy5jYW5vbmljYWwpIHtcbiAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHtcbiAgICAgIHJlbDogXCJjYW5vbmljYWxcIixcbiAgICAgIGhyZWY6IGNvbmZpZy5jYW5vbmljYWwsXG4gICAgICBrZXk6IFwiY2Fub25pY2FsXCJcbiAgICB9KSk7XG4gIH1cbiAgaWYgKGNvbmZpZy5hZGRpdGlvbmFsTWV0YVRhZ3MgJiYgY29uZmlnLmFkZGl0aW9uYWxNZXRhVGFncy5sZW5ndGggPiAwKSB7XG4gICAgY29uZmlnLmFkZGl0aW9uYWxNZXRhVGFncy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIF9yZWYzLCBfcmVmNDtcbiAgICAgIHZhciBrZXlPdmVycmlkZSA9IF9yZWYyLmtleU92ZXJyaWRlLFxuICAgICAgICB0YWcgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgX2V4Y2x1ZGVkJHgpO1xuICAgICAgdGFnc1RvUmVuZGVyLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCBfZXh0ZW5kcyh7XG4gICAgICAgIGtleTogXCJtZXRhOlwiICsgKChfcmVmMyA9IChfcmVmNCA9IGtleU92ZXJyaWRlICE9IG51bGwgPyBrZXlPdmVycmlkZSA6IHRhZy5uYW1lKSAhPSBudWxsID8gX3JlZjQgOiB0YWcucHJvcGVydHkpICE9IG51bGwgPyBfcmVmMyA6IHRhZy5odHRwRXF1aXYpXG4gICAgICB9LCB0YWcpKSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKChfY29uZmlnJGFkZGl0aW9uYWxMaW4gPSBjb25maWcuYWRkaXRpb25hbExpbmtUYWdzKSAhPSBudWxsICYmIF9jb25maWckYWRkaXRpb25hbExpbi5sZW5ndGgpIHtcbiAgICBjb25maWcuYWRkaXRpb25hbExpbmtUYWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgdmFyIF90YWcka2V5T3ZlcnJpZGU7XG4gICAgICB0YWdzVG9SZW5kZXIucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICAgICAga2V5OiBcImxpbmtcIiArICgoX3RhZyRrZXlPdmVycmlkZSA9IHRhZy5rZXlPdmVycmlkZSkgIT0gbnVsbCA/IF90YWcka2V5T3ZlcnJpZGUgOiB0YWcuaHJlZikgKyB0YWcucmVsXG4gICAgICB9LCB0YWcpKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhZ3NUb1JlbmRlcjtcbn07XG5cbnZhciBXaXRoSGVhZCA9IGZ1bmN0aW9uIFdpdGhIZWFkKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkLCBudWxsLCBidWlsZFRhZ3MocHJvcHMpKTtcbn07XG5cbnZhciBEZWZhdWx0U2VvID0gZnVuY3Rpb24gRGVmYXVsdFNlbyhfcmVmKSB7XG4gIHZhciB0aXRsZSA9IF9yZWYudGl0bGUsXG4gICAgdGl0bGVUZW1wbGF0ZSA9IF9yZWYudGl0bGVUZW1wbGF0ZSxcbiAgICBkZWZhdWx0VGl0bGUgPSBfcmVmLmRlZmF1bHRUaXRsZSxcbiAgICB0aGVtZUNvbG9yID0gX3JlZi50aGVtZUNvbG9yLFxuICAgIF9yZWYkZGFuZ2Vyb3VzbHlTZXRBbCA9IF9yZWYuZGFuZ2Vyb3VzbHlTZXRBbGxQYWdlc1RvTm9JbmRleCxcbiAgICBkYW5nZXJvdXNseVNldEFsbFBhZ2VzVG9Ob0luZGV4ID0gX3JlZiRkYW5nZXJvdXNseVNldEFsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGFuZ2Vyb3VzbHlTZXRBbCxcbiAgICBfcmVmJGRhbmdlcm91c2x5U2V0QWwyID0gX3JlZi5kYW5nZXJvdXNseVNldEFsbFBhZ2VzVG9Ob0ZvbGxvdyxcbiAgICBkYW5nZXJvdXNseVNldEFsbFBhZ2VzVG9Ob0ZvbGxvdyA9IF9yZWYkZGFuZ2Vyb3VzbHlTZXRBbDIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRkYW5nZXJvdXNseVNldEFsMixcbiAgICBkZXNjcmlwdGlvbiA9IF9yZWYuZGVzY3JpcHRpb24sXG4gICAgY2Fub25pY2FsID0gX3JlZi5jYW5vbmljYWwsXG4gICAgZmFjZWJvb2sgPSBfcmVmLmZhY2Vib29rLFxuICAgIG9wZW5HcmFwaCA9IF9yZWYub3BlbkdyYXBoLFxuICAgIGFkZGl0aW9uYWxNZXRhVGFncyA9IF9yZWYuYWRkaXRpb25hbE1ldGFUYWdzLFxuICAgIHR3aXR0ZXIgPSBfcmVmLnR3aXR0ZXIsXG4gICAgZGVmYXVsdE9wZW5HcmFwaEltYWdlV2lkdGggPSBfcmVmLmRlZmF1bHRPcGVuR3JhcGhJbWFnZVdpZHRoLFxuICAgIGRlZmF1bHRPcGVuR3JhcGhJbWFnZUhlaWdodCA9IF9yZWYuZGVmYXVsdE9wZW5HcmFwaEltYWdlSGVpZ2h0LFxuICAgIGRlZmF1bHRPcGVuR3JhcGhWaWRlb1dpZHRoID0gX3JlZi5kZWZhdWx0T3BlbkdyYXBoVmlkZW9XaWR0aCxcbiAgICBkZWZhdWx0T3BlbkdyYXBoVmlkZW9IZWlnaHQgPSBfcmVmLmRlZmF1bHRPcGVuR3JhcGhWaWRlb0hlaWdodCxcbiAgICBtb2JpbGVBbHRlcm5hdGUgPSBfcmVmLm1vYmlsZUFsdGVybmF0ZSxcbiAgICBsYW5ndWFnZUFsdGVybmF0ZXMgPSBfcmVmLmxhbmd1YWdlQWx0ZXJuYXRlcyxcbiAgICBhZGRpdGlvbmFsTGlua1RhZ3MgPSBfcmVmLmFkZGl0aW9uYWxMaW5rVGFncyxcbiAgICByb2JvdHNQcm9wcyA9IF9yZWYucm9ib3RzUHJvcHM7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXaXRoSGVhZCwge1xuICAgIHRpdGxlOiB0aXRsZSxcbiAgICB0aXRsZVRlbXBsYXRlOiB0aXRsZVRlbXBsYXRlLFxuICAgIGRlZmF1bHRUaXRsZTogZGVmYXVsdFRpdGxlLFxuICAgIHRoZW1lQ29sb3I6IHRoZW1lQ29sb3IsXG4gICAgZGFuZ2Vyb3VzbHlTZXRBbGxQYWdlc1RvTm9JbmRleDogZGFuZ2Vyb3VzbHlTZXRBbGxQYWdlc1RvTm9JbmRleCxcbiAgICBkYW5nZXJvdXNseVNldEFsbFBhZ2VzVG9Ob0ZvbGxvdzogZGFuZ2Vyb3VzbHlTZXRBbGxQYWdlc1RvTm9Gb2xsb3csXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgIGNhbm9uaWNhbDogY2Fub25pY2FsLFxuICAgIGZhY2Vib29rOiBmYWNlYm9vayxcbiAgICBvcGVuR3JhcGg6IG9wZW5HcmFwaCxcbiAgICBhZGRpdGlvbmFsTWV0YVRhZ3M6IGFkZGl0aW9uYWxNZXRhVGFncyxcbiAgICB0d2l0dGVyOiB0d2l0dGVyLFxuICAgIGRlZmF1bHRPcGVuR3JhcGhJbWFnZVdpZHRoOiBkZWZhdWx0T3BlbkdyYXBoSW1hZ2VXaWR0aCxcbiAgICBkZWZhdWx0T3BlbkdyYXBoSW1hZ2VIZWlnaHQ6IGRlZmF1bHRPcGVuR3JhcGhJbWFnZUhlaWdodCxcbiAgICBkZWZhdWx0T3BlbkdyYXBoVmlkZW9XaWR0aDogZGVmYXVsdE9wZW5HcmFwaFZpZGVvV2lkdGgsXG4gICAgZGVmYXVsdE9wZW5HcmFwaFZpZGVvSGVpZ2h0OiBkZWZhdWx0T3BlbkdyYXBoVmlkZW9IZWlnaHQsXG4gICAgbW9iaWxlQWx0ZXJuYXRlOiBtb2JpbGVBbHRlcm5hdGUsXG4gICAgbGFuZ3VhZ2VBbHRlcm5hdGVzOiBsYW5ndWFnZUFsdGVybmF0ZXMsXG4gICAgYWRkaXRpb25hbExpbmtUYWdzOiBhZGRpdGlvbmFsTGlua1RhZ3MsXG4gICAgcm9ib3RzUHJvcHM6IHJvYm90c1Byb3BzXG4gIH0pO1xufTtcblxudmFyIE5leHRTZW8gPSBmdW5jdGlvbiBOZXh0U2VvKF9yZWYpIHtcbiAgdmFyIHRpdGxlID0gX3JlZi50aXRsZSxcbiAgICB0aGVtZUNvbG9yID0gX3JlZi50aGVtZUNvbG9yLFxuICAgIF9yZWYkbm9pbmRleCA9IF9yZWYubm9pbmRleCxcbiAgICBub2luZGV4ID0gX3JlZiRub2luZGV4ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbm9pbmRleCxcbiAgICBub2ZvbGxvdyA9IF9yZWYubm9mb2xsb3csXG4gICAgcm9ib3RzUHJvcHMgPSBfcmVmLnJvYm90c1Byb3BzLFxuICAgIGRlc2NyaXB0aW9uID0gX3JlZi5kZXNjcmlwdGlvbixcbiAgICBjYW5vbmljYWwgPSBfcmVmLmNhbm9uaWNhbCxcbiAgICBvcGVuR3JhcGggPSBfcmVmLm9wZW5HcmFwaCxcbiAgICBmYWNlYm9vayA9IF9yZWYuZmFjZWJvb2ssXG4gICAgdHdpdHRlciA9IF9yZWYudHdpdHRlcixcbiAgICBhZGRpdGlvbmFsTWV0YVRhZ3MgPSBfcmVmLmFkZGl0aW9uYWxNZXRhVGFncyxcbiAgICB0aXRsZVRlbXBsYXRlID0gX3JlZi50aXRsZVRlbXBsYXRlLFxuICAgIGRlZmF1bHRUaXRsZSA9IF9yZWYuZGVmYXVsdFRpdGxlLFxuICAgIG1vYmlsZUFsdGVybmF0ZSA9IF9yZWYubW9iaWxlQWx0ZXJuYXRlLFxuICAgIGxhbmd1YWdlQWx0ZXJuYXRlcyA9IF9yZWYubGFuZ3VhZ2VBbHRlcm5hdGVzLFxuICAgIGFkZGl0aW9uYWxMaW5rVGFncyA9IF9yZWYuYWRkaXRpb25hbExpbmtUYWdzLFxuICAgIF9yZWYkdXNlQXBwRGlyID0gX3JlZi51c2VBcHBEaXIsXG4gICAgdXNlQXBwRGlyID0gX3JlZiR1c2VBcHBEaXIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiR1c2VBcHBEaXI7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgdXNlQXBwRGlyID8gYnVpbGRUYWdzKHtcbiAgICB0aXRsZTogdGl0bGUsXG4gICAgdGhlbWVDb2xvcjogdGhlbWVDb2xvcixcbiAgICBub2luZGV4OiBub2luZGV4LFxuICAgIG5vZm9sbG93OiBub2ZvbGxvdyxcbiAgICByb2JvdHNQcm9wczogcm9ib3RzUHJvcHMsXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgIGNhbm9uaWNhbDogY2Fub25pY2FsLFxuICAgIGZhY2Vib29rOiBmYWNlYm9vayxcbiAgICBvcGVuR3JhcGg6IG9wZW5HcmFwaCxcbiAgICBhZGRpdGlvbmFsTWV0YVRhZ3M6IGFkZGl0aW9uYWxNZXRhVGFncyxcbiAgICB0d2l0dGVyOiB0d2l0dGVyLFxuICAgIHRpdGxlVGVtcGxhdGU6IHRpdGxlVGVtcGxhdGUsXG4gICAgZGVmYXVsdFRpdGxlOiBkZWZhdWx0VGl0bGUsXG4gICAgbW9iaWxlQWx0ZXJuYXRlOiBtb2JpbGVBbHRlcm5hdGUsXG4gICAgbGFuZ3VhZ2VBbHRlcm5hdGVzOiBsYW5ndWFnZUFsdGVybmF0ZXMsXG4gICAgYWRkaXRpb25hbExpbmtUYWdzOiBhZGRpdGlvbmFsTGlua1RhZ3NcbiAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChXaXRoSGVhZCwge1xuICAgIHRpdGxlOiB0aXRsZSxcbiAgICB0aGVtZUNvbG9yOiB0aGVtZUNvbG9yLFxuICAgIG5vaW5kZXg6IG5vaW5kZXgsXG4gICAgbm9mb2xsb3c6IG5vZm9sbG93LFxuICAgIHJvYm90c1Byb3BzOiByb2JvdHNQcm9wcyxcbiAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgY2Fub25pY2FsOiBjYW5vbmljYWwsXG4gICAgZmFjZWJvb2s6IGZhY2Vib29rLFxuICAgIG9wZW5HcmFwaDogb3BlbkdyYXBoLFxuICAgIGFkZGl0aW9uYWxNZXRhVGFnczogYWRkaXRpb25hbE1ldGFUYWdzLFxuICAgIHR3aXR0ZXI6IHR3aXR0ZXIsXG4gICAgdGl0bGVUZW1wbGF0ZTogdGl0bGVUZW1wbGF0ZSxcbiAgICBkZWZhdWx0VGl0bGU6IGRlZmF1bHRUaXRsZSxcbiAgICBtb2JpbGVBbHRlcm5hdGU6IG1vYmlsZUFsdGVybmF0ZSxcbiAgICBsYW5ndWFnZUFsdGVybmF0ZXM6IGxhbmd1YWdlQWx0ZXJuYXRlcyxcbiAgICBhZGRpdGlvbmFsTGlua1RhZ3M6IGFkZGl0aW9uYWxMaW5rVGFnc1xuICB9KSk7XG59O1xuXG52YXIgdG9Kc29uID0gZnVuY3Rpb24gdG9Kc29uKHR5cGUsIGpzb25sZCkge1xuICB2YXIgZGF0YSA9IGpzb25sZDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICBkYXRhID0gX2V4dGVuZHMoe30sIGpzb25sZFswXSk7XG4gIH1cbiAgdmFyIGpzb25MZE9iamVjdCA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBmb3JtYXRPYmplY3RGb3JTY2hlbWEodHlwZSwgaXRlbSk7XG4gIH0pIDogZm9ybWF0T2JqZWN0Rm9yU2NoZW1hKHR5cGUsIGRhdGEpO1xuICByZXR1cm4ge1xuICAgIF9faHRtbDogSlNPTi5zdHJpbmdpZnkoanNvbkxkT2JqZWN0LCBzYWZlSnNvbkxkUmVwbGFjZXIpXG4gIH07XG59O1xudmFyIGZvcm1hdE9iamVjdEZvclNjaGVtYSA9IGZ1bmN0aW9uIGZvcm1hdE9iamVjdEZvclNjaGVtYSh0eXBlLCBqc29ubGQpIHtcbiAgdmFyIF9qc29ubGQkaWQgPSBqc29ubGQuaWQsXG4gICAgaWQgPSBfanNvbmxkJGlkID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfanNvbmxkJGlkO1xuICB2YXIgdXBkYXRlZCA9IF9leHRlbmRzKHt9LCBpZCA/IHtcbiAgICAnQGlkJzoganNvbmxkLmlkXG4gIH0gOiB7fSwganNvbmxkKTtcbiAgZGVsZXRlIHVwZGF0ZWQuaWQ7XG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgJ0Bjb250ZXh0JzogJ2h0dHBzOi8vc2NoZW1hLm9yZycsXG4gICAgJ0B0eXBlJzogdHlwZVxuICB9LCB1cGRhdGVkKTtcbn07XG52YXIgRVNDQVBFX0VOVElUSUVTID0gT2JqZWN0LmZyZWV6ZSh7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmYXBvczsnXG59KTtcbnZhciBFU0NBUEVfUkVHRVggPSBuZXcgUmVnRXhwKFwiW1wiICsgT2JqZWN0LmtleXMoRVNDQVBFX0VOVElUSUVTKS5qb2luKCcnKSArIFwiXVwiLCAnZycpO1xudmFyIEVTQ0FQRV9SRVBMQUNFUiA9IGZ1bmN0aW9uIEVTQ0FQRV9SRVBMQUNFUih0KSB7XG4gIHJldHVybiBFU0NBUEVfRU5USVRJRVNbdF07XG59O1xuLyoqXHJcbiAqIEEgcmVwbGFjZXIgZm9yIEpTT04uc3RyaW5naWZ5IHRvIHN0cmlwIEpTT04tTEQgb2YgaWxsZWdhbCBIVE1MIGVudGl0aWVzXHJcbiAqIHBlciBodHRwczovL3d3dy53My5vcmcvVFIvanNvbi1sZDExLyNyZXN0cmljdGlvbnMtZm9yLWNvbnRlbnRzLW9mLWpzb24tbGQtc2NyaXB0LWVsZW1lbnRzXHJcbiAqL1xudmFyIHNhZmVKc29uTGRSZXBsYWNlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVwbGFjZSBwZXIgaHR0cHM6Ly93d3cudzMub3JnL1RSL2pzb24tbGQxMS8jcmVzdHJpY3Rpb25zLWZvci1jb250ZW50cy1vZi1qc29uLWxkLXNjcmlwdC1lbGVtZW50c1xuICAvLyBTb2x1dGlvbiBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDk5ODIxLzg2NDMxM1xuICByZXR1cm4gZnVuY3Rpb24gKF8sIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIC8vIE9taXQgbnVsbCB2YWx1ZXMuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgd2lsbCByZWN1cnNpdmVseSBjYWxsIHJlcGxhY2VyLlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgLy8gVGhlc2UgdmFsdWVzIGFyZSBub3Qgcmlza3kuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShFU0NBUEVfUkVHRVgsIEVTQ0FQRV9SRVBMQUNFUik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgd2lsbCByZW1vdmUgdGhpcyBlbGVtZW50LlxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG59KCk7XG5cbnZhciBfZXhjbHVkZWQkdyA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiLCBcInNjcmlwdEtleVwiLCBcInNjcmlwdElkXCIsIFwiZGF0YUFycmF5XCIsIFwidXNlQXBwRGlyXCJdO1xuZnVuY3Rpb24gSnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnVGhpbmcnIDogX3JlZiR0eXBlLFxuICAgIGtleU92ZXJyaWRlID0gX3JlZi5rZXlPdmVycmlkZSxcbiAgICBzY3JpcHRLZXkgPSBfcmVmLnNjcmlwdEtleSxcbiAgICBfcmVmJHNjcmlwdElkID0gX3JlZi5zY3JpcHRJZCxcbiAgICBzY3JpcHRJZCA9IF9yZWYkc2NyaXB0SWQgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9yZWYkc2NyaXB0SWQsXG4gICAgZGF0YUFycmF5ID0gX3JlZi5kYXRhQXJyYXksXG4gICAgX3JlZiR1c2VBcHBEaXIgPSBfcmVmLnVzZUFwcERpcixcbiAgICB1c2VBcHBEaXIgPSBfcmVmJHVzZUFwcERpciA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHVzZUFwcERpcixcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJHcpO1xuICB2YXIgSnNvbkxkU2NyaXB0ID0gZnVuY3Rpb24gSnNvbkxkU2NyaXB0KCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2xkK2pzb25cIixcbiAgICAgIGlkOiBzY3JpcHRJZCxcbiAgICAgIFwiZGF0YS10ZXN0aWRcIjogc2NyaXB0SWQsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdG9Kc29uKHR5cGUsIGRhdGFBcnJheSA9PT0gdW5kZWZpbmVkID8gX2V4dGVuZHMoe30sIHJlc3QpIDogZGF0YUFycmF5KSxcbiAgICAgIGtleTogXCJqc29ubGQtXCIgKyBzY3JpcHRLZXkgKyAoa2V5T3ZlcnJpZGUgPyBcIi1cIiArIGtleU92ZXJyaWRlIDogJycpXG4gICAgfSk7XG4gIH07XG4gIGlmICh1c2VBcHBEaXIpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkU2NyaXB0LCBudWxsKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZCwgbnVsbCwgSnNvbkxkU2NyaXB0KCkpO1xufVxuXG4vKipcclxuICogR2VuZXJhdGUgYXV0aG9yIGluZm9ybWF0aW9uXHJcbiAqIEBwYXJhbSBhdXRob3JcclxuICogQHJldHVybnNcclxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUF1dGhvckluZm8oYXV0aG9yKSB7XG4gIGlmICh0eXBlb2YgYXV0aG9yID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICAnQHR5cGUnOiAnUGVyc29uJyxcbiAgICAgIG5hbWU6IGF1dGhvclxuICAgIH07XG4gIH0gZWxzZSBpZiAoISFhdXRob3IubmFtZSkge1xuICAgIHZhciBfYXV0aG9yJHR5cGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICdAdHlwZSc6IChfYXV0aG9yJHR5cGUgPSBhdXRob3IgPT0gbnVsbCA/IHZvaWQgMCA6IGF1dGhvci50eXBlKSAhPSBudWxsID8gX2F1dGhvciR0eXBlIDogJ1BlcnNvbicsXG4gICAgICBuYW1lOiBhdXRob3IubmFtZSxcbiAgICAgIHVybDogYXV0aG9yID09IG51bGwgPyB2b2lkIDAgOiBhdXRob3IudXJsXG4gICAgfTtcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiBzZXRBdXRob3IoYXV0aG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGF1dGhvcikpIHtcbiAgICByZXR1cm4gYXV0aG9yLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlQXV0aG9ySW5mbyhpdGVtKTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAhIWl0ZW07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYXV0aG9yKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlQXV0aG9ySW5mbyhhdXRob3IpO1xuICB9XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gc2V0SW1hZ2UoaW1hZ2UpIHtcbiAgaWYgKGltYWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdAdHlwZSc6ICdJbWFnZU9iamVjdCcsXG4gICAgICB1cmw6IGltYWdlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRQdWJsaXNoZXIocHVibGlzaGVyTmFtZSwgcHVibGlzaGVyTG9nbykge1xuICBpZiAoIXB1Ymxpc2hlck5hbWUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgJ0B0eXBlJzogJ09yZ2FuaXphdGlvbicsXG4gICAgbmFtZTogcHVibGlzaGVyTmFtZSxcbiAgICBsb2dvOiBzZXRJbWFnZShwdWJsaXNoZXJMb2dvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXRSZXZpZXdSYXRpbmcocmF0aW5nKSB7XG4gIGlmIChyYXRpbmcpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJhdGluZywge1xuICAgICAgJ0B0eXBlJzogJ1JhdGluZydcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJHYgPSBbXCJyZXZpZXdSYXRpbmdcIiwgXCJhdXRob3JcIiwgXCJwdWJsaXNoZXJcIl07XG5mdW5jdGlvbiBzZXRSZXZpZXdzKHJldmlld3MpIHtcbiAgZnVuY3Rpb24gbWFwUmV2aWV3KF9yZWYpIHtcbiAgICB2YXIgcmV2aWV3UmF0aW5nID0gX3JlZi5yZXZpZXdSYXRpbmcsXG4gICAgICBhdXRob3IgPSBfcmVmLmF1dGhvcixcbiAgICAgIHB1Ymxpc2hlciA9IF9yZWYucHVibGlzaGVyLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCR2KTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgICdAdHlwZSc6ICdSZXZpZXcnXG4gICAgfSwgYXV0aG9yICYmIHtcbiAgICAgIGF1dGhvcjogc2V0QXV0aG9yKGF1dGhvcilcbiAgICB9LCByZXZpZXdSYXRpbmcgJiYge1xuICAgICAgcmV2aWV3UmF0aW5nOiBzZXRSZXZpZXdSYXRpbmcocmV2aWV3UmF0aW5nKVxuICAgIH0sIHB1Ymxpc2hlciAmJiB7XG4gICAgICBwdWJsaXNoZXI6IHNldFB1Ymxpc2hlcihwdWJsaXNoZXIubmFtZSlcbiAgICB9KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXZpZXdzKSkge1xuICAgIHJldHVybiByZXZpZXdzLm1hcChtYXBSZXZpZXcpO1xuICB9IGVsc2UgaWYgKHJldmlld3MpIHtcbiAgICByZXR1cm4gbWFwUmV2aWV3KHJldmlld3MpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE51dHJpdGlvbihjYWxvcmllcykge1xuICBpZiAoY2Fsb3JpZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0B0eXBlJzogJ051dHJpdGlvbkluZm9ybWF0aW9uJyxcbiAgICAgIGNhbG9yaWVzOiBjYWxvcmllcyArIFwiIGNhbG9yaWVzXCJcbiAgICB9O1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldEFnZ3JlZ2F0ZVJhdGluZyhhZ2dyZWdhdGVSYXRpbmcpIHtcbiAgaWYgKGFnZ3JlZ2F0ZVJhdGluZykge1xuICAgIHJldHVybiB7XG4gICAgICAnQHR5cGUnOiAnQWdncmVnYXRlUmF0aW5nJyxcbiAgICAgIHJhdGluZ0NvdW50OiBhZ2dyZWdhdGVSYXRpbmcucmF0aW5nQ291bnQsXG4gICAgICByZXZpZXdDb3VudDogYWdncmVnYXRlUmF0aW5nLnJldmlld0NvdW50LFxuICAgICAgYmVzdFJhdGluZzogYWdncmVnYXRlUmF0aW5nLmJlc3RSYXRpbmcsXG4gICAgICByYXRpbmdWYWx1ZTogYWdncmVnYXRlUmF0aW5nLnJhdGluZ1ZhbHVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRDbGlwKGNsaXBzKSB7XG4gIGZ1bmN0aW9uIG1hcENsaXAoY2xpcCkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY2xpcCwge1xuICAgICAgJ0B0eXBlJzogJ0NsaXAnXG4gICAgfSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2xpcHMpKSB7XG4gICAgcmV0dXJuIGNsaXBzLm1hcChtYXBDbGlwKTtcbiAgfSBlbHNlIGlmIChjbGlwcykge1xuICAgIHJldHVybiBtYXBDbGlwKGNsaXBzKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRJbnRlcmFjdGlvblN0YXRpc3RpYyh3YXRjaENvdW50KSB7XG4gIGlmICh3YXRjaENvdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdAdHlwZSc6ICdJbnRlcmFjdGlvbkNvdW50ZXInLFxuICAgICAgaW50ZXJhY3Rpb25UeXBlOiAnaHR0cHM6Ly9zY2hlbWEub3JnL1dhdGNoQWN0aW9uJyxcbiAgICAgIHVzZXJJbnRlcmFjdGlvbkNvdW50OiB3YXRjaENvdW50XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRCcm9hZGNhc3RFdmVudChwdWJsaWNhdGlvbikge1xuICBmdW5jdGlvbiBtYXBCcm9hZGNhc3RFdmVudChwdWJsaWNhdGlvbikge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcHVibGljYXRpb24sIHtcbiAgICAgICdAdHlwZSc6ICdCcm9hZGNhc3RFdmVudCdcbiAgICB9KTtcbiAgfVxuICBpZiAocHVibGljYXRpb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwdWJsaWNhdGlvbikpIHtcbiAgICAgIHJldHVybiBwdWJsaWNhdGlvbi5tYXAobWFwQnJvYWRjYXN0RXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwQnJvYWRjYXN0RXZlbnQocHVibGljYXRpb24pO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbnZhciBfZXhjbHVkZWQkdSA9IFtcInRodW1ibmFpbFVybHNcIiwgXCJoYXNQYXJ0XCIsIFwid2F0Y2hDb3VudFwiLCBcInB1YmxpY2F0aW9uXCJdO1xuZnVuY3Rpb24gc2V0VmlkZW8odmlkZW8sIHNldENvbnRleHQpIHtcbiAgaWYgKHNldENvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIHNldENvbnRleHQgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBtYXBWaWRlbyhfcmVmLCBjb250ZXh0KSB7XG4gICAgdmFyIHRodW1ibmFpbFVybHMgPSBfcmVmLnRodW1ibmFpbFVybHMsXG4gICAgICBoYXNQYXJ0ID0gX3JlZi5oYXNQYXJ0LFxuICAgICAgd2F0Y2hDb3VudCA9IF9yZWYud2F0Y2hDb3VudCxcbiAgICAgIHB1YmxpY2F0aW9uID0gX3JlZi5wdWJsaWNhdGlvbixcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkdSk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAnQHR5cGUnOiAnVmlkZW9PYmplY3QnXG4gICAgfSwgY29udGV4dCAmJiB7XG4gICAgICAnQGNvbnRleHQnOiAnaHR0cHM6Ly9zY2hlbWEub3JnJ1xuICAgIH0sIHtcbiAgICAgIHRodW1ibmFpbFVybDogdGh1bWJuYWlsVXJscyxcbiAgICAgIGhhc1BhcnQ6IHNldENsaXAoaGFzUGFydCksXG4gICAgICBpbnRlcmFjdGlvblN0YXRpc3RpYzogc2V0SW50ZXJhY3Rpb25TdGF0aXN0aWMod2F0Y2hDb3VudCksXG4gICAgICBwdWJsaWNhdGlvbjogc2V0QnJvYWRjYXN0RXZlbnQocHVibGljYXRpb24pXG4gICAgfSk7XG4gIH1cbiAgaWYgKHZpZGVvKSB7XG4gICAgcmV0dXJuIG1hcFZpZGVvKHZpZGVvLCBzZXRDb250ZXh0KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbikge1xuICBpZiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGluc3RydWN0aW9uLCB7XG4gICAgICAnQHR5cGUnOiAnSG93VG9TdGVwJ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbnZhciBfZXhjbHVkZWQkdCA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiLCBcIm9mVHlwZVwiLCBcImRhdGFcIl0sXG4gIF9leGNsdWRlZDIkMSA9IFtcImF1dGhvck5hbWVcIiwgXCJpbWFnZXNcIiwgXCJ5aWVsZHNcIiwgXCJjYXRlZ29yeVwiLCBcImNhbG9yaWVzXCIsIFwiYWdncmVnYXRlUmF0aW5nXCIsIFwidmlkZW9cIiwgXCJpbmdyZWRpZW50c1wiLCBcImluc3RydWN0aW9uc1wiLCBcImN1aXNpbmVcIl07XG5mdW5jdGlvbiBDYXJvdXNlbEpzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ0Nhcm91c2VsJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgb2ZUeXBlID0gX3JlZi5vZlR5cGUsXG4gICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJHQpO1xuICBmdW5jdGlvbiBnZW5lcmF0ZUxpc3QoZGF0YSwgb2ZUeXBlKSB7XG4gICAgc3dpdGNoIChvZlR5cGUpIHtcbiAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdAdHlwZSc6ICdMaXN0SXRlbScsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJcIiArIChpbmRleCArIDEpLFxuICAgICAgICAgICAgdXJsOiBpdGVtLnVybFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAnY291cnNlJzpcbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnQHR5cGUnOiAnTGlzdEl0ZW0nLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiXCIgKyAoaW5kZXggKyAxKSxcbiAgICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgICAgJ0Bjb250ZXh0JzogJ2h0dHBzOi8vc2NoZW1hLm9yZycsXG4gICAgICAgICAgICAgICdAdHlwZSc6ICdDb3Vyc2UnLFxuICAgICAgICAgICAgICB1cmw6IGl0ZW0udXJsLFxuICAgICAgICAgICAgICBuYW1lOiBpdGVtLmNvdXJzZU5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBwcm92aWRlcjoge1xuICAgICAgICAgICAgICAgICdAdHlwZSc6ICdPcmdhbml6YXRpb24nLFxuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ucHJvdmlkZXJOYW1lLFxuICAgICAgICAgICAgICAgIHNhbWVBczogaXRlbS5wcm92aWRlclVybFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlICdtb3ZpZSc6XG4gICAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ0B0eXBlJzogJ0xpc3RJdGVtJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcIlwiICsgKGluZGV4ICsgMSksXG4gICAgICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICAgICdAY29udGV4dCc6ICdodHRwczovL3NjaGVtYS5vcmcnLFxuICAgICAgICAgICAgICAnQHR5cGUnOiAnTW92aWUnLFxuICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgIHVybDogaXRlbS51cmwsXG4gICAgICAgICAgICAgIGltYWdlOiBpdGVtLmltYWdlLFxuICAgICAgICAgICAgICBkYXRlQ3JlYXRlZDogaXRlbS5kYXRlQ3JlYXRlZCxcbiAgICAgICAgICAgICAgZGlyZWN0b3I6IGl0ZW0uZGlyZWN0b3IgPyBBcnJheS5pc0FycmF5KGl0ZW0uZGlyZWN0b3IpID8gaXRlbS5kaXJlY3Rvci5tYXAoZnVuY3Rpb24gKGRpcmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICdAdHlwZSc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgbmFtZTogZGlyZWN0b3IubmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pIDoge1xuICAgICAgICAgICAgICAgICdAdHlwZSc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0uZGlyZWN0b3IubmFtZVxuICAgICAgICAgICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICByZXZpZXc6IHNldFJldmlld3MoaXRlbS5yZXZpZXcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlICdyZWNpcGUnOlxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKF9yZWYyLCBpbmRleCkge1xuICAgICAgICAgIHZhciBhdXRob3JOYW1lID0gX3JlZjIuYXV0aG9yTmFtZSxcbiAgICAgICAgICAgIGltYWdlcyA9IF9yZWYyLmltYWdlcyxcbiAgICAgICAgICAgIHlpZWxkcyA9IF9yZWYyLnlpZWxkcyxcbiAgICAgICAgICAgIGNhdGVnb3J5ID0gX3JlZjIuY2F0ZWdvcnksXG4gICAgICAgICAgICBjYWxvcmllcyA9IF9yZWYyLmNhbG9yaWVzLFxuICAgICAgICAgICAgYWdncmVnYXRlUmF0aW5nID0gX3JlZjIuYWdncmVnYXRlUmF0aW5nLFxuICAgICAgICAgICAgdmlkZW8gPSBfcmVmMi52aWRlbyxcbiAgICAgICAgICAgIGluZ3JlZGllbnRzID0gX3JlZjIuaW5ncmVkaWVudHMsXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBfcmVmMi5pbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICBjdWlzaW5lID0gX3JlZjIuY3Vpc2luZSxcbiAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgX2V4Y2x1ZGVkMiQxKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ0B0eXBlJzogJ0xpc3RJdGVtJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcIlwiICsgKGluZGV4ICsgMSksXG4gICAgICAgICAgICBpdGVtOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICdAY29udGV4dCc6ICdodHRwczovL3NjaGVtYS5vcmcnLFxuICAgICAgICAgICAgICAnQHR5cGUnOiAnUmVjaXBlJ1xuICAgICAgICAgICAgfSwgcmVzdCwge1xuICAgICAgICAgICAgICBhdXRob3I6IHNldEF1dGhvcihhdXRob3JOYW1lKSxcbiAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlcyxcbiAgICAgICAgICAgICAgcmVjaXBlWWllbGQ6IHlpZWxkcyxcbiAgICAgICAgICAgICAgcmVjaXBlQ2F0ZWdvcnk6IGNhdGVnb3J5LFxuICAgICAgICAgICAgICByZWNpcGVDdWlzaW5lOiBjdWlzaW5lLFxuICAgICAgICAgICAgICBudXRyaXRpb246IHNldE51dHJpdGlvbihjYWxvcmllcyksXG4gICAgICAgICAgICAgIGFnZ3JlZ2F0ZVJhdGluZzogc2V0QWdncmVnYXRlUmF0aW5nKGFnZ3JlZ2F0ZVJhdGluZyksXG4gICAgICAgICAgICAgIHZpZGVvOiBzZXRWaWRlbyh2aWRlbyksXG4gICAgICAgICAgICAgIHJlY2lwZUluZ3JlZGllbnQ6IGluZ3JlZGllbnRzLFxuICAgICAgICAgICAgICByZWNpcGVJbnN0cnVjdGlvbnM6IGluc3RydWN0aW9ucy5tYXAoc2V0SW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB2YXIganNvbkxkRGF0YSA9IF9leHRlbmRzKHtcbiAgICAnQHR5cGUnOiAnSXRlbUxpc3QnLFxuICAgIGl0ZW1MaXN0RWxlbWVudDogZ2VuZXJhdGVMaXN0KGRhdGEsIG9mVHlwZSlcbiAgfSwgcmVzdCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBqc29uTGREYXRhLCB7XG4gICAgc2NyaXB0S2V5OiBcIkNhcm91c2VsXCJcbiAgfSkpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJHMgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJ1cmxcIiwgXCJ0aXRsZVwiLCBcImltYWdlc1wiLCBcInNlY3Rpb25cIiwgXCJkYXRlQ3JlYXRlZFwiLCBcImRhdGVQdWJsaXNoZWRcIiwgXCJkYXRlTW9kaWZpZWRcIiwgXCJhdXRob3JOYW1lXCIsIFwiYXV0aG9yVHlwZVwiLCBcInB1Ymxpc2hlck5hbWVcIiwgXCJwdWJsaXNoZXJMb2dvXCIsIFwiYm9keVwiLCBcImlzQWNjZXNzaWJsZUZvckZyZWVcIl07XG5mdW5jdGlvbiBOZXdzQXJ0aWNsZUpzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ05ld3NBcnRpY2xlJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgdXJsID0gX3JlZi51cmwsXG4gICAgdGl0bGUgPSBfcmVmLnRpdGxlLFxuICAgIGltYWdlcyA9IF9yZWYuaW1hZ2VzLFxuICAgIHNlY3Rpb24gPSBfcmVmLnNlY3Rpb24sXG4gICAgZGF0ZUNyZWF0ZWQgPSBfcmVmLmRhdGVDcmVhdGVkLFxuICAgIGRhdGVQdWJsaXNoZWQgPSBfcmVmLmRhdGVQdWJsaXNoZWQsXG4gICAgZGF0ZU1vZGlmaWVkID0gX3JlZi5kYXRlTW9kaWZpZWQsXG4gICAgYXV0aG9yTmFtZSA9IF9yZWYuYXV0aG9yTmFtZSxcbiAgICBwdWJsaXNoZXJOYW1lID0gX3JlZi5wdWJsaXNoZXJOYW1lLFxuICAgIHB1Ymxpc2hlckxvZ28gPSBfcmVmLnB1Ymxpc2hlckxvZ28sXG4gICAgYm9keSA9IF9yZWYuYm9keSxcbiAgICBpc0FjY2Vzc2libGVGb3JGcmVlID0gX3JlZi5pc0FjY2Vzc2libGVGb3JGcmVlLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkcyk7XG4gIHZhciBkYXRhID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBtYWluRW50aXR5T2ZQYWdlOiB7XG4gICAgICAnQHR5cGUnOiAnV2ViUGFnZScsXG4gICAgICAnQGlkJzogdXJsXG4gICAgfSxcbiAgICBoZWFkbGluZTogdGl0bGUsXG4gICAgaW1hZ2U6IGltYWdlcyxcbiAgICBhcnRpY2xlU2VjdGlvbjogc2VjdGlvbixcbiAgICBkYXRlQ3JlYXRlZDogZGF0ZUNyZWF0ZWQgfHwgZGF0ZVB1Ymxpc2hlZCxcbiAgICBkYXRlUHVibGlzaGVkOiBkYXRlUHVibGlzaGVkLFxuICAgIGRhdGVNb2RpZmllZDogZGF0ZU1vZGlmaWVkIHx8IGRhdGVQdWJsaXNoZWQsXG4gICAgYXV0aG9yOiBzZXRBdXRob3IoYXV0aG9yTmFtZSksXG4gICAgcHVibGlzaGVyOiBzZXRQdWJsaXNoZXIocHVibGlzaGVyTmFtZSwgcHVibGlzaGVyTG9nbyksXG4gICAgYXJ0aWNsZUJvZHk6IGJvZHksXG4gICAgaXNBY2Nlc3NpYmxlRm9yRnJlZTogaXNBY2Nlc3NpYmxlRm9yRnJlZVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIGRhdGEsIHtcbiAgICBzY3JpcHRLZXk6IFwiTmV3c0FydGljbGVcIlxuICB9KSk7XG59XG5cbnZhciBfZXhjbHVkZWQkciA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiLCBcImJhc2VTYWxhcnlcIiwgXCJoaXJpbmdPcmdhbml6YXRpb25cIiwgXCJhcHBsaWNhbnRMb2NhdGlvblJlcXVpcmVtZW50c1wiLCBcImV4cGVyaWVuY2VSZXF1aXJlbWVudHNcIiwgXCJqb2JMb2NhdGlvblwiXTtcbmZ1bmN0aW9uIEpvYlBvc3RpbmdKc29uTGQoX3JlZikge1xuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/ICdKb2JQb3N0aW5nJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgYmFzZVNhbGFyeSA9IF9yZWYuYmFzZVNhbGFyeSxcbiAgICBoaXJpbmdPcmdhbml6YXRpb24gPSBfcmVmLmhpcmluZ09yZ2FuaXphdGlvbixcbiAgICBhcHBsaWNhbnRMb2NhdGlvblJlcXVpcmVtZW50cyA9IF9yZWYuYXBwbGljYW50TG9jYXRpb25SZXF1aXJlbWVudHMsXG4gICAgZXhwZXJpZW5jZVJlcXVpcmVtZW50cyA9IF9yZWYuZXhwZXJpZW5jZVJlcXVpcmVtZW50cyxcbiAgICBqb2JMb2NhdGlvbiA9IF9yZWYuam9iTG9jYXRpb24sXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCRyKTtcbiAgZnVuY3Rpb24gc2V0QmFzZVNhbGFyeShiYXNlU2FsYXJ5KSB7XG4gICAgaWYgKGJhc2VTYWxhcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdAdHlwZSc6ICdNb25ldGFyeUFtb3VudCcsXG4gICAgICAgIGN1cnJlbmN5OiBiYXNlU2FsYXJ5LmN1cnJlbmN5LFxuICAgICAgICB2YWx1ZTogX2V4dGVuZHMoe1xuICAgICAgICAgICdAdHlwZSc6ICdRdWFudGl0YXRpdmVWYWx1ZScsXG4gICAgICAgICAgdW5pdFRleHQ6IGJhc2VTYWxhcnkudW5pdFRleHRcbiAgICAgICAgfSwgQXJyYXkuaXNBcnJheShiYXNlU2FsYXJ5LnZhbHVlKSA/IHtcbiAgICAgICAgICBtaW5WYWx1ZTogYmFzZVNhbGFyeS52YWx1ZVswXSxcbiAgICAgICAgICBtYXhWYWx1ZTogYmFzZVNhbGFyeS52YWx1ZVsxXVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHZhbHVlOiBiYXNlU2FsYXJ5LnZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHNldEhpcmluZ09yZ2FuaXphdGlvbihvcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0B0eXBlJzogJ09yZ2FuaXphdGlvbicsXG4gICAgICBuYW1lOiBvcmcubmFtZSxcbiAgICAgIHNhbWVBczogb3JnLnNhbWVBcyxcbiAgICAgIGxvZ286IG9yZy5sb2dvXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzZXRKb2JMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0B0eXBlJzogJ1BsYWNlJyxcbiAgICAgICAgYWRkcmVzczoge1xuICAgICAgICAgICdAdHlwZSc6ICdQb3N0YWxBZGRyZXNzJyxcbiAgICAgICAgICBhZGRyZXNzQ291bnRyeTogbG9jYXRpb24uYWRkcmVzc0NvdW50cnksXG4gICAgICAgICAgYWRkcmVzc0xvY2FsaXR5OiBsb2NhdGlvbi5hZGRyZXNzTG9jYWxpdHksXG4gICAgICAgICAgYWRkcmVzc1JlZ2lvbjogbG9jYXRpb24uYWRkcmVzc1JlZ2lvbixcbiAgICAgICAgICBwb3N0YWxDb2RlOiBsb2NhdGlvbi5wb3N0YWxDb2RlLFxuICAgICAgICAgIHN0cmVldEFkZHJlc3M6IGxvY2F0aW9uLnN0cmVldEFkZHJlc3NcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBzZXRBcHBsaWNhbnRMb2NhdGlvblJlcXVpcmVtZW50cyhyZXF1aXJlbWVudHMpIHtcbiAgICBpZiAocmVxdWlyZW1lbnRzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQHR5cGUnOiAnQ291bnRyeScsXG4gICAgICAgIG5hbWU6IHJlcXVpcmVtZW50c1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBzZXRPY2N1cGF0aW9uYWxFeHBlcmllbmNlUmVxdWlyZW1lbnRzKHJlcXVpcmVtZW50cykge1xuICAgIGlmIChyZXF1aXJlbWVudHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdAdHlwZSc6IHJlcXVpcmVtZW50c1snQHR5cGUnXSA/IHJlcXVpcmVtZW50c1snQHR5cGUnXSA6ICdPY2N1cGF0aW9uYWxFeHBlcmllbmNlUmVxdWlyZW1lbnRzJyxcbiAgICAgICAgbW9udGhzT2ZFeHBlcmllbmNlOiByZXF1aXJlbWVudHMubWluaW11bU1vbnRoc09mRXhwZXJpZW5jZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBzZXRFZHVjYXRpb25hbE9jY3VwYXRpb25hbENyZWRlbnRpYWwocmVxdWlyZW1lbnRzKSB7XG4gICAgaWYgKHJlcXVpcmVtZW50cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0B0eXBlJzogcmVxdWlyZW1lbnRzWydAdHlwZSddID8gcmVxdWlyZW1lbnRzWydAdHlwZSddIDogJ0VkdWNhdGlvbmFsT2NjdXBhdGlvbmFsQ3JlZGVudGlhbCcsXG4gICAgICAgIGNyZWRlbnRpYWxDYXRlZ29yeTogcmVxdWlyZW1lbnRzLmNyZWRlbnRpYWxDYXRlZ29yeVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgYmFzZVNhbGFyeTogc2V0QmFzZVNhbGFyeShiYXNlU2FsYXJ5KSxcbiAgICBoaXJpbmdPcmdhbml6YXRpb246IHNldEhpcmluZ09yZ2FuaXphdGlvbihoaXJpbmdPcmdhbml6YXRpb24pLFxuICAgIGpvYkxvY2F0aW9uOiBzZXRKb2JMb2NhdGlvbihqb2JMb2NhdGlvbiksXG4gICAgYXBwbGljYW50TG9jYXRpb25SZXF1aXJlbWVudHM6IHNldEFwcGxpY2FudExvY2F0aW9uUmVxdWlyZW1lbnRzKGFwcGxpY2FudExvY2F0aW9uUmVxdWlyZW1lbnRzKSxcbiAgICBleHBlcmllbmNlUmVxdWlyZW1lbnRzOiBzZXRPY2N1cGF0aW9uYWxFeHBlcmllbmNlUmVxdWlyZW1lbnRzKGV4cGVyaWVuY2VSZXF1aXJlbWVudHMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cGVyaWVuY2VSZXF1aXJlbWVudHMub2NjdXBhdGlvbmFsKSxcbiAgICBlZHVjYXRpb25SZXF1aXJlbWVudHM6IHNldEVkdWNhdGlvbmFsT2NjdXBhdGlvbmFsQ3JlZGVudGlhbChleHBlcmllbmNlUmVxdWlyZW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiBleHBlcmllbmNlUmVxdWlyZW1lbnRzLmVkdWNhdGlvbmFsKSxcbiAgICBleHBlcmllbmNlSW5QbGFjZU9mRWR1Y2F0aW9uOiBleHBlcmllbmNlUmVxdWlyZW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiBleHBlcmllbmNlUmVxdWlyZW1lbnRzLmV4cGVyaWVuY2VJblBsYWNlT2ZFZHVjYXRpb25cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBkYXRhLCB7XG4gICAgc2NyaXB0S2V5OiBcIkpvYlBvc3RpbmdcIlxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHNldEFkZHJlc3MoYWRkcmVzcykge1xuICBpZiAoIWFkZHJlc3MpIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmICghQXJyYXkuaXNBcnJheShhZGRyZXNzKSkgcmV0dXJuIHRvUG9zdGFsQWRkcmVzcyhhZGRyZXNzKTtcbiAgLy8gSWYgYXJyYXkgb2Ygb25lIGFkZHJlc3MsIHJlcGxhY2Ugd2l0aCBzaW5nbGUgYWRkcmVzc1xuICBpZiAoYWRkcmVzcy5sZW5ndGggPT09IDEpIHJldHVybiB0b1Bvc3RhbEFkZHJlc3MoYWRkcmVzc1swXSk7XG4gIC8vIElmIGFycmF5LCByZXR1cm4gbWFwcGVkIGFycmF5IG9mIFBvc3RhbEFkZHJlc3Nlc1xuICByZXR1cm4gYWRkcmVzcy5tYXAodG9Qb3N0YWxBZGRyZXNzKTtcbn1cbmZ1bmN0aW9uIHRvUG9zdGFsQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycpIHJldHVybiBhZGRyZXNzO1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICdAdHlwZSc6ICdQb3N0YWxBZGRyZXNzJ1xuICB9LCBhZGRyZXNzKTtcbn1cblxuZnVuY3Rpb24gc2V0R2VvKGdlbykge1xuICBpZiAoZ2VvKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBnZW8sIHtcbiAgICAgICdAdHlwZSc6ICdHZW9Db29yZGluYXRlcydcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRBY3Rpb24oYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0B0eXBlJzogYWN0aW9uLmFjdGlvblR5cGUsXG4gICAgICBuYW1lOiBhY3Rpb24uYWN0aW9uTmFtZSxcbiAgICAgIHRhcmdldDogYWN0aW9uLnRhcmdldFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0R2VvQ2lyY2xlKGdlb0NpcmNsZSkge1xuICBpZiAoZ2VvQ2lyY2xlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdAdHlwZSc6ICdHZW9DaXJjbGUnLFxuICAgICAgZ2VvTWlkcG9pbnQ6IHtcbiAgICAgICAgJ0B0eXBlJzogJ0dlb0Nvb3JkaW5hdGVzJyxcbiAgICAgICAgbGF0aXR1ZGU6IGdlb0NpcmNsZS5nZW9NaWRwb2ludC5sYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlOiBnZW9DaXJjbGUuZ2VvTWlkcG9pbnQubG9uZ2l0dWRlXG4gICAgICB9LFxuICAgICAgZ2VvUmFkaXVzOiBnZW9DaXJjbGUuZ2VvUmFkaXVzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZlcihvZmZlcikge1xuICBmdW5jdGlvbiBzZXRQcmljZVNwZWNpZmljYXRpb24ocHJpY2VTcGVjaWZpY2F0aW9uKSB7XG4gICAgaWYgKHByaWNlU3BlY2lmaWNhdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0B0eXBlJzogcHJpY2VTcGVjaWZpY2F0aW9uLnR5cGUsXG4gICAgICAgIHByaWNlQ3VycmVuY3k6IHByaWNlU3BlY2lmaWNhdGlvbi5wcmljZUN1cnJlbmN5LFxuICAgICAgICBwcmljZTogcHJpY2VTcGVjaWZpY2F0aW9uLnByaWNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHNldEl0ZW1PZmZlcmVkKGl0ZW1PZmZlcmVkKSB7XG4gICAgaWYgKGl0ZW1PZmZlcmVkKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGl0ZW1PZmZlcmVkLCB7XG4gICAgICAgICdAdHlwZSc6ICdTZXJ2aWNlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG9mZmVyKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZlciwge1xuICAgICAgJ0B0eXBlJzogJ09mZmVyJyxcbiAgICAgIHByaWNlU3BlY2lmaWNhdGlvbjogc2V0UHJpY2VTcGVjaWZpY2F0aW9uKG9mZmVyLnByaWNlU3BlY2lmaWNhdGlvbiksXG4gICAgICBpdGVtT2ZmZXJlZDogc2V0SXRlbU9mZmVyZWQob2ZmZXIuaXRlbU9mZmVyZWQpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0T3BlbmluZ0hvdXJzKG9wZW5pbmdIb3Vycykge1xuICBpZiAob3BlbmluZ0hvdXJzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvcGVuaW5nSG91cnMsIHtcbiAgICAgICdAdHlwZSc6ICdPcGVuaW5nSG91cnNTcGVjaWZpY2F0aW9uJ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbnZhciBfZXhjbHVkZWQkcSA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiLCBcImFkZHJlc3NcIiwgXCJnZW9cIiwgXCJyYXRpbmdcIiwgXCJyZXZpZXdcIiwgXCJhY3Rpb25cIiwgXCJhcmVhU2VydmVkXCIsIFwibWFrZXNPZmZlclwiLCBcIm9wZW5pbmdIb3Vyc1wiLCBcImltYWdlc1wiXTtcbmZ1bmN0aW9uIExvY2FsQnVzaW5lc3NKc29uTGQoX3JlZikge1xuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/ICdMb2NhbEJ1c2luZXNzJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgYWRkcmVzcyA9IF9yZWYuYWRkcmVzcyxcbiAgICBnZW8gPSBfcmVmLmdlbyxcbiAgICByYXRpbmcgPSBfcmVmLnJhdGluZyxcbiAgICByZXZpZXcgPSBfcmVmLnJldmlldyxcbiAgICBhY3Rpb24gPSBfcmVmLmFjdGlvbixcbiAgICBhcmVhU2VydmVkID0gX3JlZi5hcmVhU2VydmVkLFxuICAgIG1ha2VzT2ZmZXIgPSBfcmVmLm1ha2VzT2ZmZXIsXG4gICAgb3BlbmluZ0hvdXJzID0gX3JlZi5vcGVuaW5nSG91cnMsXG4gICAgaW1hZ2VzID0gX3JlZi5pbWFnZXMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCRxKTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGltYWdlOiBpbWFnZXMsXG4gICAgYWRkcmVzczogc2V0QWRkcmVzcyhhZGRyZXNzKSxcbiAgICBnZW86IHNldEdlbyhnZW8pLFxuICAgIGFnZ3JlZ2F0ZVJhdGluZzogc2V0QWdncmVnYXRlUmF0aW5nKHJhdGluZyksXG4gICAgcmV2aWV3OiBzZXRSZXZpZXdzKHJldmlldyksXG4gICAgcG90ZW50aWFsQWN0aW9uOiBzZXRBY3Rpb24oYWN0aW9uKSxcbiAgICBhcmVhU2VydmVkOiBhcmVhU2VydmVkICYmIGFyZWFTZXJ2ZWQubWFwKHNldEdlb0NpcmNsZSksXG4gICAgbWFrZXNPZmZlcjogbWFrZXNPZmZlciA9PSBudWxsID8gdm9pZCAwIDogbWFrZXNPZmZlci5tYXAoc2V0T2ZmZXIpLFxuICAgIG9wZW5pbmdIb3Vyc1NwZWNpZmljYXRpb246IEFycmF5LmlzQXJyYXkob3BlbmluZ0hvdXJzKSA/IG9wZW5pbmdIb3Vycy5tYXAoc2V0T3BlbmluZ0hvdXJzKSA6IHNldE9wZW5pbmdIb3VycyhvcGVuaW5nSG91cnMpXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJMb2NhbEJ1c2luZXNzXCJcbiAgfSkpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJHAgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJtYWluRW50aXR5XCJdLFxuICBfZXhjbHVkZWQyID0gW1widXB2b3RlQ291bnRcIl07XG5mdW5jdGlvbiBRQVBhZ2VKc29uTGQoX3JlZikge1xuICB2YXIgX21haW5FbnRpdHkkYXV0aG9yLCBfbWFpbkVudGl0eSRhY2NlcHRlZEEsIF9tYWluRW50aXR5JGFjY2VwdGVkQTI7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ1FBUGFnZScgOiBfcmVmJHR5cGUsXG4gICAga2V5T3ZlcnJpZGUgPSBfcmVmLmtleU92ZXJyaWRlLFxuICAgIG1haW5FbnRpdHkgPSBfcmVmLm1haW5FbnRpdHksXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCRwKTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIG1haW5FbnRpdHk6IF9leHRlbmRzKHt9LCBtYWluRW50aXR5LCB7XG4gICAgICAnQHR5cGUnOiAnUXVlc3Rpb24nLFxuICAgICAgYXV0aG9yOiBzZXRBdXRob3IoKF9tYWluRW50aXR5JGF1dGhvciA9IG1haW5FbnRpdHkuYXV0aG9yKSA9PSBudWxsID8gdm9pZCAwIDogX21haW5FbnRpdHkkYXV0aG9yLm5hbWUpXG4gICAgfSwgbWFpbkVudGl0eS5hY2NlcHRlZEFuc3dlciAmJiB7XG4gICAgICBhY2NlcHRlZEFuc3dlcjogX2V4dGVuZHMoe30sIG1haW5FbnRpdHkuYWNjZXB0ZWRBbnN3ZXIsIHtcbiAgICAgICAgJ0B0eXBlJzogJ0Fuc3dlcicsXG4gICAgICAgIGF1dGhvcjogc2V0QXV0aG9yKChfbWFpbkVudGl0eSRhY2NlcHRlZEEgPSBtYWluRW50aXR5LmFjY2VwdGVkQW5zd2VyKSA9PSBudWxsID8gdm9pZCAwIDogKF9tYWluRW50aXR5JGFjY2VwdGVkQTIgPSBfbWFpbkVudGl0eSRhY2NlcHRlZEEuYXV0aG9yKSA9PSBudWxsID8gdm9pZCAwIDogX21haW5FbnRpdHkkYWNjZXB0ZWRBMi5uYW1lKVxuICAgICAgfSlcbiAgICB9LCBtYWluRW50aXR5LnN1Z2dlc3RlZEFuc3dlciAmJiB7XG4gICAgICBzdWdnZXN0ZWRBbnN3ZXI6IG1haW5FbnRpdHkuc3VnZ2VzdGVkQW5zd2VyLm1hcChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIF9yZXN0JGF1dGhvcjtcbiAgICAgICAgdmFyIHVwdm90ZUNvdW50ID0gX3JlZjIudXB2b3RlQ291bnQsXG4gICAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBfZXhjbHVkZWQyKTtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgICAgJ0B0eXBlJzogJ0Fuc3dlcicsXG4gICAgICAgICAgdXB2b3RlQ291bnQ6IHVwdm90ZUNvdW50IHx8IDAsXG4gICAgICAgICAgYXV0aG9yOiBzZXRBdXRob3IoKF9yZXN0JGF1dGhvciA9IHJlc3QuYXV0aG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3QkYXV0aG9yLm5hbWUpXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIGRhdGEsIHtcbiAgICBzY3JpcHRLZXk6IFwiUUFQYWdlXCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBzZXRJdGVtTGlzdEVsZW1lbnRzKGl0ZW1zKSB7XG4gIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQHR5cGUnOiAnTGlzdEl0ZW0nLFxuICAgICAgICBwb3NpdGlvbjogaXRlbS5wb3NpdGlvbixcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgICdAaWQnOiBpdGVtLml0ZW0sXG4gICAgICAgICAgbmFtZTogaXRlbS5uYW1lXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIF9leGNsdWRlZCRvID0gW1widHlwZVwiLCBcImtleU92ZXJyaWRlXCIsIFwiYnJlYWRjcnVtYlwiXTtcbmZ1bmN0aW9uIFByb2ZpbGVQYWdlSnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnUHJvZmlsZVBhZ2UnIDogX3JlZiR0eXBlLFxuICAgIGtleU92ZXJyaWRlID0gX3JlZi5rZXlPdmVycmlkZSxcbiAgICBicmVhZGNydW1iID0gX3JlZi5icmVhZGNydW1iLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkbyk7XG4gIHZhciBkYXRhID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBicmVhZGNydW1iOiBBcnJheS5pc0FycmF5KGJyZWFkY3J1bWIpID8ge1xuICAgICAgJ0B0eXBlJzogJ0JyZWFkY3J1bWJMaXN0JyxcbiAgICAgIGl0ZW1MaXN0RWxlbWVudDogc2V0SXRlbUxpc3RFbGVtZW50cyhicmVhZGNydW1iKVxuICAgIH0gOiBicmVhZGNydW1iXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJQcm9maWxlUGFnZVwiXG4gIH0pKTtcbn1cblxudmFyIF9leGNsdWRlZCRuID0gW1widHlwZVwiLCBcImtleU92ZXJyaWRlXCIsIFwicG90ZW50aWFsQWN0aW9uc1wiXTtcbmZ1bmN0aW9uIFNpdGVMaW5rc1NlYXJjaEJveEpzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ1dlYlNpdGUnIDogX3JlZiR0eXBlLFxuICAgIGtleU92ZXJyaWRlID0gX3JlZi5rZXlPdmVycmlkZSxcbiAgICBwb3RlbnRpYWxBY3Rpb25zID0gX3JlZi5wb3RlbnRpYWxBY3Rpb25zLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkbik7XG4gIGZ1bmN0aW9uIHNldFBvdGVudGlhbEFjdGlvbihhY3Rpb24pIHtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gYWN0aW9uLnRhcmdldCxcbiAgICAgICAgcXVlcnlJbnB1dCA9IGFjdGlvbi5xdWVyeUlucHV0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0B0eXBlJzogJ1NlYXJjaEFjdGlvbicsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0ICsgXCI9e1wiICsgcXVlcnlJbnB1dCArIFwifVwiLFxuICAgICAgICAncXVlcnktaW5wdXQnOiBcInJlcXVpcmVkIG5hbWU9XCIgKyBxdWVyeUlucHV0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBkYXRhID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBwb3RlbnRpYWxBY3Rpb246IHBvdGVudGlhbEFjdGlvbnMubWFwKHNldFBvdGVudGlhbEFjdGlvbilcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBkYXRhLCB7XG4gICAgc2NyaXB0S2V5OiBcImpzb25sZC1zaXRlTGlua3NTZWFyY2hCb3hcIlxuICB9KSk7XG59XG5cbnZhciBfZXhjbHVkZWQkbSA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiLCBcImF1dGhvck5hbWVcIiwgXCJpbWFnZXNcIiwgXCJ5aWVsZHNcIiwgXCJjYXRlZ29yeVwiLCBcImN1aXNpbmVcIiwgXCJjYWxvcmllc1wiLCBcImFnZ3JlZ2F0ZVJhdGluZ1wiLCBcInZpZGVvXCIsIFwiaW5ncmVkaWVudHNcIiwgXCJpbnN0cnVjdGlvbnNcIl07XG5mdW5jdGlvbiBSZWNpcGVKc29uTGQoX3JlZikge1xuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/ICdSZWNpcGUnIDogX3JlZiR0eXBlLFxuICAgIGtleU92ZXJyaWRlID0gX3JlZi5rZXlPdmVycmlkZSxcbiAgICBhdXRob3JOYW1lID0gX3JlZi5hdXRob3JOYW1lLFxuICAgIGltYWdlcyA9IF9yZWYuaW1hZ2VzLFxuICAgIHlpZWxkcyA9IF9yZWYueWllbGRzLFxuICAgIGNhdGVnb3J5ID0gX3JlZi5jYXRlZ29yeSxcbiAgICBjdWlzaW5lID0gX3JlZi5jdWlzaW5lLFxuICAgIGNhbG9yaWVzID0gX3JlZi5jYWxvcmllcyxcbiAgICBhZ2dyZWdhdGVSYXRpbmcgPSBfcmVmLmFnZ3JlZ2F0ZVJhdGluZyxcbiAgICB2aWRlbyA9IF9yZWYudmlkZW8sXG4gICAgaW5ncmVkaWVudHMgPSBfcmVmLmluZ3JlZGllbnRzLFxuICAgIGluc3RydWN0aW9ucyA9IF9yZWYuaW5zdHJ1Y3Rpb25zLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkbSk7XG4gIHZhciBkYXRhID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBhdXRob3I6IHNldEF1dGhvcihhdXRob3JOYW1lKSxcbiAgICBpbWFnZTogaW1hZ2VzLFxuICAgIHJlY2lwZVlpZWxkOiB5aWVsZHMsXG4gICAgcmVjaXBlQ2F0ZWdvcnk6IGNhdGVnb3J5LFxuICAgIHJlY2lwZUN1aXNpbmU6IGN1aXNpbmUsXG4gICAgbnV0cml0aW9uOiBzZXROdXRyaXRpb24oY2Fsb3JpZXMpLFxuICAgIGFnZ3JlZ2F0ZVJhdGluZzogc2V0QWdncmVnYXRlUmF0aW5nKGFnZ3JlZ2F0ZVJhdGluZyksXG4gICAgdmlkZW86IHNldFZpZGVvKHZpZGVvKSxcbiAgICByZWNpcGVJbmdyZWRpZW50OiBpbmdyZWRpZW50cyxcbiAgICByZWNpcGVJbnN0cnVjdGlvbnM6IGluc3RydWN0aW9ucyA/IGluc3RydWN0aW9ucy5tYXAoc2V0SW5zdHJ1Y3Rpb24pIDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJyZWNpcGVcIlxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHNldExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIGlmICghbG9jYXRpb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG4gIGlmICgndXJsJyBpbiBsb2NhdGlvbikge1xuICAgIHJldHVybiBzZXRWaXJ0dWFsTG9jYXRpb24obG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZXRQbGFjZShsb2NhdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZpcnR1YWxMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgJ0B0eXBlJzogJ1ZpcnR1YWxMb2NhdGlvbidcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRQbGFjZShsb2NhdGlvbikge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgYWRkcmVzczogc2V0QWRkcmVzcyhsb2NhdGlvbi5hZGRyZXNzKSxcbiAgICAnQHR5cGUnOiAnUGxhY2UnXG4gIH0pO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGwgPSBbXCJ0eXBlXCJdO1xuZnVuY3Rpb24gc2V0UGVyZm9ybWVyKHBlcmZvcm1lcikge1xuICBpZiAocGVyZm9ybWVyKSB7XG4gICAgdmFyIHR5cGUgPSBwZXJmb3JtZXIudHlwZSxcbiAgICAgIHJlc3RQZXJmb3JtZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwZXJmb3JtZXIsIF9leGNsdWRlZCRsKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJlc3RQZXJmb3JtZXIsIHtcbiAgICAgICdAdHlwZSc6IHR5cGUgfHwgJ1BlcmZvcm1pbmdHcm91cCdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGsgPSBbXCJzZWxsZXJcIl07XG5mdW5jdGlvbiBzZXRPZmZlcnMob2ZmZXJzKSB7XG4gIGZ1bmN0aW9uIG1hcE9mZmVyKF9yZWYpIHtcbiAgICB2YXIgc2VsbGVyID0gX3JlZi5zZWxsZXIsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJGspO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgJ0B0eXBlJzogJ09mZmVyJ1xuICAgIH0sIHNlbGxlciAmJiB7XG4gICAgICBzZWxsZXI6IHtcbiAgICAgICAgJ0B0eXBlJzogJ09yZ2FuaXphdGlvbicsXG4gICAgICAgIG5hbWU6IHNlbGxlci5uYW1lXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2ZmZXJzKSkge1xuICAgIHJldHVybiBvZmZlcnMubWFwKG1hcE9mZmVyKTtcbiAgfSBlbHNlIGlmIChvZmZlcnMpIHtcbiAgICByZXR1cm4gbWFwT2ZmZXIob2ZmZXJzKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRBZ2dyZWdhdGVPZmZlcihhZ2dyZWdhdGVPZmZlcikge1xuICBpZiAoYWdncmVnYXRlT2ZmZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0B0eXBlJzogJ0FnZ3JlZ2F0ZU9mZmVyJyxcbiAgICAgIHByaWNlQ3VycmVuY3k6IGFnZ3JlZ2F0ZU9mZmVyLnByaWNlQ3VycmVuY3ksXG4gICAgICBoaWdoUHJpY2U6IGFnZ3JlZ2F0ZU9mZmVyLmhpZ2hQcmljZSxcbiAgICAgIGxvd1ByaWNlOiBhZ2dyZWdhdGVPZmZlci5sb3dQcmljZSxcbiAgICAgIG9mZmVyQ291bnQ6IGFnZ3JlZ2F0ZU9mZmVyLm9mZmVyQ291bnQsXG4gICAgICBvZmZlcnM6IHNldE9mZmVycyhhZ2dyZWdhdGVPZmZlci5vZmZlcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGogPSBbXCJ0eXBlXCJdO1xuZnVuY3Rpb24gc2V0T3JnYW5pemVyKG9yZ2FuaXplcikge1xuICBpZiAob3JnYW5pemVyKSB7XG4gICAgdmFyIHR5cGUgPSBvcmdhbml6ZXIudHlwZSxcbiAgICAgIHJlc3RPcmdhbml6ZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShvcmdhbml6ZXIsIF9leGNsdWRlZCRqKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJlc3RPcmdhbml6ZXIsIHtcbiAgICAgICdAdHlwZSc6IHR5cGUgfHwgJ1BlcnNvbidcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGkgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJsb2NhdGlvblwiLCBcImltYWdlc1wiLCBcIm9mZmVyc1wiLCBcImFnZ3JlZ2F0ZU9mZmVyXCIsIFwicGVyZm9ybWVyc1wiLCBcIm9yZ2FuaXplclwiLCBcImV2ZW50U3RhdHVzXCIsIFwiZXZlbnRBdHRlbmRhbmNlTW9kZVwiXTtcbmZ1bmN0aW9uIEV2ZW50SnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnRXZlbnQnIDogX3JlZiR0eXBlLFxuICAgIGtleU92ZXJyaWRlID0gX3JlZi5rZXlPdmVycmlkZSxcbiAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb24sXG4gICAgaW1hZ2VzID0gX3JlZi5pbWFnZXMsXG4gICAgb2ZmZXJzID0gX3JlZi5vZmZlcnMsXG4gICAgYWdncmVnYXRlT2ZmZXIgPSBfcmVmLmFnZ3JlZ2F0ZU9mZmVyLFxuICAgIHBlcmZvcm1lcnMgPSBfcmVmLnBlcmZvcm1lcnMsXG4gICAgb3JnYW5pemVyID0gX3JlZi5vcmdhbml6ZXIsXG4gICAgZXZlbnRTdGF0dXMgPSBfcmVmLmV2ZW50U3RhdHVzLFxuICAgIGV2ZW50QXR0ZW5kYW5jZU1vZGUgPSBfcmVmLmV2ZW50QXR0ZW5kYW5jZU1vZGUsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCRpKTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGxvY2F0aW9uOiBzZXRMb2NhdGlvbihsb2NhdGlvbiksXG4gICAgaW1hZ2U6IGltYWdlcyxcbiAgICBvZmZlcnM6IG9mZmVycyA/IHNldE9mZmVycyhvZmZlcnMpIDogc2V0QWdncmVnYXRlT2ZmZXIoYWdncmVnYXRlT2ZmZXIpLFxuICAgIHBlcmZvcm1lcjogQXJyYXkuaXNBcnJheShwZXJmb3JtZXJzKSA/IHBlcmZvcm1lcnMubWFwKHNldFBlcmZvcm1lcikgOiBzZXRQZXJmb3JtZXIocGVyZm9ybWVycyksXG4gICAgb3JnYW5pemVyOiBBcnJheS5pc0FycmF5KG9yZ2FuaXplcikgPyBvcmdhbml6ZXIubWFwKHNldE9yZ2FuaXplcikgOiBzZXRPcmdhbml6ZXIob3JnYW5pemVyKSxcbiAgICBldmVudFN0YXR1czogZXZlbnRTdGF0dXMgPyBcImh0dHBzOi8vc2NoZW1hLm9yZy9cIiArIGV2ZW50U3RhdHVzIDogdW5kZWZpbmVkLFxuICAgIGV2ZW50QXR0ZW5kYW5jZU1vZGU6IGV2ZW50QXR0ZW5kYW5jZU1vZGUgPyBcImh0dHBzOi8vc2NoZW1hLm9yZy9cIiArIGV2ZW50QXR0ZW5kYW5jZU1vZGUgOiB1bmRlZmluZWRcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBkYXRhLCB7XG4gICAgc2NyaXB0S2V5OiBcIkV2ZW50XCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBzZXRDb250YWN0UG9pbnQoY29udGFjdFBvaW50KSB7XG4gIGlmIChjb250YWN0UG9pbnQpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRhY3RQb2ludCwge1xuICAgICAgJ0B0eXBlJzogJ0NvbnRhY3RQb2ludCdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGggPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJjb250YWN0UG9pbnRcIl07XG5mdW5jdGlvbiBDb3Jwb3JhdGVDb250YWN0SnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnT3JnYW5pemF0aW9uJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgY29udGFjdFBvaW50ID0gX3JlZi5jb250YWN0UG9pbnQsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCRoKTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGNvbnRhY3RQb2ludDogY29udGFjdFBvaW50Lm1hcChzZXRDb250YWN0UG9pbnQpXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJDb3Jwb3JhdGVDb250YWN0XCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBzZXRDcmVhdGl2ZVdvcmsoY3JlYXRpdmVXb3JrKSB7XG4gIGlmIChjcmVhdGl2ZVdvcmspIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNyZWF0aXZlV29yaywge1xuICAgICAgJ0B0eXBlJzogJ0NyZWF0aXZlV29yaydcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGcgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJoYXNQYXJ0XCJdO1xuZnVuY3Rpb24gQ29sbGVjdGlvblBhZ2VKc29uTGQoX3JlZikge1xuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/ICdDb2xsZWN0aW9uUGFnZScgOiBfcmVmJHR5cGUsXG4gICAga2V5T3ZlcnJpZGUgPSBfcmVmLmtleU92ZXJyaWRlLFxuICAgIGhhc1BhcnQgPSBfcmVmLmhhc1BhcnQsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCRnKTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGhhc1BhcnQ6IGhhc1BhcnQubWFwKHNldENyZWF0aXZlV29yaylcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBkYXRhLCB7XG4gICAgc2NyaXB0S2V5OiBcIkNvbGxlY3Rpb25QYWdlXCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBzZXRNYW51ZmFjdHVyZXIobWFudWZhY3R1cmVyKSB7XG4gIGlmIChtYW51ZmFjdHVyZXIgJiYgKG1hbnVmYWN0dXJlci5tYW51ZmFjdHVyZXJOYW1lIHx8IG1hbnVmYWN0dXJlci5tYW51ZmFjdHVyZXJMb2dvKSkge1xuICAgIHJldHVybiB7XG4gICAgICAnQHR5cGUnOiAnT3JnYW5pemF0aW9uJyxcbiAgICAgIG5hbWU6IG1hbnVmYWN0dXJlci5tYW51ZmFjdHVyZXJOYW1lLFxuICAgICAgbG9nbzogc2V0SW1hZ2UobWFudWZhY3R1cmVyLm1hbnVmYWN0dXJlckxvZ28pXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRCcmFuZChicmFuZCkge1xuICBpZiAoYnJhbmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0B0eXBlJzogJ0JyYW5kJyxcbiAgICAgIG5hbWU6IGJyYW5kXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGYgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJpbWFnZXNcIiwgXCJicmFuZFwiLCBcInJldmlld3NcIiwgXCJhZ2dyZWdhdGVSYXRpbmdcIiwgXCJtYW51ZmFjdHVyZXJMb2dvXCIsIFwibWFudWZhY3R1cmVyTmFtZVwiLCBcIm9mZmVyc1wiLCBcImFnZ3JlZ2F0ZU9mZmVyXCIsIFwicHJvZHVjdE5hbWVcIl07XG5mdW5jdGlvbiBQcm9kdWN0SnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnUHJvZHVjdCcgOiBfcmVmJHR5cGUsXG4gICAga2V5T3ZlcnJpZGUgPSBfcmVmLmtleU92ZXJyaWRlLFxuICAgIGltYWdlcyA9IF9yZWYuaW1hZ2VzLFxuICAgIGJyYW5kID0gX3JlZi5icmFuZCxcbiAgICByZXZpZXdzID0gX3JlZi5yZXZpZXdzLFxuICAgIGFnZ3JlZ2F0ZVJhdGluZyA9IF9yZWYuYWdncmVnYXRlUmF0aW5nLFxuICAgIG1hbnVmYWN0dXJlckxvZ28gPSBfcmVmLm1hbnVmYWN0dXJlckxvZ28sXG4gICAgbWFudWZhY3R1cmVyTmFtZSA9IF9yZWYubWFudWZhY3R1cmVyTmFtZSxcbiAgICBvZmZlcnMgPSBfcmVmLm9mZmVycyxcbiAgICBhZ2dyZWdhdGVPZmZlciA9IF9yZWYuYWdncmVnYXRlT2ZmZXIsXG4gICAgcHJvZHVjdE5hbWUgPSBfcmVmLnByb2R1Y3ROYW1lLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkZik7XG4gIHZhciBkYXRhID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBpbWFnZTogaW1hZ2VzLFxuICAgIGJyYW5kOiBzZXRCcmFuZChicmFuZCksXG4gICAgcmV2aWV3OiBzZXRSZXZpZXdzKHJldmlld3MpLFxuICAgIGFnZ3JlZ2F0ZVJhdGluZzogc2V0QWdncmVnYXRlUmF0aW5nKGFnZ3JlZ2F0ZVJhdGluZyksXG4gICAgbWFudWZhY3R1cmVyOiBzZXRNYW51ZmFjdHVyZXIoe1xuICAgICAgbWFudWZhY3R1cmVyTG9nbzogbWFudWZhY3R1cmVyTG9nbyxcbiAgICAgIG1hbnVmYWN0dXJlck5hbWU6IG1hbnVmYWN0dXJlck5hbWVcbiAgICB9KSxcbiAgICBvZmZlcnM6IG9mZmVycyA/IHNldE9mZmVycyhvZmZlcnMpIDogc2V0QWdncmVnYXRlT2ZmZXIoYWdncmVnYXRlT2ZmZXIpLFxuICAgIG5hbWU6IHByb2R1Y3ROYW1lXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJQcm9kdWN0XCJcbiAgfSkpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGUgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJwcmljZUN1cnJlbmN5XCIsIFwicHJpY2VcIiwgXCJhZ2dyZWdhdGVSYXRpbmdcIiwgXCJyZXZpZXdcIl07XG5mdW5jdGlvbiBTb2Z0d2FyZUFwcEpzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ1NvZnR3YXJlQXBwbGljYXRpb24nIDogX3JlZiR0eXBlLFxuICAgIGtleU92ZXJyaWRlID0gX3JlZi5rZXlPdmVycmlkZSxcbiAgICBwcmljZUN1cnJlbmN5ID0gX3JlZi5wcmljZUN1cnJlbmN5LFxuICAgIHByaWNlID0gX3JlZi5wcmljZSxcbiAgICBhZ2dyZWdhdGVSYXRpbmcgPSBfcmVmLmFnZ3JlZ2F0ZVJhdGluZyxcbiAgICByZXZpZXcgPSBfcmVmLnJldmlldyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJGUpO1xuICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgb2ZmZXJzOiB7XG4gICAgICAnQHR5cGUnOiAnT2ZmZXInLFxuICAgICAgcHJpY2U6IHByaWNlLFxuICAgICAgcHJpY2VDdXJyZW5jeTogcHJpY2VDdXJyZW5jeVxuICAgIH0sXG4gICAgYWdncmVnYXRlUmF0aW5nOiBzZXRBZ2dyZWdhdGVSYXRpbmcoYWdncmVnYXRlUmF0aW5nKSxcbiAgICByZXZpZXc6IHNldFJldmlld3MocmV2aWV3KVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIGRhdGEsIHtcbiAgICBzY3JpcHRLZXk6IFwiU29mdHdhcmVBcHBcIlxuICB9KSk7XG59XG5cbnZhciBfZXhjbHVkZWQkZCA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiXTtcbmZ1bmN0aW9uIFZpZGVvSnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnVmlkZW8nIDogX3JlZiR0eXBlLFxuICAgIGtleU92ZXJyaWRlID0gX3JlZi5rZXlPdmVycmlkZSxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJGQpO1xuICB2YXIgZGF0YSA9IHNldFZpZGVvKHJlc3QsIHRydWUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJWaWRlb1wiXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gc2V0UHJvZHVjZXIocHJvZHVjZXIpIHtcbiAgaWYgKHByb2R1Y2VyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdAdHlwZSc6ICdPcmdhbml6YXRpb24nLFxuICAgICAgc2FtZUFzOiBwcm9kdWNlci51cmwsXG4gICAgICBuYW1lOiBwcm9kdWNlci5uYW1lXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRQcm92aWRlcihwcm92aWRlcikge1xuICBpZiAocHJvdmlkZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0B0eXBlJzogcHJvdmlkZXIudHlwZSB8fCAnT3JnYW5pemF0aW9uJyxcbiAgICAgIG5hbWU6IHByb3ZpZGVyLm5hbWUsXG4gICAgICBzYW1lQXM6IHByb3ZpZGVyLnVybFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIF9leGNsdWRlZCRjID0gW1widHlwZVwiLCBcImtleU92ZXJyaWRlXCIsIFwiYWdncmVnYXRlUmF0aW5nXCIsIFwidHJhaWxlclwiLCBcInJldmlld3NcIiwgXCJpbWFnZVwiLCBcImF1dGhvck5hbWVcIiwgXCJwcm92aWRlclwiLCBcInByb2R1Y2VyTmFtZVwiLCBcInByb2R1Y2VyVXJsXCIsIFwib2ZmZXJzXCIsIFwib3BlcmF0aW5nU3lzdGVtTmFtZVwiLCBcInBsYXRmb3JtTmFtZVwiLCBcInRyYW5zbGF0b3JOYW1lXCIsIFwibGFuZ3VhZ2VOYW1lXCIsIFwiZ2VucmVOYW1lXCIsIFwicHVibGlzaGVyTmFtZVwiXTtcbmZ1bmN0aW9uIFZpZGVvR2FtZUpzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ1ZpZGVvR2FtZScgOiBfcmVmJHR5cGUsXG4gICAga2V5T3ZlcnJpZGUgPSBfcmVmLmtleU92ZXJyaWRlLFxuICAgIGFnZ3JlZ2F0ZVJhdGluZyA9IF9yZWYuYWdncmVnYXRlUmF0aW5nLFxuICAgIHRyYWlsZXIgPSBfcmVmLnRyYWlsZXIsXG4gICAgcmV2aWV3cyA9IF9yZWYucmV2aWV3cyxcbiAgICBpbWFnZSA9IF9yZWYuaW1hZ2UsXG4gICAgYXV0aG9yTmFtZSA9IF9yZWYuYXV0aG9yTmFtZSxcbiAgICBwcm92aWRlciA9IF9yZWYucHJvdmlkZXIsXG4gICAgcHJvZHVjZXJOYW1lID0gX3JlZi5wcm9kdWNlck5hbWUsXG4gICAgcHJvZHVjZXJVcmwgPSBfcmVmLnByb2R1Y2VyVXJsLFxuICAgIG9mZmVycyA9IF9yZWYub2ZmZXJzLFxuICAgIG9wZXJhdGluZ1N5c3RlbU5hbWUgPSBfcmVmLm9wZXJhdGluZ1N5c3RlbU5hbWUsXG4gICAgcGxhdGZvcm1OYW1lID0gX3JlZi5wbGF0Zm9ybU5hbWUsXG4gICAgdHJhbnNsYXRvck5hbWUgPSBfcmVmLnRyYW5zbGF0b3JOYW1lLFxuICAgIGxhbmd1YWdlTmFtZSA9IF9yZWYubGFuZ3VhZ2VOYW1lLFxuICAgIGdlbnJlTmFtZSA9IF9yZWYuZ2VucmVOYW1lLFxuICAgIHB1Ymxpc2hlck5hbWUgPSBfcmVmLnB1Ymxpc2hlck5hbWUsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCRjKTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIGFnZ3JlZ2F0ZVJhdGluZzogc2V0QWdncmVnYXRlUmF0aW5nKGFnZ3JlZ2F0ZVJhdGluZyksXG4gICAgdHJhaWxlcjogc2V0VmlkZW8odHJhaWxlciksXG4gICAgcmV2aWV3OiBzZXRSZXZpZXdzKHJldmlld3MpLFxuICAgIGltYWdlOiBzZXRJbWFnZShpbWFnZSksXG4gICAgYXV0aG9yOiBzZXRBdXRob3IoYXV0aG9yTmFtZSksXG4gICAgcHJvdmlkZXI6IHNldFByb3ZpZGVyKHByb3ZpZGVyKSxcbiAgICBwcm9kdWNlcjogc2V0UHJvZHVjZXIoe1xuICAgICAgbmFtZTogcHJvZHVjZXJOYW1lLFxuICAgICAgdXJsOiBwcm9kdWNlclVybFxuICAgIH0pLFxuICAgIG9mZmVyczogc2V0T2ZmZXJzKG9mZmVycyksXG4gICAgb3BlcmF0aW5nU3lzdGVtOiBvcGVyYXRpbmdTeXN0ZW1OYW1lLFxuICAgIGdhbWVQbGF0Zm9ybTogcGxhdGZvcm1OYW1lLFxuICAgIHRyYW5zbGF0b3I6IHRyYW5zbGF0b3JOYW1lLFxuICAgIGluTGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICBnZW5yZTogZ2VucmVOYW1lLFxuICAgIHB1Ymxpc2hlcjogcHVibGlzaGVyTmFtZVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIGRhdGEsIHtcbiAgICBzY3JpcHRLZXk6IFwiVmlkZW9HYW1lXCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBzZXRDb250YWN0UG9pbnRzKGNvbnRhY3RQb2ludCkge1xuICBpZiAoY29udGFjdFBvaW50ICYmIGNvbnRhY3RQb2ludC5sZW5ndGgpIHtcbiAgICByZXR1cm4gY29udGFjdFBvaW50Lm1hcChmdW5jdGlvbiAoY29udGFjdFBvaW50KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICAnQHR5cGUnOiAnQ29udGFjdFBvaW50J1xuICAgICAgfSwgY29udGFjdFBvaW50KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgX2V4Y2x1ZGVkJGIgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJhZGRyZXNzXCIsIFwiY29udGFjdFBvaW50c1wiLCBcImNvbnRhY3RQb2ludFwiXTtcbmZ1bmN0aW9uIE9yZ2FuaXphdGlvbkpzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ09yZ2FuaXphdGlvbicgOiBfcmVmJHR5cGUsXG4gICAga2V5T3ZlcnJpZGUgPSBfcmVmLmtleU92ZXJyaWRlLFxuICAgIGFkZHJlc3MgPSBfcmVmLmFkZHJlc3MsXG4gICAgY29udGFjdFBvaW50cyA9IF9yZWYuY29udGFjdFBvaW50cyxcbiAgICBjb250YWN0UG9pbnQgPSBfcmVmLmNvbnRhY3RQb2ludCxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJGIpO1xuICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgYWRkcmVzczogc2V0QWRkcmVzcyhhZGRyZXNzKSxcbiAgICBjb250YWN0UG9pbnQ6IHNldENvbnRhY3RQb2ludHMoY29udGFjdFBvaW50IHx8IGNvbnRhY3RQb2ludHMpXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJvcmdhbml6YXRpb25cIlxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHNldFF1ZXN0aW9ucyhxdWVzdGlvbnMpIHtcbiAgaWYgKHF1ZXN0aW9ucyAmJiBxdWVzdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHF1ZXN0aW9ucy5tYXAoZnVuY3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQHR5cGUnOiAnUXVlc3Rpb24nLFxuICAgICAgICBuYW1lOiBxdWVzdGlvbi5xdWVzdGlvbk5hbWUsXG4gICAgICAgIGFjY2VwdGVkQW5zd2VyOiB7XG4gICAgICAgICAgJ0B0eXBlJzogJ0Fuc3dlcicsXG4gICAgICAgICAgdGV4dDogcXVlc3Rpb24uYWNjZXB0ZWRBbnN3ZXJUZXh0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIF9leGNsdWRlZCRhID0gW1widHlwZVwiLCBcImtleU92ZXJyaWRlXCIsIFwibWFpbkVudGl0eVwiXTtcbmZ1bmN0aW9uIEZBUVBhZ2VKc29uTGQoX3JlZikge1xuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/ICdGQVFQYWdlJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgbWFpbkVudGl0eSA9IF9yZWYubWFpbkVudGl0eSxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJGEpO1xuICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgbWFpbkVudGl0eTogc2V0UXVlc3Rpb25zKG1haW5FbnRpdHkpXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJmYXEtcGFnZVwiXG4gIH0pKTtcbn1cblxudmFyIF9leGNsdWRlZCQ5ID0gW1widHlwZVwiLCBcImtleU92ZXJyaWRlXCJdO1xuZnVuY3Rpb24gTG9nb0pzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ09yZ2FuaXphdGlvbicgOiBfcmVmJHR5cGUsXG4gICAga2V5T3ZlcnJpZGUgPSBfcmVmLmtleU92ZXJyaWRlLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkOSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCByZXN0LCB7XG4gICAgc2NyaXB0S2V5OiBcIkxvZ29cIlxuICB9KSk7XG59XG5cbnZhciBfZXhjbHVkZWQkOCA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiXTtcbmZ1bmN0aW9uIERhdGFzZXRKc29uTGQoX3JlZikge1xuICB2YXIgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/ICdEYXRhc2V0JyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQ4KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIHJlc3QsIHtcbiAgICBzY3JpcHRLZXk6IFwiZGF0YXNldFwiXG4gIH0pKTtcbn1cblxudmFyIF9leGNsdWRlZCQ3ID0gW1widHlwZVwiLCBcImtleU92ZXJyaWRlXCIsIFwiY291cnNlTmFtZVwiLCBcInByb3ZpZGVyXCJdO1xuZnVuY3Rpb24gQ291cnNlSnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnQ291cnNlJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgY291cnNlTmFtZSA9IF9yZWYuY291cnNlTmFtZSxcbiAgICBwcm92aWRlciA9IF9yZWYucHJvdmlkZXIsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQ3KTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7XG4gICAgbmFtZTogY291cnNlTmFtZVxuICB9LCByZXN0LCB7XG4gICAgcHJvdmlkZXI6IHNldFByb3ZpZGVyKHByb3ZpZGVyKVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIGRhdGEsIHtcbiAgICBzY3JpcHRLZXk6IFwiY291cnNlXCJcbiAgfSkpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDYgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJpdGVtTGlzdEVsZW1lbnRzXCJdO1xuZnVuY3Rpb24gQnJlYWRDcnVtYkpzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ0JyZWFkY3J1bWJMaXN0JyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgaXRlbUxpc3RFbGVtZW50cyA9IF9yZWYuaXRlbUxpc3RFbGVtZW50cyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJDYpO1xuICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgaXRlbUxpc3RFbGVtZW50OiBzZXRJdGVtTGlzdEVsZW1lbnRzKGl0ZW1MaXN0RWxlbWVudHMpXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSnNvbkxkLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXlPdmVycmlkZToga2V5T3ZlcnJpZGVcbiAgfSwgZGF0YSwge1xuICAgIHNjcmlwdEtleTogXCJicmVhZGNydW1iXCJcbiAgfSkpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDUgPSBbXCJ0eXBlXCIsIFwiaWRcIiwgXCJrZXlPdmVycmlkZVwiLCBcImFnZ3JlZ2F0ZVJhdGluZ1wiXTtcbmZ1bmN0aW9uIEJyYW5kSnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnQnJhbmQnIDogX3JlZiR0eXBlLFxuICAgIGlkID0gX3JlZi5pZCxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgYWdncmVnYXRlUmF0aW5nID0gX3JlZi5hZ2dyZWdhdGVSYXRpbmcsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQ1KTtcbiAgdmFyIGRhdGEgPSBfZXh0ZW5kcyh7XG4gICAgYWdncmVnYXRlUmF0aW5nOiBzZXRBZ2dyZWdhdGVSYXRpbmcoYWdncmVnYXRlUmF0aW5nKSxcbiAgICAnQGlkJzogaWRcbiAgfSwgcmVzdCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBkYXRhLCB7XG4gICAgc2NyaXB0S2V5OiBcImJyYW5kXCJcbiAgfSkpO1xufVxuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJ0eXBlXCIsIFwia2V5T3ZlcnJpZGVcIiwgXCJ1cmxcIiwgXCJ0aXRsZVwiLCBcImltYWdlc1wiLCBcImRhdGVQdWJsaXNoZWRcIiwgXCJkYXRlTW9kaWZpZWRcIiwgXCJhdXRob3JOYW1lXCIsIFwicHVibGlzaGVyTmFtZVwiLCBcInB1Ymxpc2hlckxvZ29cIiwgXCJkZXNjcmlwdGlvblwiLCBcImlzQWNjZXNzaWJsZUZvckZyZWVcIl07XG5mdW5jdGlvbiBBcnRpY2xlSnNvbkxkKF9yZWYpIHtcbiAgdmFyIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICB0eXBlID0gX3JlZiR0eXBlID09PSB2b2lkIDAgPyAnQXJ0aWNsZScgOiBfcmVmJHR5cGUsXG4gICAga2V5T3ZlcnJpZGUgPSBfcmVmLmtleU92ZXJyaWRlLFxuICAgIHVybCA9IF9yZWYudXJsLFxuICAgIHRpdGxlID0gX3JlZi50aXRsZSxcbiAgICBpbWFnZXMgPSBfcmVmLmltYWdlcyxcbiAgICBkYXRlUHVibGlzaGVkID0gX3JlZi5kYXRlUHVibGlzaGVkLFxuICAgIGRhdGVNb2RpZmllZCA9IF9yZWYuZGF0ZU1vZGlmaWVkLFxuICAgIGF1dGhvck5hbWUgPSBfcmVmLmF1dGhvck5hbWUsXG4gICAgX3JlZiRwdWJsaXNoZXJOYW1lID0gX3JlZi5wdWJsaXNoZXJOYW1lLFxuICAgIHB1Ymxpc2hlck5hbWUgPSBfcmVmJHB1Ymxpc2hlck5hbWUgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9yZWYkcHVibGlzaGVyTmFtZSxcbiAgICBfcmVmJHB1Ymxpc2hlckxvZ28gPSBfcmVmLnB1Ymxpc2hlckxvZ28sXG4gICAgcHVibGlzaGVyTG9nbyA9IF9yZWYkcHVibGlzaGVyTG9nbyA9PT0gdm9pZCAwID8gdW5kZWZpbmVkIDogX3JlZiRwdWJsaXNoZXJMb2dvLFxuICAgIGRlc2NyaXB0aW9uID0gX3JlZi5kZXNjcmlwdGlvbixcbiAgICBpc0FjY2Vzc2libGVGb3JGcmVlID0gX3JlZi5pc0FjY2Vzc2libGVGb3JGcmVlLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkNCk7XG4gIHZhciBkYXRhID0gX2V4dGVuZHMoe1xuICAgIGRhdGVQdWJsaXNoZWQ6IGRhdGVQdWJsaXNoZWQsXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgIG1haW5FbnRpdHlPZlBhZ2U6IHtcbiAgICAgICdAdHlwZSc6ICdXZWJQYWdlJyxcbiAgICAgICdAaWQnOiB1cmxcbiAgICB9LFxuICAgIGhlYWRsaW5lOiB0aXRsZSxcbiAgICBpbWFnZTogaW1hZ2VzLFxuICAgIGRhdGVNb2RpZmllZDogZGF0ZU1vZGlmaWVkIHx8IGRhdGVQdWJsaXNoZWQsXG4gICAgYXV0aG9yOiBzZXRBdXRob3IoYXV0aG9yTmFtZSksXG4gICAgcHVibGlzaGVyOiBzZXRQdWJsaXNoZXIocHVibGlzaGVyTmFtZSwgcHVibGlzaGVyTG9nbyksXG4gICAgaXNBY2Nlc3NpYmxlRm9yRnJlZTogaXNBY2Nlc3NpYmxlRm9yRnJlZVxuICB9LCByZXN0KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIGRhdGEsIHtcbiAgICBzY3JpcHRLZXk6IFwiYXJ0aWNsZVwiXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gc2V0UmV2aWV3ZWRCeShyZXZpZXdlZEJ5KSB7XG4gIGlmIChyZXZpZXdlZEJ5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICdAdHlwZSc6IChyZXZpZXdlZEJ5ID09IG51bGwgPyB2b2lkIDAgOiByZXZpZXdlZEJ5LnR5cGUpIHx8ICdPcmdhbml6YXRpb24nXG4gICAgfSwgcmV2aWV3ZWRCeSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIF9leGNsdWRlZCQzID0gW1wia2V5T3ZlcnJpZGVcIiwgXCJyZXZpZXdlZEJ5XCJdO1xuZnVuY3Rpb24gV2ViUGFnZUpzb25MZChfcmVmKSB7XG4gIHZhciBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgcmV2aWV3ZWRCeSA9IF9yZWYucmV2aWV3ZWRCeSxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJDMpO1xuICB2YXIgZGF0YSA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgcmV2aWV3ZWRCeTogc2V0UmV2aWV3ZWRCeShyZXZpZXdlZEJ5KVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBkYXRhLCB7XG4gICAgdHlwZTogXCJXZWJQYWdlXCIsXG4gICAgc2NyaXB0S2V5OiBcIldlYlBhZ2VcIlxuICB9KSk7XG59XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcInR5cGVcIiwgXCJrZXlPdmVycmlkZVwiXTtcbmZ1bmN0aW9uIFNvY2lhbFByb2ZpbGVKc29uTGQoX3JlZikge1xuICB2YXIgdHlwZSA9IF9yZWYudHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQyKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEpzb25MZCwgX2V4dGVuZHMoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5T3ZlcnJpZGU6IGtleU92ZXJyaWRlXG4gIH0sIHJlc3QsIHtcbiAgICBzY3JpcHRLZXk6IFwic29jaWFsXCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBzZXRDb3N0KGNvc3QpIHtcbiAgaWYgKGNvc3QpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvc3QsIHtcbiAgICAgICdAdHlwZSc6ICdNb25ldGFyeUFtb3VudCdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRTdXBwbHkoc3VwcGx5KSB7XG4gIGlmIChzdXBwbHkpIHtcbiAgICByZXR1cm4gc3VwcGx5Lm1hcChmdW5jdGlvbiAoc3VwcGx5SXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0B0eXBlJzogJ0hvd1RvU3VwcGx5JyxcbiAgICAgICAgbmFtZTogc3VwcGx5SXRlbVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXRUb29sKHRvb2wpIHtcbiAgaWYgKHRvb2wpIHtcbiAgICByZXR1cm4gdG9vbC5tYXAoZnVuY3Rpb24gKHRvb2xJdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQHR5cGUnOiAnSG93VG9Ub29sJyxcbiAgICAgICAgbmFtZTogdG9vbEl0ZW1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0U3RlcChzdGVwKSB7XG4gIGlmIChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXAubWFwKGZ1bmN0aW9uIChzdGVwRWxlbWVudCkge1xuICAgICAgdmFyIGl0ZW1MaXN0RWxlbWVudCA9IHN0ZXBFbGVtZW50Lml0ZW1MaXN0RWxlbWVudCxcbiAgICAgICAgaW1hZ2UgPSBzdGVwRWxlbWVudC5pbWFnZTtcbiAgICAgIHZhciBjdXJyZW50TGlzdEVsZW1lbnRzID0gaXRlbUxpc3RFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBpdGVtTGlzdEVsZW1lbnQubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgIHRleHQgPSBfcmVmLnRleHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ0B0eXBlJzogdHlwZSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RlcEVsZW1lbnQsIHtcbiAgICAgICAgJ0B0eXBlJzogJ0hvd1RvU3RlcCcsXG4gICAgICAgIGl0ZW1MaXN0RWxlbWVudDogY3VycmVudExpc3RFbGVtZW50cyxcbiAgICAgICAgaW1hZ2U6IHNldEltYWdlKGltYWdlKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIF9leGNsdWRlZCQxID0gW1widHlwZVwiLCBcImtleU92ZXJyaWRlXCIsIFwiaW1hZ2VcIiwgXCJlc3RpbWF0ZWRDb3N0XCIsIFwic3VwcGx5XCIsIFwidG9vbFwiLCBcInN0ZXBcIl07XG5mdW5jdGlvbiBob3dUb0pzb25MZChfcmVmKSB7XG4gIHZhciBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gJ0hvd1RvJyA6IF9yZWYkdHlwZSxcbiAgICBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgaW1hZ2UgPSBfcmVmLmltYWdlLFxuICAgIGVzdGltYXRlZENvc3QgPSBfcmVmLmVzdGltYXRlZENvc3QsXG4gICAgc3VwcGx5ID0gX3JlZi5zdXBwbHksXG4gICAgdG9vbCA9IF9yZWYudG9vbCxcbiAgICBzdGVwID0gX3JlZi5zdGVwLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkMSk7XG4gIHZhciBkYXRhID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBpbWFnZTogc2V0SW1hZ2UoaW1hZ2UpLFxuICAgIGVzdGltYXRlZENvc3Q6IHNldENvc3QoZXN0aW1hdGVkQ29zdCksXG4gICAgc3VwcGx5OiBzZXRTdXBwbHkoc3VwcGx5KSxcbiAgICB0b29sOiBzZXRUb29sKHRvb2wpLFxuICAgIHN0ZXA6IHNldFN0ZXAoc3RlcClcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZVxuICB9LCBkYXRhLCB7XG4gICAgc2NyaXB0S2V5OiBcImhvd1RvXCJcbiAgfSkpO1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wia2V5T3ZlcnJpZGVcIiwgXCJpbWFnZXNcIl07XG5mdW5jdGlvbiBJbWFnZUpzb25MZChfcmVmKSB7XG4gIHZhciBrZXlPdmVycmlkZSA9IF9yZWYua2V5T3ZlcnJpZGUsXG4gICAgaW1hZ2VzID0gX3JlZi5pbWFnZXMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChKc29uTGQsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgdHlwZTogXCJJbWFnZU9iamVjdFwiLFxuICAgIGtleU92ZXJyaWRlOiBrZXlPdmVycmlkZSxcbiAgICBkYXRhQXJyYXk6IGltYWdlcyxcbiAgICBzY3JpcHRLZXk6IFwiaW1hZ2VcIlxuICB9KSk7XG59XG5cbmV4cG9ydCB7IEFydGljbGVKc29uTGQsIEJyYW5kSnNvbkxkLCBCcmVhZENydW1iSnNvbkxkIGFzIEJyZWFkY3J1bWJKc29uTGQsIENhcm91c2VsSnNvbkxkLCBDb2xsZWN0aW9uUGFnZUpzb25MZCwgQ29ycG9yYXRlQ29udGFjdEpzb25MZCwgQ291cnNlSnNvbkxkLCBEYXRhc2V0SnNvbkxkLCBEZWZhdWx0U2VvLCBFdmVudEpzb25MZCwgRkFRUGFnZUpzb25MZCwgaG93VG9Kc29uTGQgYXMgSG93VG9Kc29uTGQsIEltYWdlSnNvbkxkLCBKb2JQb3N0aW5nSnNvbkxkLCBMb2NhbEJ1c2luZXNzSnNvbkxkLCBMb2dvSnNvbkxkLCBOZXdzQXJ0aWNsZUpzb25MZCwgTmV4dFNlbywgT3JnYW5pemF0aW9uSnNvbkxkLCBQcm9kdWN0SnNvbkxkLCBQcm9maWxlUGFnZUpzb25MZCwgUUFQYWdlSnNvbkxkLCBSZWNpcGVKc29uTGQsIFNpdGVMaW5rc1NlYXJjaEJveEpzb25MZCwgU29jaWFsUHJvZmlsZUpzb25MZCwgU29mdHdhcmVBcHBKc29uTGQsIFZpZGVvR2FtZUpzb25MZCwgVmlkZW9Kc29uTGQsIFdlYlBhZ2VKc29uTGQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-seo/lib/next-seo.module.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=D%3A%5Cdev_test%5Csrc%5Cpages%5C%5Bslug%5D.tsx&page=%2F%5Bslug%5D!":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=D%3A%5Cdev_test%5Csrc%5Cpages%5C%5Bslug%5D.tsx&page=%2F%5Bslug%5D! ***!
  \**********************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/[slug]\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/[slug].tsx */ \"./src/pages/[slug].tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/[slug]\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1EJTNBJTVDZGV2X3Rlc3QlNUNzcmMlNUNwYWdlcyU1QyU1QnNsdWclNUQudHN4JnBhZ2U9JTJGJTVCc2x1ZyU1RCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzREFBd0I7QUFDL0M7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzljOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9bc2x1Z11cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3NyYy9wYWdlcy9bc2x1Z10udHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9bc2x1Z11cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=D%3A%5Cdev_test%5Csrc%5Cpages%5C%5Bslug%5D.tsx&page=%2F%5Bslug%5D!\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDomainLocale = getDomainLocale;\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0U7QUFDMUIsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTRixnQkFBZ0JLLElBQUksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLGFBQWEsRUFBRTtJQUMzRCxJQUFJTixLQUErQixFQUFFLEVBV3BDLE1BQU07UUFDSCxPQUFPLEtBQUs7SUFDaEIsQ0FBQztBQUNMO0FBRUEsSUFBSSxDQUFDLE9BQU9KLFFBQVF1QixPQUFPLEtBQUssY0FBZSxPQUFPdkIsUUFBUXVCLE9BQU8sS0FBSyxZQUFZdkIsUUFBUXVCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3ZCLFFBQVF1QixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLMUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRdUIsT0FBTyxFQUFFLGNBQWM7UUFBRXRCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPMkIsTUFBTSxDQUFDekIsUUFBUXVCLE9BQU8sRUFBRXZCO0lBQy9CMEIsT0FBTzFCLE9BQU8sR0FBR0EsUUFBUXVCLE9BQU87QUFDbEMsQ0FBQyxDQUVELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcz81YzI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXREb21haW5Mb2NhbGUgPSBnZXREb21haW5Mb2NhbGU7XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XG5mdW5jdGlvbiBnZXREb21haW5Mb2NhbGUocGF0aCwgbG9jYWxlLCBsb2NhbGVzLCBkb21haW5Mb2NhbGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJykubm9ybWFsaXplTG9jYWxlUGF0aDtcbiAgICAgICAgY29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZSgnLi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIHRhcmdldCk7XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gYGh0dHAke2RvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vYDtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTG9jYWxlID0gdGFyZ2V0ID09PSBkb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke3RhcmdldH1gO1xuICAgICAgICAgICAgcmV0dXJuIGAke3Byb3RvfSR7ZG9tYWluLmRvbWFpbn0ke2Jhc2VQYXRofSR7ZmluYWxMb2NhbGV9JHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb21haW4tbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldERvbWFpbkxvY2FsZSIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRoIiwibG9jYWxlIiwibG9jYWxlcyIsImRvbWFpbkxvY2FsZXMiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInJlcXVpcmUiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJ0YXJnZXQiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsInVuZGVmaW5lZCIsInByb3RvIiwiaHR0cCIsImZpbmFsTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use client\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _formatUrl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nvar _getDomainLocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options) {\n    if (false) {}\n    if (!(0, _router).isLocalURL(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(router.prefetch(href, as, options)).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const { target  } = event.currentTarget;\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    const { nodeName  } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || !(0, _router).isLocalURL(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled\n            });\n        }\n    };\n    if (isAppRouter) {\n        // @ts-expect-error startTransition exists.\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formatUrl).formatUrl(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    let children;\n    const { href: hrefProp , as: asProp , children: childrenProp , prefetch: prefetchProp , passHref , replace , shallow , scroll , locale , onClick , onMouseEnter: onMouseEnterProp , onTouchStart: onTouchStartProp , legacyBehavior =true === false  } = props, restProps = _object_without_properties_loose(props, [\n        \"href\",\n        \"as\",\n        \"children\",\n        \"prefetch\",\n        \"passHref\",\n        \"replace\",\n        \"shallow\",\n        \"scroll\",\n        \"locale\",\n        \"onClick\",\n        \"onMouseEnter\",\n        \"onTouchStart\",\n        \"legacyBehavior\"\n    ]);\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    const prefetchEnabled = prefetchProp !== false;\n    const pagesRouter = _react.default.useContext(_routerContext.RouterContext);\n    const appRouter = _react.default.useContext(_appRouterContext.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\".concat(href, \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\"));\n                }\n            }\n        }\n    }\n    const { href: href1 , as  } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref1, resolvedAs] = (0, _router).resolveHref(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref1,\n            as: asProp ? (0, _router).resolveHref(pagesRouter, asProp) : resolvedAs || resolvedHref1\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href1);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link'));\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `'.concat(hrefProp, '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link'));\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but one child is required https://nextjs.org/docs/messages/link-no-children\"));\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\".concat(hrefProp, \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\") + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            var ref;\n            if (((ref = children) == null ? void 0 : ref.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useIntersection).useIntersection({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href1) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href1;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href1,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href1, as, {\n            locale\n        });\n    }, [\n        as,\n        href1,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href1, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            });\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href1, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            });\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user\n    if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getDomainLocale).getDomainLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", Object.assign({}, restProps, childProps), children);\n}, \"ann5/dOH/k5dvIvXTqfdyzq9F1A=\")), \"ann5/dOH/k5dvIvXTqfdyzq9F1A=\");\n_c1 = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOztBQURiO0FBRUFBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJQyxtQ0FBbUNELG1LQUF1RTtBQUM5RyxJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLDRDQUFPO0FBQ3JELElBQUlHLFVBQVVILG1CQUFPQSxDQUFDLHlGQUE2QjtBQUNuRCxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDaEUsSUFBSUssYUFBYUwsbUJBQU9BLENBQUMsbUVBQWM7QUFDdkMsSUFBSU0saUJBQWlCTixtQkFBT0EsQ0FBQywyRkFBOEI7QUFDM0QsSUFBSU8sb0JBQW9CUCxtQkFBT0EsQ0FBQyxtR0FBa0M7QUFDbEUsSUFBSVEsbUJBQW1CUixtQkFBT0EsQ0FBQywrRUFBb0I7QUFDbkQsSUFBSVMsbUJBQW1CVCxtQkFBT0EsQ0FBQyxpRkFBcUI7QUFDcEQsSUFBSVUsZUFBZVYsbUJBQU9BLENBQUMseUVBQWlCO0FBRTVDLE1BQU1XLGFBQWEsSUFBSUM7QUFDdkIsU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsT0FBTyxFQUFFO0lBQ3pDLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUNELElBQUksQ0FBQyxDQUFDLEdBQUdkLE9BQU8sRUFBRWUsVUFBVSxDQUFDSCxPQUFPO1FBQ2hDO0lBQ0osQ0FBQztJQUNELDRFQUE0RTtJQUM1RSxZQUFZO0lBQ1osSUFBSSxDQUFDRSxRQUFRRSxxQkFBcUIsRUFBRTtRQUNoQyxNQUFNQyxTQUNOLE9BQU9ILFFBQVFHLE1BQU0sS0FBSyxjQUFjSCxRQUFRRyxNQUFNLEdBQUcsWUFBWU4sU0FBU0EsT0FBT00sTUFBTSxHQUFHQyxTQUFTO1FBQ3ZHLE1BQU1D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S0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDbUosVUFBVSxLQUFLLGFBQWE7SUFDckt2SixPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPcUosTUFBTSxDQUFDbkosUUFBUUUsT0FBTyxFQUFFRjtJQUMvQnNKLE9BQU90SixPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzP2U0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXJcIik7XG52YXIgX2Zvcm1hdFVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xudmFyIF9hZGRMb2NhbGUgPSByZXF1aXJlKFwiLi9hZGQtbG9jYWxlXCIpO1xudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3VzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG52YXIgX2dldERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoXCIuL2dldC1kb21haW4tbG9jYWxlXCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG5cbmNvbnN0IHByZWZldGNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoMCwgX3JvdXRlcikuaXNMb2NhbFVSTChocmVmKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIHNob3VsZCBvbmx5IGRlZHVwZSByZXF1ZXN0cyB3aGVuIGV4cGVyaW1lbnRhbC5vcHRpbWlzdGljQ2xpZW50Q2FjaGUgaXNcbiAgICAvLyBkaXNhYmxlZC5cbiAgICBpZiAoIW9wdGlvbnMuYnlwYXNzUHJlZmV0Y2hlZENoZWNrKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IC8vIExldCB0aGUgbGluaydzIGxvY2FsZSBwcm9wIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHJvdXRlciBsb2NhbGUuXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSA6ICdsb2NhbGUnIGluIHJvdXRlciA/IHJvdXRlci5sb2NhbGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHByZWZldGNoZWRLZXkgPSBocmVmICsgJyUnICsgYXMgKyAnJScgKyBsb2NhbGU7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZmV0Y2hlZCB0aGUga2V5LCB0aGVuIGRvbid0IHByZWZldGNoIGl0IGFnYWluIVxuICAgICAgICBpZiAocHJlZmV0Y2hlZC5oYXMocHJlZmV0Y2hlZEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIHRoaXMgVVJMIGFzIHByZWZldGNoZWQuXG4gICAgICAgIHByZWZldGNoZWQuYWRkKHByZWZldGNoZWRLZXkpO1xuICAgIH1cbiAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFByb21pc2UucmVzb2x2ZShyb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IHRhcmdldCAgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMjtcbn1cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSAgfSA9IGUuY3VycmVudFRhcmdldDtcbiAgICAvLyBhbmNob3JzIGluc2lkZSBhbiBzdmcgaGF2ZSBhIGxvd2VyY2FzZSBub2RlTmFtZVxuICAgIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQSc7XG4gICAgaWYgKGlzQW5jaG9yTm9kZU5hbWUgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhKDAsIF9yb3V0ZXIpLmlzTG9jYWxVUkwoaHJlZikpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuYXZpZ2F0ZSA9ICgpPT57XG4gICAgICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuICAgICAgICBpZiAoJ2JlZm9yZVBvcFN0YXRlJyBpbiByb3V0ZXIpIHtcbiAgICAgICAgICAgIHJvdXRlcltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ3B1c2gnXShocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHNjcm9sbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oYXMgfHwgaHJlZiwge1xuICAgICAgICAgICAgICAgIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb246ICFwcmVmZXRjaEVuYWJsZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdGFydFRyYW5zaXRpb24gZXhpc3RzLlxuICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24obmF2aWdhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nT3JVcmwodXJsT2JqT3JTdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHVybE9iak9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0VXJsKHVybE9iak9yU3RyaW5nKTtcbn1cbi8qKlxuICogUmVhY3QgQ29tcG9uZW50IHRoYXQgZW5hYmxlcyBjbGllbnQtc2lkZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHJvdXRlcy5cbiAqLyBjb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBGYWlsZWQgcHJvcCB0eXBlOiBUaGUgcHJvcCBcXGAke2FyZ3Mua2V5fVxcYCBleHBlY3RzIGEgJHthcmdzLmV4cGVjdGVkfSBpbiBcXGA8TGluaz5cXGAsIGJ1dCBnb3QgXFxgJHthcmdzLmFjdHVhbH1cXGAgaW5zdGVhZC5gICsgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gXCJcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBocmVmOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcHMgPSBPYmplY3Qua2V5cyhyZXF1aXJlZFByb3BzR3VhcmQpO1xuICAgICAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldID09IG51bGwgfHwgdHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCBvciBgb2JqZWN0YCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcHJvcHNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQgPSB7XG4gICAgICAgICAgICBhczogdHJ1ZSxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICAgICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBvbk1vdXNlRW50ZXI6IHRydWUsXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICBsZWdhY3lCZWhhdmlvcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzID0gT2JqZWN0LmtleXMob3B0aW9uYWxQcm9wc0d1YXJkKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycgJiYgdmFsVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ29uQ2xpY2snIHx8IGtleSA9PT0gJ29uTW91c2VFbnRlcicgfHwga2V5ID09PSAnb25Ub3VjaFN0YXJ0Jykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYGZ1bmN0aW9uYCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdyZXBsYWNlJyB8fCBrZXkgPT09ICdzY3JvbGwnIHx8IGtleSA9PT0gJ3NoYWxsb3cnIHx8IGtleSA9PT0gJ3Bhc3NIcmVmJyB8fCBrZXkgPT09ICdwcmVmZXRjaCcgfHwga2V5ID09PSAnbGVnYWN5QmVoYXZpb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgaGFzV2FybmVkID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbjtcbiAgICBjb25zdCB7IGhyZWY6IGhyZWZQcm9wICwgYXM6IGFzUHJvcCAsIGNoaWxkcmVuOiBjaGlsZHJlblByb3AgLCBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wICwgcGFzc0hyZWYgLCByZXBsYWNlICwgc2hhbGxvdyAsIHNjcm9sbCAsIGxvY2FsZSAsIG9uQ2xpY2sgLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlclByb3AgLCBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydFByb3AgLCAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgaW5saW5lZCBhcyBhIGxpdGVyYWwgYm9vbGVhbiBub3QgYSBzdHJpbmdcbiAgICBsZWdhY3lCZWhhdmlvciA9cHJvY2Vzcy5lbnYuX19ORVhUX05FV19MSU5LX0JFSEFWSU9SID09PSBmYWxzZSAgfSA9IHByb3BzLCByZXN0UHJvcHMgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShwcm9wcywgW1xuICAgICAgICBcImhyZWZcIixcbiAgICAgICAgXCJhc1wiLFxuICAgICAgICBcImNoaWxkcmVuXCIsXG4gICAgICAgIFwicHJlZmV0Y2hcIixcbiAgICAgICAgXCJwYXNzSHJlZlwiLFxuICAgICAgICBcInJlcGxhY2VcIixcbiAgICAgICAgXCJzaGFsbG93XCIsXG4gICAgICAgIFwic2Nyb2xsXCIsXG4gICAgICAgIFwibG9jYWxlXCIsXG4gICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICBcIm9uTW91c2VFbnRlclwiLFxuICAgICAgICBcIm9uVG91Y2hTdGFydFwiLFxuICAgICAgICBcImxlZ2FjeUJlaGF2aW9yXCJcbiAgICBdKTtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZmV0Y2hFbmFibGVkID0gcHJlZmV0Y2hQcm9wICE9PSBmYWxzZTtcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX3JvdXRlckNvbnRleHQuUm91dGVyQ29udGV4dCk7XG4gICAgY29uc3QgYXBwUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5BcHBSb3V0ZXJDb250ZXh0KTtcbiAgICBjb25zdCByb3V0ZXIgPSBwYWdlc1JvdXRlciAhPSBudWxsID8gcGFnZXNSb3V0ZXIgOiBhcHBSb3V0ZXI7XG4gICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuICAgIGNvbnN0IGlzQXBwUm91dGVyID0gIXBhZ2VzUm91dGVyO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChpc0FwcFJvdXRlciAmJiAhYXNQcm9wKSB7XG4gICAgICAgICAgICBsZXQgaHJlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHJlZlByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQcm9wO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaHJlZlByb3AgPT09ICdvYmplY3QnICYmIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3AucGF0aG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0R5bmFtaWNTZWdtZW50ID0gaHJlZi5zcGxpdCgnLycpLnNvbWUoKHNlZ21lbnQpPT5zZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER5bmFtaWMgaHJlZiBcXGAke2hyZWZ9XFxgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgXFxgL2FwcFxcYCByb3V0ZXIsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9hcHAtZGlyLWR5bmFtaWMtaHJlZmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGhyZWYgLCBhcyAgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKCFwYWdlc1JvdXRlcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocGFnZXNSb3V0ZXIsIGhyZWZQcm9wLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgICAgICAgIGFzOiBhc1Byb3AgPyAoMCwgX3JvdXRlcikucmVzb2x2ZUhyZWYocGFnZXNSb3V0ZXIsIGFzUHJvcCkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgcGFnZXNSb3V0ZXIsXG4gICAgICAgIGhyZWZQcm9wLFxuICAgICAgICBhc1Byb3BcbiAgICBdKTtcbiAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG4gICAgY29uc3QgcHJldmlvdXNBcyA9IF9yZWFjdC5kZWZhdWx0LnVzZVJlZihhcyk7XG4gICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgbGV0IGNoaWxkO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIFxcYGhyZWZcXGAgb2YgXFxgJHtocmVmUHJvcH1cXGAgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke2hyZWZQcm9wfVxcYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBcXGBocmVmXFxgIG9mIFxcYCR7aHJlZlByb3B9XFxgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlbmAgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICBpZiAoKChyZWYgPSBjaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50eXBlKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIDxMaW5rPiB3aXRoIDxhPiBjaGlsZC4gUGxlYXNlIHJlbW92ZSA8YT4gb3IgdXNlIDxMaW5rIGxlZ2FjeUJlaGF2aW9yPi5cXG5MZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLW5ldy1saW5rLXdpdGgtZXh0cmEtYW5jaG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRSZWYgPSBsZWdhY3lCZWhhdmlvciA/IGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmIDogZm9yd2FyZGVkUmVmO1xuICAgIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZSwgcmVzZXRWaXNpYmxlXSA9ICgwLCBfdXNlSW50ZXJzZWN0aW9uKS51c2VJbnRlcnNlY3Rpb24oe1xuICAgICAgICByb290TWFyZ2luOiAnMjAwcHgnXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuICAgICAgICAgICAgcHJldmlvdXNIcmVmLmN1cnJlbnQgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGRSZWYoZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXMsXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBocmVmLFxuICAgICAgICByZXNldFZpc2libGUsXG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZlxuICAgIF0pO1xuICAgIC8vIFByZWZldGNoIHRoZSBVUkwgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IGFuZCBpdCdzIHZpc2libGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIGluIGRldiwgd2Ugb25seSBwcmVmZXRjaCBvbiBob3ZlciB0byBhdm9pZCB3YXN0aW5nIHJlc291cmNlcyBhcyB0aGUgcHJlZmV0Y2ggd2lsbCB0cmlnZ2VyIGNvbXBpbGluZyB0aGUgcGFnZS5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBhcyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgaXNWaXNpYmxlLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIHByZWZldGNoRW5hYmxlZCxcbiAgICAgICAgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmxvY2FsZSxcbiAgICAgICAgcm91dGVyLCBcbiAgICBdKTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgICAgICByZWY6IHNldFJlZixcbiAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgcmVuZGVyZWQgaW5zaWRlIG5leHQvbGluayBoYXMgdG8gcGFzcyBjbGljayBldmVudCB0byBcIm9uQ2xpY2tcIiBwcm9wLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyUHJvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCAmJiBpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0IChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0UHJvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZWZldGNoRW5hYmxlZCAmJiBpc0FwcFJvdXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHNlZSB7aHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2Rpc2N1c3Npb25zLzQwMjY4P3NvcnQ9dG9wI2Rpc2N1c3Npb25jb21tZW50LTM1NzI2NDJ9XG4gICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gICAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXG4gICAgaWYgKCFsZWdhY3lCZWhhdmlvciB8fCBwYXNzSHJlZiB8fCBjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmxvY2FsZTtcbiAgICAgICAgLy8gd2Ugb25seSByZW5kZXIgZG9tYWluIGxvY2FsZXMgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiBhIGRvbWFpbiBsb2NhbGVcbiAgICAgICAgLy8gc28gdGhhdCBsb2NhbGUgbGlua3MgYXJlIHN0aWxsIHZpc2l0YWJsZSBpbiBkZXZlbG9wbWVudC9wcmV2aWV3IGVudnNcbiAgICAgICAgY29uc3QgbG9jYWxlRG9tYWluID0gKHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5pc0xvY2FsZURvbWFpbikgJiYgKDAsIF9nZXREb21haW5Mb2NhbGUpLmdldERvbWFpbkxvY2FsZShhcywgY3VyTG9jYWxlLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlcywgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmRvbWFpbkxvY2FsZXMpO1xuICAgICAgICBjaGlsZFByb3BzLmhyZWYgPSBsb2NhbGVEb21haW4gfHwgKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShhcywgY3VyTG9jYWxlLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZGVmYXVsdExvY2FsZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGVnYWN5QmVoYXZpb3IgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcykgOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3RQcm9wcywgY2hpbGRQcm9wcyksIGNoaWxkcmVuKTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gTGluaztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJfcmVhY3QiLCJfcm91dGVyIiwiX2Zvcm1hdFVybCIsIl9hZGRMb2NhbGUiLCJfcm91dGVyQ29udGV4dCIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX3VzZUludGVyc2VjdGlvbiIsIl9nZXREb21haW5Mb2NhbGUiLCJfYWRkQmFzZVBhdGgiLCJwcmVmZXRjaGVkIiwiU2V0IiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiaXNMb2NhbFVSTCIsImJ5cGFzc1ByZWZldGNoZWRDaGVjayIsImxvY2FsZSIsInVuZGVmaW5lZCIsInByZWZldGNoZWRLZXkiLCJoYXMiLCJhZGQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicHJvY2VzcyIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJpc0FwcFJvdXRlciIsInByZWZldGNoRW5hYmxlZCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInRvVXBwZXJDYXNlIiwicHJldmVudERlZmF1bHQiLCJuYXZpZ2F0ZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJzdGFydFRyYW5zaXRpb24iLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiZm9ybWF0VXJsIiwiTGluayIsImZvcndhcmRSZWYiLCJMaW5rQ29tcG9uZW50IiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJjcmVhdGVQcm9wRXJyb3IiLCJhcmdzIiwiRXJyb3IiLCJrZXkiLCJleHBlY3RlZCIsImFjdHVhbCIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJrZXlzIiwiZm9yRWFjaCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJwYXNzSHJlZiIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvblRvdWNoU3RhcnQiLCJsZWdhY3lCZWhhdmlvciIsIm9wdGlvbmFsUHJvcHMiLCJ2YWxUeXBlIiwiaGFzV2FybmVkIiwidXNlUmVmIiwiY3VycmVudCIsImNvbnNvbGUiLCJ3YXJuIiwiY2hpbGRyZW4iLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoUHJvcCIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnRQcm9wIiwiZW52IiwiX19ORVhUX05FV19MSU5LX0JFSEFWSU9SIiwicmVzdFByb3BzIiwiY3JlYXRlRWxlbWVudCIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJhcHBSb3V0ZXIiLCJBcHBSb3V0ZXJDb250ZXh0IiwicGF0aG5hbWUiLCJoYXNEeW5hbWljU2VnbWVudCIsInNwbGl0Iiwic29tZSIsInNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsInJlc29sdmVIcmVmIiwicHJldmlvdXNIcmVmIiwicHJldmlvdXNBcyIsImNoaWxkIiwiQ2hpbGRyZW4iLCJvbmx5IiwicmVmIiwidHlwZSIsImNoaWxkUmVmIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdE1hcmdpbiIsInNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJ1c2VFZmZlY3QiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwiY3VyTG9jYWxlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJnZXREb21haW5Mb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImNsb25lRWxlbWVudCIsImFzc2lnbiIsIl9kZWZhdWx0IiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useIntersection = useIntersection;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef , rootMargin , disabled  } = param;\n    _s();\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react).useState(false);\n    const [element, setElement] = (0, _react).useState(null);\n    (0, _react).useEffect(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true));\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n            }\n        }\n    }, [\n        element,\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible\n    ]);\n    const resetVisible = (0, _react).useCallback(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\n_s(useIntersection, \"mCSdCffdW7h1A87zcVCmaEd/d2A=\");\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0U7QUFDMUIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsNENBQU87QUFDNUIsSUFBSUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDNUQsTUFBTUUsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUNoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQVMsRUFBRTtBQUNqQixTQUFTQyxlQUFlQyxPQUFPLEVBQUU7SUFDN0IsTUFBTUMsS0FBSztRQUNQQyxNQUFNRixRQUFRRSxJQUFJLElBQUksSUFBSTtRQUMxQkMsUUFBUUgsUUFBUUksVUFBVSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsV0FBV1AsT0FBT1EsSUFBSSxDQUFDLENBQUNDLE1BQU1BLElBQUlMLElBQUksS0FBS0QsR0FBR0MsSUFBSSxJQUFJSyxJQUFJSixNQUFNLEtBQUtGLEdBQUdFLE1BQU07SUFDcEYsSUFBSUs7SUFDSixJQUFJSCxVQUFVO1FBQ1ZHLFdBQVdaLFVBQVVhLEdBQUcsQ0FBQ0o7UUFDekIsSUFBSUcsVUFBVTtZQUNWLE9BQU9BO1FBQ1gsQ0FBQztJQUNMLENBQUM7SUFDRCxNQUFNRSxXQUFXLElBQUliO0lBQ3JCLE1BQU1jLFdBQVcsSUFBSWhCLHFCQUFxQixDQUFDaUIsVUFBVTtRQUNqREEsUUFBUUMsT0FBTyxDQUFDLENBQUNDLFFBQVE7WUFDckIsTUFBTUMsV0FBV0wsU0FBU0QsR0FBRyxDQUFDSyxNQUFNRSxNQUFNO1lBQzFDLE1BQU1DLFlBQVlILE1BQU1JLGNBQWMsSUFBSUosTUFBTUssaUJBQWlCLEdBQUc7WUFDcEUsSUFBSUosWUFBWUUsV0FBVztnQkFDdkJGLFNBQVNFO1lBQ2IsQ0FBQztRQUNMO0lBQ0osR0FBR2pCO0lB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R0FBR0EsUUFBUTBELE9BQU87QUFDbEMsQ0FBQyxDQUVELDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzP2ZkOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZUludGVyc2VjdGlvbiA9IHVzZUludGVyc2VjdGlvbjtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgX3JlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1aXJlKFwiLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2tcIik7XG5jb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlkTGlzdCA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0ge1xuICAgICAgICByb290OiBvcHRpb25zLnJvb3QgfHwgbnVsbCxcbiAgICAgICAgbWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW4gfHwgJydcbiAgICB9O1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaWRMaXN0LmZpbmQoKG9iaik9Pm9iai5yb290ID09PSBpZC5yb290ICYmIG9iai5tYXJnaW4gPT09IGlkLm1hcmdpbik7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmIChleGlzdGluZykge1xuICAgICAgICBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoZXhpc3RpbmcpO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcyk9PntcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDA7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaW5zdGFuY2UgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBvYnNlcnZlcixcbiAgICAgICAgZWxlbWVudHNcbiAgICB9O1xuICAgIGlkTGlzdC5wdXNoKGlkKTtcbiAgICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZShlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgaWQgLCBvYnNlcnZlciAsIGVsZW1lbnRzICB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucyk7XG4gICAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAvLyBEZXN0cm95IG9ic2VydmVyIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gd2F0Y2g6XG4gICAgICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaWRMaXN0LmZpbmRJbmRleCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWRMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uKHsgcm9vdFJlZiAsIHJvb3RNYXJnaW4gLCBkaXNhYmxlZCAgfSkge1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gICAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtlbGVtZW50LCBzZXRFbGVtZW50XSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKG51bGwpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG9ic2VydmUoZWxlbWVudCwgKGlzVmlzaWJsZSk9PmlzVmlzaWJsZSAmJiBzZXRWaXNpYmxlKGlzVmlzaWJsZSksIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogcm9vdFJlZiA9PSBudWxsID8gdm9pZCAwIDogcm9vdFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpPT4oMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLmNhbmNlbElkbGVDYWxsYmFjayhpZGxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICByb290UmVmLFxuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldEVsZW1lbnQsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIHJlc2V0VmlzaWJsZVxuICAgIF07XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1pbnRlcnNlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlSW50ZXJzZWN0aW9uIiwiX3JlYWN0IiwicmVxdWlyZSIsIl9yZXF1ZXN0SWRsZUNhbGxiYWNrIiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVycyIsIk1hcCIsImlkTGlzdCIsImNyZWF0ZU9ic2VydmVyIiwib3B0aW9ucyIsImlkIiwicm9vdCIsIm1hcmdpbiIsInJvb3RNYXJnaW4iLCJleGlzdGluZyIsImZpbmQiLCJvYmoiLCJpbnN0YW5jZSIsImdldCIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwicHVzaCIsInNldCIsIm9ic2VydmUiLCJlbGVtZW50IiwidW5vYnNlcnZlIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInJvb3RSZWYiLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVzZVN0YXRlIiwic2V0RWxlbWVudCIsInVzZUVmZmVjdCIsInRhZ05hbWUiLCJjdXJyZW50IiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsInJlc2V0VmlzaWJsZSIsInVzZUNhbGxiYWNrIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./src/components/form.tsx":
/*!*********************************!*\
  !*** ./src/components/form.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CheckoutForm; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction CheckoutForm() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"md:flex \",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"w-full\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"text-sm font-medium text-gray-900\",\n                    children: \"Customer Information\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 5,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"relative pb-5\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            name: \"mail\",\n                            className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                            placeholder: \"E-mail\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 10,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"absolute right-2 top-4 text-xs font-medium text-blue-500\",\n                            children: \"Log out\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 16,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"mt-4 flex items-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    id: \"default-checkbox\",\n                                    type: \"checkbox\",\n                                    value: \"\",\n                                    className: \"h-3 w-3 rounded border-gray-300 bg-gray-100 text-xs text-blue-600 placeholder:text-zinc-500 focus:outline-none focus:ring-2 dark:border-gray-600 dark:bg-gray-700 dark:ring-offset-gray-800 \"\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                                    lineNumber: 20,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    htmlFor: \"default-checkbox\",\n                                    className: \"ml-1 text-xs\",\n                                    children: \"Keep me up to date with news and special offers\"\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                                    lineNumber: 26,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 19,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 9,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"text-sm font-medium text-gray-900\",\n                    children: \"Shipping Address\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 32,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid md:grid-cols-2 md:gap-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            name: \"mail\",\n                            className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                            placeholder: \"First name*\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 37,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            name: \"mail\",\n                            className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                            placeholder: \"Last name*\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 43,\n                            columnNumber: 11\n                        }, this),\n                        \" \"\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 36,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                    type: \"text\",\n                    name: \"mail\",\n                    className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                    placeholder: \"Company (optional)\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 50,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                    type: \"text\",\n                    name: \"mail\",\n                    className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                    placeholder: \"Address*\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                    type: \"text\",\n                    name: \"mail\",\n                    className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                    placeholder: \"Apartment, suite, etc. (optional)\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 62,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid md:grid-cols-3 md:gap-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            name: \"mail\",\n                            className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                            placeholder: \"Zipcode*\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 69,\n                            columnNumber: 11\n                        }, this),\n                        \" \",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            name: \"mail\",\n                            className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                            placeholder: \"City*\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 75,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            name: \"mail\",\n                            className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                            placeholder: \"State*\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 81,\n                            columnNumber: 11\n                        }, this),\n                        \" \"\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 68,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                    type: \"text\",\n                    name: \"mail\",\n                    className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                    placeholder: \"Country*\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 88,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                    type: \"text\",\n                    name: \"mail\",\n                    className: \"mt-3 h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                    placeholder: \"Phone Number*\"\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 94,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between pt-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"button\",\n                            className: \"h-12 w-24 text-xs font-medium text-blue-500\",\n                            children: \"Return to cart\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 101,\n                            columnNumber: 11\n                        }, this),\n                        \" \",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"button\",\n                            className: \"h-12 w-48 rounded bg-blue-500 text-xs font-medium text-white\",\n                            children: \"Continue to Shipping\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                            lineNumber: 107,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n                    lineNumber: 100,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n            lineNumber: 4,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\form.tsx\",\n        lineNumber: 3,\n        columnNumber: 5\n    }, this);\n}\n_c = CheckoutForm;\nvar _c;\n$RefreshReg$(_c, \"CheckoutForm\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9mb3JtLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUFlLFNBQVNBLGVBQWU7SUFDckMscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNEO1lBQUlDLFdBQVU7OzhCQUNiLDhEQUFDQztvQkFBS0QsV0FBVTs4QkFBb0M7Ozs7Ozs4QkFJcEQsOERBQUNEO29CQUFJQyxXQUFVOztzQ0FDYiw4REFBQ0U7NEJBQ0NDLE1BQUs7NEJBQ0xDLE1BQUs7NEJBQ0xKLFdBQVU7NEJBQ1ZLLGFBQVk7Ozs7OztzQ0FFZCw4REFBQ0o7NEJBQUtELFdBQVU7c0NBQTJEOzs7Ozs7c0NBRzNFLDhEQUFDRDs0QkFBSUMsV0FBVTs7OENBQ2IsOERBQUNFO29DQUNDSSxJQUFHO29DQUNISCxNQUFLO29DQUNMSSxPQUFNO29DQUNOUCxXQUFVOzs7Ozs7OENBRVosOERBQUNRO29DQUFNQyxTQUFRO29DQUFtQlQsV0FBVTs4Q0FBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQU0vRCw4REFBQ0M7b0JBQUtELFdBQVU7OEJBQW9DOzs7Ozs7OEJBSXBELDhEQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNFOzRCQUNDQyxNQUFLOzRCQUNMQyxNQUFLOzRCQUNMSixXQUFVOzRCQUNWSyxhQUFZOzs7Ozs7c0NBRWQsOERBQUNIOzRCQUNDQyxNQUFLOzRCQUNMQyxNQUFLOzRCQUNMSixXQUFVOzRCQUNWSyxhQUFZOzs7Ozs7d0JBQ1g7Ozs7Ozs7OEJBRUwsOERBQUNIO29CQUNDQyxNQUFLO29CQUNMQyxNQUFLO29CQUNMSixXQUFVO29CQUNWSyxhQUFZOzs7Ozs7OEJBRWQsOERBQUNIO29CQUNDQyxNQUFLO29CQUNMQyxNQUFLO29CQUNMSixXQUFVO29CQUNWSyxhQUFZOzs7Ozs7OEJBRWQsOERBQUNIO29CQUNDQyxNQUFLO29CQUNMQyxNQUFLO29CQUNMSixXQUFVO29CQUNWSyxhQUFZOzs7Ozs7OEJBRWQsOERBQUNOO29CQUFJQyxXQUFVOztzQ0FDYiw4REFBQ0U7NEJBQ0NDLE1BQUs7NEJBQ0xDLE1BQUs7NEJBQ0xKLFdBQVU7NEJBQ1ZLLGFBQVk7Ozs7Ozt3QkFDWDtzQ0FDSCw4REFBQ0g7NEJBQ0NDLE1BQUs7NEJBQ0xDLE1BQUs7NEJBQ0xKLFdBQVU7NEJBQ1ZLLGFBQVk7Ozs7OztzQ0FFZCw4REFBQ0g7NEJBQ0NDLE1BQUs7NEJBQ0xDLE1BQUs7NEJBQ0xKLFdBQVU7NEJBQ1ZLLGFBQVk7Ozs7Ozt3QkFDWDs7Ozs7Ozs4QkFFTCw4REFBQ0g7b0JBQ0NDLE1BQUs7b0JBQ0xDLE1BQUs7b0JBQ0xKLFdBQVU7b0JBQ1ZLLGFBQVk7Ozs7Ozs4QkFFZCw4REFBQ0g7b0JBQ0NDLE1BQUs7b0JBQ0xDLE1BQUs7b0JBQ0xKLFdBQVU7b0JBQ1ZLLGFBQVk7Ozs7Ozs4QkFFZCw4REFBQ047b0JBQUlDLFdBQVU7O3NDQUNiLDhEQUFDVTs0QkFDQ1AsTUFBSzs0QkFDTEgsV0FBVTtzQ0FDWDs7Ozs7O3dCQUVTO3NDQUNWLDhEQUFDVTs0QkFDQ1AsTUFBSzs0QkFDTEgsV0FBVTtzQ0FDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPWCxDQUFDO0tBcEh1QkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZm9ybS50c3g/Y2E1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDaGVja291dEZvcm0oKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtZDpmbGV4IFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGxcIj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktOTAwXCI+XG4gICAgICAgICAgQ3VzdG9tZXIgSW5mb3JtYXRpb25cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgcGItNVwiPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgbmFtZT1cIm1haWxcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBoLTkgdy1mdWxsIHJvdW5kZWQgYm9yZGVyIHB4LTIgdGV4dC14cyBwbGFjZWhvbGRlcjp0ZXh0LXppbmMtNTAwIGZvY3VzOmJvcmRlci1ncmF5LTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFLW1haWxcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWJzb2x1dGUgcmlnaHQtMiB0b3AtNCB0ZXh0LXhzIGZvbnQtbWVkaXVtIHRleHQtYmx1ZS01MDBcIj5cbiAgICAgICAgICAgIExvZyBvdXRcbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IGZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgaWQ9XCJkZWZhdWx0LWNoZWNrYm94XCJcbiAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgdmFsdWU9XCJcIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJoLTMgdy0zIHJvdW5kZWQgYm9yZGVyLWdyYXktMzAwIGJnLWdyYXktMTAwIHRleHQteHMgdGV4dC1ibHVlLTYwMCBwbGFjZWhvbGRlcjp0ZXh0LXppbmMtNTAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZGFyazpib3JkZXItZ3JheS02MDAgZGFyazpiZy1ncmF5LTcwMCBkYXJrOnJpbmctb2Zmc2V0LWdyYXktODAwIFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJkZWZhdWx0LWNoZWNrYm94XCIgY2xhc3NOYW1lPVwibWwtMSB0ZXh0LXhzXCI+XG4gICAgICAgICAgICAgIEtlZXAgbWUgdXAgdG8gZGF0ZSB3aXRoIG5ld3MgYW5kIHNwZWNpYWwgb2ZmZXJzXG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS05MDBcIj5cbiAgICAgICAgICBTaGlwcGluZyBBZGRyZXNzXG4gICAgICAgIDwvc3Bhbj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgbWQ6Z3JpZC1jb2xzLTIgbWQ6Z2FwLTJcIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIG5hbWU9XCJtYWlsXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTMgaC05IHctZnVsbCByb3VuZGVkIGJvcmRlciBweC0yIHRleHQteHMgcGxhY2Vob2xkZXI6dGV4dC16aW5jLTUwMCBmb2N1czpib3JkZXItZ3JheS01MDAgZm9jdXM6b3V0bGluZS1ub25lXCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRmlyc3QgbmFtZSpcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICBuYW1lPVwibWFpbFwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIGgtOSB3LWZ1bGwgcm91bmRlZCBib3JkZXIgcHgtMiB0ZXh0LXhzIHBsYWNlaG9sZGVyOnRleHQtemluYy01MDAgZm9jdXM6Ym9yZGVyLWdyYXktNTAwIGZvY3VzOm91dGxpbmUtbm9uZVwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkxhc3QgbmFtZSpcIlxuICAgICAgICAgIC8+eycgJ31cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBuYW1lPVwibWFpbFwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBoLTkgdy1mdWxsIHJvdW5kZWQgYm9yZGVyIHB4LTIgdGV4dC14cyBwbGFjZWhvbGRlcjp0ZXh0LXppbmMtNTAwIGZvY3VzOmJvcmRlci1ncmF5LTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQ29tcGFueSAob3B0aW9uYWwpXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIG5hbWU9XCJtYWlsXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIGgtOSB3LWZ1bGwgcm91bmRlZCBib3JkZXIgcHgtMiB0ZXh0LXhzIHBsYWNlaG9sZGVyOnRleHQtemluYy01MDAgZm9jdXM6Ym9yZGVyLWdyYXktNTAwIGZvY3VzOm91dGxpbmUtbm9uZVwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJBZGRyZXNzKlwiXG4gICAgICAgIC8+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBuYW1lPVwibWFpbFwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBoLTkgdy1mdWxsIHJvdW5kZWQgYm9yZGVyIHB4LTIgdGV4dC14cyBwbGFjZWhvbGRlcjp0ZXh0LXppbmMtNTAwIGZvY3VzOmJvcmRlci1ncmF5LTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQXBhcnRtZW50LCBzdWl0ZSwgZXRjLiAob3B0aW9uYWwpXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIG1kOmdyaWQtY29scy0zIG1kOmdhcC0yXCI+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICBuYW1lPVwibWFpbFwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIGgtOSB3LWZ1bGwgcm91bmRlZCBib3JkZXIgcHgtMiB0ZXh0LXhzIHBsYWNlaG9sZGVyOnRleHQtemluYy01MDAgZm9jdXM6Ym9yZGVyLWdyYXktNTAwIGZvY3VzOm91dGxpbmUtbm9uZVwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlppcGNvZGUqXCJcbiAgICAgICAgICAvPnsnICd9XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICBuYW1lPVwibWFpbFwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIGgtOSB3LWZ1bGwgcm91bmRlZCBib3JkZXIgcHgtMiB0ZXh0LXhzIHBsYWNlaG9sZGVyOnRleHQtemluYy01MDAgZm9jdXM6Ym9yZGVyLWdyYXktNTAwIGZvY3VzOm91dGxpbmUtbm9uZVwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkNpdHkqXCJcbiAgICAgICAgICAvPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgbmFtZT1cIm1haWxcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBoLTkgdy1mdWxsIHJvdW5kZWQgYm9yZGVyIHB4LTIgdGV4dC14cyBwbGFjZWhvbGRlcjp0ZXh0LXppbmMtNTAwIGZvY3VzOmJvcmRlci1ncmF5LTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJTdGF0ZSpcIlxuICAgICAgICAgIC8+eycgJ31cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBuYW1lPVwibWFpbFwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBoLTkgdy1mdWxsIHJvdW5kZWQgYm9yZGVyIHB4LTIgdGV4dC14cyBwbGFjZWhvbGRlcjp0ZXh0LXppbmMtNTAwIGZvY3VzOmJvcmRlci1ncmF5LTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQ291bnRyeSpcIlxuICAgICAgICAvPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgbmFtZT1cIm1haWxcIlxuICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTMgaC05IHctZnVsbCByb3VuZGVkIGJvcmRlciBweC0yIHRleHQteHMgcGxhY2Vob2xkZXI6dGV4dC16aW5jLTUwMCBmb2N1czpib3JkZXItZ3JheS01MDAgZm9jdXM6b3V0bGluZS1ub25lXCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIlBob25lIE51bWJlcipcIlxuICAgICAgICAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBwdC0yXCI+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJoLTEyIHctMjQgdGV4dC14cyBmb250LW1lZGl1bSB0ZXh0LWJsdWUtNTAwXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBSZXR1cm4gdG8gY2FydFxuICAgICAgICAgIDwvYnV0dG9uPnsnICd9XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJoLTEyIHctNDggcm91bmRlZCBiZy1ibHVlLTUwMCB0ZXh0LXhzIGZvbnQtbWVkaXVtIHRleHQtd2hpdGVcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIENvbnRpbnVlIHRvIFNoaXBwaW5nXG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiQ2hlY2tvdXRGb3JtIiwiZGl2IiwiY2xhc3NOYW1lIiwic3BhbiIsImlucHV0IiwidHlwZSIsIm5hbWUiLCJwbGFjZWhvbGRlciIsImlkIiwidmFsdWUiLCJsYWJlbCIsImh0bWxGb3IiLCJidXR0b24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/form.tsx\n"));

/***/ }),

/***/ "./src/components/loading.tsx":
/*!************************************!*\
  !*** ./src/components/loading.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Loader; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction Loader() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        role: \"status\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                \"aria-hidden\": \"true\",\n                className: \"mr-2 h-8 w-8 animate-spin fill-blue-600 text-gray-200 dark:text-gray-600\",\n                viewBox: \"0 0 100 101\",\n                fill: \"none\",\n                xmlns: \"http://www.w3.org/2000/svg\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z\",\n                        fill: \"currentColor\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\loading.tsx\",\n                        lineNumber: 11,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z\",\n                        fill: \"currentFill\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\loading.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\loading.tsx\",\n                lineNumber: 4,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"sr-only\",\n                children: \"Loading...\"\n            }, void 0, false, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\loading.tsx\",\n                lineNumber: 20,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\loading.tsx\",\n        lineNumber: 3,\n        columnNumber: 5\n    }, this);\n}\n_c = Loader;\nvar _c;\n$RefreshReg$(_c, \"Loader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9sb2FkaW5nLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUFlLFNBQVNBLFNBQVM7SUFDL0IscUJBQ0UsOERBQUNDO1FBQUlDLE1BQUs7OzBCQUNSLDhEQUFDQztnQkFDQ0MsZUFBWTtnQkFDWkMsV0FBVTtnQkFDVkMsU0FBUTtnQkFDUkMsTUFBSztnQkFDTEMsT0FBTTs7a0NBRU4sOERBQUNDO3dCQUNDQyxHQUFFO3dCQUNGSCxNQUFLOzs7Ozs7a0NBRVAsOERBQUNFO3dCQUNDQyxHQUFFO3dCQUNGSCxNQUFLOzs7Ozs7Ozs7Ozs7MEJBR1QsOERBQUNJO2dCQUFLTixXQUFVOzBCQUFVOzs7Ozs7Ozs7Ozs7QUFHaEMsQ0FBQztLQXRCdUJMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2xvYWRpbmcudHN4PzAzMDciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTG9hZGVyKCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgcm9sZT1cInN0YXR1c1wiPlxuICAgICAgPHN2Z1xuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICBjbGFzc05hbWU9XCJtci0yIGgtOCB3LTggYW5pbWF0ZS1zcGluIGZpbGwtYmx1ZS02MDAgdGV4dC1ncmF5LTIwMCBkYXJrOnRleHQtZ3JheS02MDBcIlxuICAgICAgICB2aWV3Qm94PVwiMCAwIDEwMCAxMDFcIlxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJNMTAwIDUwLjU5MDhDMTAwIDc4LjIwNTEgNzcuNjE0MiAxMDAuNTkxIDUwIDEwMC41OTFDMjIuMzg1OCAxMDAuNTkxIDAgNzguMjA1MSAwIDUwLjU5MDhDMCAyMi45NzY2IDIyLjM4NTggMC41OTA4MiA1MCAwLjU5MDgyQzc3LjYxNDIgMC41OTA4MiAxMDAgMjIuOTc2NiAxMDAgNTAuNTkwOFpNOS4wODE0NCA1MC41OTA4QzkuMDgxNDQgNzMuMTg5NSAyNy40MDEzIDkxLjUwOTQgNTAgOTEuNTA5NEM3Mi41OTg3IDkxLjUwOTQgOTAuOTE4NiA3My4xODk1IDkwLjkxODYgNTAuNTkwOEM5MC45MTg2IDI3Ljk5MjEgNzIuNTk4NyA5LjY3MjI2IDUwIDkuNjcyMjZDMjcuNDAxMyA5LjY3MjI2IDkuMDgxNDQgMjcuOTkyMSA5LjA4MTQ0IDUwLjU5MDhaXCJcbiAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTkzLjk2NzYgMzkuMDQwOUM5Ni4zOTMgMzguNDAzOCA5Ny44NjI0IDM1LjkxMTYgOTcuMDA3OSAzMy41NTM5Qzk1LjI5MzIgMjguODIyNyA5Mi44NzEgMjQuMzY5MiA4OS44MTY3IDIwLjM0OEM4NS44NDUyIDE1LjExOTIgODAuODgyNiAxMC43MjM4IDc1LjIxMjQgNy40MTI4OUM2OS41NDIyIDQuMTAxOTQgNjMuMjc1NCAxLjk0MDI1IDU2Ljc2OTggMS4wNTEyNEM1MS43NjY2IDAuMzY3NTQxIDQ2LjY5NzYgMC40NDY4NDMgNDEuNzM0NSAxLjI3ODczQzM5LjI2MTMgMS42OTMyOCAzNy44MTMgNC4xOTc3OCAzOC40NTAxIDYuNjIzMjZDMzkuMDg3MyA5LjA0ODc0IDQxLjU2OTQgMTAuNDcxNyA0NC4wNTA1IDEwLjEwNzFDNDcuODUxMSA5LjU0ODU1IDUxLjcxOTEgOS41MjY4OSA1NS41NDAyIDEwLjA0OTFDNjAuODY0MiAxMC43NzY2IDY1Ljk5MjggMTIuNTQ1NyA3MC42MzMxIDE1LjI1NTJDNzUuMjczNSAxNy45NjQ4IDc5LjMzNDcgMjEuNTYxOSA4Mi41ODQ5IDI1Ljg0MUM4NC45MTc1IDI4LjkxMjEgODYuNzk5NyAzMi4yOTEzIDg4LjE4MTEgMzUuODc1OEM4OS4wODMgMzguMjE1OCA5MS41NDIxIDM5LjY3ODEgOTMuOTY3NiAzOS4wNDA5WlwiXG4gICAgICAgICAgZmlsbD1cImN1cnJlbnRGaWxsXCJcbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3Itb25seVwiPkxvYWRpbmcuLi48L3NwYW4+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiTG9hZGVyIiwiZGl2Iiwicm9sZSIsInN2ZyIsImFyaWEtaGlkZGVuIiwiY2xhc3NOYW1lIiwidmlld0JveCIsImZpbGwiLCJ4bWxucyIsInBhdGgiLCJkIiwic3BhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/loading.tsx\n"));

/***/ }),

/***/ "./src/components/order_summary.tsx":
/*!******************************************!*\
  !*** ./src/components/order_summary.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ OrderSummary; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_product__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/product */ \"./src/utils/product.ts\");\n/* harmony import */ var _order_summary_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./order_summary_item */ \"./src/components/order_summary_item.tsx\");\n\n\n\nfunction OrderSummary(param) {\n    let { items , discount_total , sub_total , grand_total , tax_total , promotions  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"lg:py-21 relative col-span-full flex flex-col bg-gray-100 py-6 pl-8 pr-4 sm:py-12 lg:col-span-5\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-black\",\n                children: \"Order summary\"\n            }, void 0, false, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                lineNumber: 25,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative max-w-md\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                        className: \"space-y-5\",\n                        children: items.map((e, key)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_order_summary_item__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                ...e\n                            }, key, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 13\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"my-5 h-0.5 w-full bg-white bg-opacity-30\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {}, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 35,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex gap-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"text\",\n                                        name: \"mail\",\n                                        className: \" h-9 w-full rounded border px-2 text-xs placeholder:text-zinc-500 focus:border-gray-500 focus:outline-none\",\n                                        placeholder: \"Coupon code\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 37,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        type: \"button\",\n                                        className: \" rounded bg-zinc-700 px-5 py-2 text-sm font-medium text-white hover:bg-zinc-800 focus:outline-none focus:ring-4 focus:ring-zinc-300 dark:bg-zinc-600 dark:hover:bg-zinc-700 dark:focus:ring-zinc-900\",\n                                        children: \"Apply\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 43,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 36,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {\n                                className: \"pb-2\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 50,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 34,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"flex justify-between text-sm text-black\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Subtotal\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 54,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: (0,_utils_product__WEBPACK_IMPORTED_MODULE_1__.getPrice)(sub_total, \"AUD\")\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 55,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 53,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"flex justify-between text-sm text-black\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Shipping\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 58,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-xs font-light\",\n                                        children: \"\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 59,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"flex justify-between text-sm text-black\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Discount\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 62,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: [\n                                            \"(\",\n                                            (0,_utils_product__WEBPACK_IMPORTED_MODULE_1__.getPrice)(discount_total, \"AUD\"),\n                                            \")\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 63,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 61,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {}, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 65,\n                                columnNumber: 11\n                            }, this),\n                            promotions.count > 0 && promotions.results.length > 0 && promotions.results.map((promotion)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"relative inline-flex rounded-md bg-gray-200 p-2 text-sm text-black\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-xs\",\n                                        children: promotion.name\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 74,\n                                        columnNumber: 17\n                                    }, this)\n                                }, promotion.id, false, {\n                                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                    lineNumber: 70,\n                                    columnNumber: 15\n                                }, this)),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"hr\", {}, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 78,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center justify-between text-lg font-bold text-black\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            \"Total\",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"block text-xs font-light\",\n                                                children: [\n                                                    \"including \",\n                                                    (0,_utils_product__WEBPACK_IMPORTED_MODULE_1__.getPrice)(tax_total, \"AUD\"),\n                                                    \" in taxes\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                                lineNumber: 82,\n                                                columnNumber: 15\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 80,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: (0,_utils_product__WEBPACK_IMPORTED_MODULE_1__.getPrice)(grand_total, \"AUD\")\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                        lineNumber: 86,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 79,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 52,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative mt-10 text-black\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"mb-5 text-lg font-bold\",\n                        children: \"Support\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 92,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-sm font-semibold\",\n                        children: [\n                            \"+01 234 456 789 \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-light\",\n                                children: \"(International)\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 94,\n                                columnNumber: 27\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 93,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"mt-1 text-sm font-semibold\",\n                        children: [\n                            \"support@example.com \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-light\",\n                                children: \"(Email)\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                                lineNumber: 97,\n                                columnNumber: 31\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 96,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"mt-2 text-xs font-medium\",\n                        children: \"Call us now for payment related issues\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                        lineNumber: 99,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                lineNumber: 91,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative mt-10 flex\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"flex flex-col\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-sm font-bold text-black\",\n                            children: \"Money Back Guarantee\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                            lineNumber: 105,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-xs font-medium text-black\",\n                            children: \"within 30 days of purchase\"\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                            lineNumber: 108,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                    lineNumber: 104,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n                lineNumber: 103,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary.tsx\",\n        lineNumber: 24,\n        columnNumber: 5\n    }, this);\n}\n_c = OrderSummary;\nvar _c;\n$RefreshReg$(_c, \"OrderSummary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9vcmRlcl9zdW1tYXJ5LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBRTJDO0FBRVM7QUFFckMsU0FBU0UsYUFBYSxLQWVwQyxFQUFFO1FBZmtDLEVBQ25DQyxNQUFLLEVBQ0xDLGVBQWMsRUFDZEMsVUFBUyxFQUNUQyxZQUFXLEVBQ1hDLFVBQVMsRUFDVEMsV0FBVSxFQVNYLEdBZm9DO0lBZ0JuQyxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNDO2dCQUFHRCxXQUFVOzBCQUFhOzs7Ozs7MEJBRTNCLDhEQUFDRDtnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUNFO3dCQUFHRixXQUFVO2tDQUNYUCxNQUFNVSxHQUFHLENBQUMsQ0FBQ0MsR0FBUUMsb0JBQ2xCLDhEQUFDZCwyREFBZ0JBO2dDQUFZLEdBQUdhLENBQUM7K0JBQVZDOzs7Ozs7Ozs7O2tDQUczQiw4REFBQ047d0JBQUlDLFdBQVU7Ozs7OztrQ0FDZiw4REFBQ0Q7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDTTs7Ozs7MENBQ0QsOERBQUNQO2dDQUFJQyxXQUFVOztrREFDYiw4REFBQ087d0NBQ0NDLE1BQUs7d0NBQ0xDLE1BQUs7d0NBQ0xULFdBQVU7d0NBQ1ZVLGFBQVk7Ozs7OztrREFFZCw4REFBQ0M7d0NBQ0NILE1BQUs7d0NBQ0xSLFdBQVU7a0RBQ1g7Ozs7Ozs7Ozs7OzswQ0FJSCw4REFBQ007Z0NBQUdOLFdBQVU7Ozs7Ozs7Ozs7OztrQ0FFaEIsOERBQUNEO3dCQUFJQyxXQUFVOzswQ0FDYiw4REFBQ1k7Z0NBQUVaLFdBQVU7O2tEQUNYLDhEQUFDYTtrREFBSzs7Ozs7O2tEQUNOLDhEQUFDQTtrREFBTXZCLHdEQUFRQSxDQUFDSyxXQUFXOzs7Ozs7Ozs7Ozs7MENBRTdCLDhEQUFDaUI7Z0NBQUVaLFdBQVU7O2tEQUNYLDhEQUFDYTtrREFBSzs7Ozs7O2tEQUNOLDhEQUFDQTt3Q0FBS2IsV0FBVTtrREFBcUI7Ozs7Ozs7Ozs7OzswQ0FFdkMsOERBQUNZO2dDQUFFWixXQUFVOztrREFDWCw4REFBQ2E7a0RBQUs7Ozs7OztrREFDTiw4REFBQ0E7OzRDQUFLOzRDQUFFdkIsd0RBQVFBLENBQUNJLGdCQUFnQjs0Q0FBTzs7Ozs7Ozs7Ozs7OzswQ0FFMUMsOERBQUNZOzs7Ozs0QkFFQVIsV0FBV2dCLEtBQUssR0FBRyxLQUNsQmhCLFdBQVdpQixPQUFPLENBQUNDLE1BQU0sR0FBRyxLQUM1QmxCLFdBQVdpQixPQUFPLENBQUNaLEdBQUcsQ0FBQyxDQUFDYywwQkFDdEIsOERBQUNsQjtvQ0FFQ0MsV0FBVTs4Q0FFViw0RUFBQ2E7d0NBQUtiLFdBQVU7a0RBQVdpQixVQUFVUixJQUFJOzs7Ozs7bUNBSHBDUSxVQUFVQyxFQUFFOzs7OzswQ0FPdkIsOERBQUNaOzs7OzswQ0FDRCw4REFBQ1A7Z0NBQUlDLFdBQVU7O2tEQUNiLDhEQUFDRDs7NENBQUk7MERBRUgsOERBQUNjO2dEQUFLYixXQUFVOztvREFBMkI7b0RBQzlCVix3REFBUUEsQ0FBQ08sV0FBVztvREFBTzs7Ozs7Ozs7Ozs7OztrREFHMUMsOERBQUNnQjtrREFBTXZCLHdEQUFRQSxDQUFDTSxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBS25DLDhEQUFDRztnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUNtQjt3QkFBR25CLFdBQVU7a0NBQXlCOzs7Ozs7a0NBQ3ZDLDhEQUFDWTt3QkFBRVosV0FBVTs7NEJBQXdCOzBDQUNuQiw4REFBQ2E7Z0NBQUtiLFdBQVU7MENBQWE7Ozs7Ozs7Ozs7OztrQ0FFL0MsOERBQUNZO3dCQUFFWixXQUFVOzs0QkFBNkI7MENBQ3BCLDhEQUFDYTtnQ0FBS2IsV0FBVTswQ0FBYTs7Ozs7Ozs7Ozs7O2tDQUVuRCw4REFBQ1k7d0JBQUVaLFdBQVU7a0NBQTJCOzs7Ozs7Ozs7Ozs7MEJBSTFDLDhEQUFDRDtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ1k7b0JBQUVaLFdBQVU7O3NDQUNYLDhEQUFDYTs0QkFBS2IsV0FBVTtzQ0FBK0I7Ozs7OztzQ0FHL0MsOERBQUNhOzRCQUFLYixXQUFVO3NDQUFpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPM0QsQ0FBQztLQTVHdUJSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL29yZGVyX3N1bW1hcnkudHN4P2I0M2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDYXJ0SXRlbSwgTGlzdFJlc3VsdCB9IGZyb20gJ3N3ZWxsLWpzJztcblxuaW1wb3J0IHsgZ2V0UHJpY2UgfSBmcm9tICdAL3V0aWxzL3Byb2R1Y3QnO1xuXG5pbXBvcnQgT3JkZXJTdW1tYXJ5SXRlbSBmcm9tICcuL29yZGVyX3N1bW1hcnlfaXRlbSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9yZGVyU3VtbWFyeSh7XG4gIGl0ZW1zLFxuICBkaXNjb3VudF90b3RhbCxcbiAgc3ViX3RvdGFsLFxuICBncmFuZF90b3RhbCxcbiAgdGF4X3RvdGFsLFxuICBwcm9tb3Rpb25zLFxufToge1xuICBpdGVtczogQXJyYXk8Q2FydEl0ZW0+O1xuICBkaXNjb3VudF90b3RhbDogbnVtYmVyO1xuICB0b3RhbDogbnVtYmVyO1xuICBzdWJfdG90YWw6IG51bWJlcjtcbiAgdGF4X3RvdGFsOiBudW1iZXI7XG4gIHByb21vdGlvbnM6IExpc3RSZXN1bHQ8YW55PjtcbiAgZ3JhbmRfdG90YWw6IG51bWJlcjtcbn0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImxnOnB5LTIxIHJlbGF0aXZlIGNvbC1zcGFuLWZ1bGwgZmxleCBmbGV4LWNvbCBiZy1ncmF5LTEwMCBweS02IHBsLTggcHItNCBzbTpweS0xMiAgbGc6Y29sLXNwYW4tNVwiPlxuICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtYmxhY2tcIj5PcmRlciBzdW1tYXJ5PC9oMj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBtYXgtdy1tZFwiPlxuICAgICAgICA8dWwgY2xhc3NOYW1lPVwic3BhY2UteS01XCI+XG4gICAgICAgICAge2l0ZW1zLm1hcCgoZTogYW55LCBrZXkpID0+IChcbiAgICAgICAgICAgIDxPcmRlclN1bW1hcnlJdGVtIGtleT17a2V5fSB7Li4uZX0gLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC91bD5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJteS01IGgtMC41IHctZnVsbCBiZy13aGl0ZSBiZy1vcGFjaXR5LTMwXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgICAgPGhyIC8+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICBuYW1lPVwibWFpbFwiXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIiBoLTkgdy1mdWxsIHJvdW5kZWQgYm9yZGVyIHB4LTIgdGV4dC14cyBwbGFjZWhvbGRlcjp0ZXh0LXppbmMtNTAwIGZvY3VzOmJvcmRlci1ncmF5LTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkNvdXBvbiBjb2RlXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCIgcm91bmRlZCBiZy16aW5jLTcwMCBweC01IHB5LTIgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LXdoaXRlIGhvdmVyOmJnLXppbmMtODAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTQgZm9jdXM6cmluZy16aW5jLTMwMCBkYXJrOmJnLXppbmMtNjAwIGRhcms6aG92ZXI6YmctemluYy03MDAgZGFyazpmb2N1czpyaW5nLXppbmMtOTAwXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgQXBwbHlcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxociBjbGFzc05hbWU9XCJwYi0yXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gdGV4dC1zbSAgdGV4dC1ibGFja1wiPlxuICAgICAgICAgICAgPHNwYW4+U3VidG90YWw8L3NwYW4+XG4gICAgICAgICAgICA8c3Bhbj57Z2V0UHJpY2Uoc3ViX3RvdGFsLCAnQVVEJyl9PC9zcGFuPlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiB0ZXh0LXNtICB0ZXh0LWJsYWNrXCI+XG4gICAgICAgICAgICA8c3Bhbj5TaGlwcGluZzwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHMgZm9udC1saWdodFwiPuKAlDwvc3Bhbj5cbiAgICAgICAgICA8L3A+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gdGV4dC1zbSAgdGV4dC1ibGFja1wiPlxuICAgICAgICAgICAgPHNwYW4+RGlzY291bnQ8L3NwYW4+XG4gICAgICAgICAgICA8c3Bhbj4oe2dldFByaWNlKGRpc2NvdW50X3RvdGFsLCAnQVVEJyl9KTwvc3Bhbj5cbiAgICAgICAgICA8L3A+XG4gICAgICAgICAgPGhyIC8+XG5cbiAgICAgICAgICB7cHJvbW90aW9ucy5jb3VudCA+IDAgJiZcbiAgICAgICAgICAgIHByb21vdGlvbnMucmVzdWx0cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBwcm9tb3Rpb25zLnJlc3VsdHMubWFwKChwcm9tb3Rpb24pID0+IChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleT17cHJvbW90aW9uLmlkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlIGlubGluZS1mbGV4ICByb3VuZGVkLW1kIGJnLWdyYXktMjAwIHAtMiB0ZXh0LXNtIHRleHQtYmxhY2tcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC14c1wiPntwcm9tb3Rpb24ubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgey8qIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHNcIj48L3NwYW4+ICovfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDxociAvPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHRleHQtbGcgZm9udC1ib2xkIHRleHQtYmxhY2tcIj5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgIFRvdGFsXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJsb2NrIHRleHQteHMgZm9udC1saWdodFwiPlxuICAgICAgICAgICAgICAgIGluY2x1ZGluZyB7Z2V0UHJpY2UodGF4X3RvdGFsLCAnQVVEJyl9IGluIHRheGVzXG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHNwYW4+e2dldFByaWNlKGdyYW5kX3RvdGFsLCAnQVVEJyl9PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIG10LTEwIHRleHQtYmxhY2tcIj5cbiAgICAgICAgPGgzIGNsYXNzTmFtZT1cIm1iLTUgdGV4dC1sZyBmb250LWJvbGRcIj5TdXBwb3J0PC9oMz5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LXNlbWlib2xkXCI+XG4gICAgICAgICAgKzAxIDIzNCA0NTYgNzg5IDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbGlnaHRcIj4oSW50ZXJuYXRpb25hbCk8L3NwYW4+XG4gICAgICAgIDwvcD5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtMSB0ZXh0LXNtIGZvbnQtc2VtaWJvbGRcIj5cbiAgICAgICAgICBzdXBwb3J0QGV4YW1wbGUuY29tIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbGlnaHRcIj4oRW1haWwpPC9zcGFuPlxuICAgICAgICA8L3A+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cIm10LTIgdGV4dC14cyBmb250LW1lZGl1bVwiPlxuICAgICAgICAgIENhbGwgdXMgbm93IGZvciBwYXltZW50IHJlbGF0ZWQgaXNzdWVzXG4gICAgICAgIDwvcD5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBtdC0xMCBmbGV4XCI+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2xcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtYm9sZCB0ZXh0LWJsYWNrXCI+XG4gICAgICAgICAgICBNb25leSBCYWNrIEd1YXJhbnRlZVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIGZvbnQtbWVkaXVtIHRleHQtYmxhY2tcIj5cbiAgICAgICAgICAgIHdpdGhpbiAzMCBkYXlzIG9mIHB1cmNoYXNlXG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRQcmljZSIsIk9yZGVyU3VtbWFyeUl0ZW0iLCJPcmRlclN1bW1hcnkiLCJpdGVtcyIsImRpc2NvdW50X3RvdGFsIiwic3ViX3RvdGFsIiwiZ3JhbmRfdG90YWwiLCJ0YXhfdG90YWwiLCJwcm9tb3Rpb25zIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJ1bCIsIm1hcCIsImUiLCJrZXkiLCJociIsImlucHV0IiwidHlwZSIsIm5hbWUiLCJwbGFjZWhvbGRlciIsImJ1dHRvbiIsInAiLCJzcGFuIiwiY291bnQiLCJyZXN1bHRzIiwibGVuZ3RoIiwicHJvbW90aW9uIiwiaWQiLCJoMyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/order_summary.tsx\n"));

/***/ }),

/***/ "./src/components/order_summary_item.tsx":
/*!***********************************************!*\
  !*** ./src/components/order_summary_item.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ OrderSummaryItem; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_product__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/product */ \"./src/utils/product.ts\");\n\n\nfunction OrderSummaryItem(param) {\n    let { product , price , variant  } = param;\n    var _product_images_, _product_images__file;\n    var _ref;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n        className: \"flex items-center justify-between\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"inline-flex items-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        src: (_ref = product.images && ((_product_images_ = product.images[0]) === null || _product_images_ === void 0 ? void 0 : (_product_images__file = _product_images_.file) === null || _product_images__file === void 0 ? void 0 : _product_images__file.url)) !== null && _ref !== void 0 ? _ref : \"https://londiniumespresso.com/store/image/cache/catalog/all-machines/londinium-R24-2021-800x800.jpg\",\n                        alt: \"\",\n                        className: \"max-h-16 rounded-md\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary_item.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"ml-3\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-base font-semibold text-black\",\n                                children: product.name\n                            }, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary_item.tsx\",\n                                lineNumber: 27,\n                                columnNumber: 11\n                            }, this),\n                            (variant === null || variant === void 0 ? void 0 : variant.name) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm font-medium text-black text-opacity-80\",\n                                children: variant.name\n                            }, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary_item.tsx\",\n                                lineNumber: 29,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary_item.tsx\",\n                        lineNumber: 26,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary_item.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-sm font-semibold text-black\",\n                children: (0,_utils_product__WEBPACK_IMPORTED_MODULE_1__.getPrice)(price, \"AUD\")\n            }, void 0, false, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary_item.tsx\",\n                lineNumber: 35,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\dev_test\\\\src\\\\components\\\\order_summary_item.tsx\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, this);\n}\n_c = OrderSummaryItem;\nvar _c;\n$RefreshReg$(_c, \"OrderSummaryItem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9vcmRlcl9zdW1tYXJ5X2l0ZW0udHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUUyQztBQUU1QixTQUFTQyxpQkFBaUIsS0FTeEMsRUFBRTtRQVRzQyxFQUN2Q0MsUUFBTyxFQUNQQyxNQUFLLEVBQ0xDLFFBQU8sRUFNUixHQVR3QztRQWVWRjtRQUFsQkE7SUFMWCxxQkFDRSw4REFBQ0c7UUFBR0MsV0FBVTs7MEJBQ1osOERBQUNDO2dCQUFJRCxXQUFVOztrQ0FDYiw4REFBQ0U7d0JBQ0NDLEtBQ0UsQ0FBQ1AsT0FBQUEsUUFBUVEsTUFBTSxJQUFJUixDQUFBQSxDQUFBQSxtQkFBQUEsUUFBUVEsTUFBTSxDQUFDLEVBQUUsY0FBakJSLDhCQUFBQSxLQUFBQSxJQUFBQSx5QkFBQUEsaUJBQW1CUyxxREFBbkJULEtBQUFBLDBCQUF5QlUsR0FBRixlQUF6Q1Ysa0JBQUFBLE9BQ0QscUdBQXFHO3dCQUV2R1csS0FBSTt3QkFDSlAsV0FBVTs7Ozs7O2tDQUVaLDhEQUFDQzt3QkFBSUQsV0FBVTs7MENBQ2IsOERBQUNRO2dDQUFFUixXQUFVOzBDQUFzQ0osUUFBUWEsSUFBSTs7Ozs7OzRCQUM5RFgsQ0FBQUEsb0JBQUFBLHFCQUFBQSxLQUFBQSxJQUFBQSxRQUFTVyxJQUFJLG1CQUNaLDhEQUFDRDtnQ0FBRVIsV0FBVTswQ0FDVkYsUUFBUVcsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUtyQiw4REFBQ0Q7Z0JBQUVSLFdBQVU7MEJBQ1ZOLHdEQUFRQSxDQUFDRyxPQUFPOzs7Ozs7Ozs7Ozs7QUFJekIsQ0FBQztLQW5DdUJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL29yZGVyX3N1bW1hcnlfaXRlbS50c3g/ODU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFByb2R1Y3QsIFByb2R1Y3RWYXJpYW50IH0gZnJvbSAnc3dlbGwtanMnO1xuXG5pbXBvcnQgeyBnZXRQcmljZSB9IGZyb20gJ0AvdXRpbHMvcHJvZHVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9yZGVyU3VtbWFyeUl0ZW0oe1xuICBwcm9kdWN0LFxuICBwcmljZSxcbiAgdmFyaWFudCxcbn06IHtcbiAgaXRlbTogb2JqZWN0O1xuICBwcm9kdWN0OiBQcm9kdWN0O1xuICB2YXJpYW50OiBQcm9kdWN0VmFyaWFudDtcbiAgcHJpY2U6IG51bWJlcjtcbn0pIHtcbiAgcmV0dXJuIChcbiAgICA8bGkgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICA8aW1nXG4gICAgICAgICAgc3JjPXtcbiAgICAgICAgICAgIChwcm9kdWN0LmltYWdlcyAmJiBwcm9kdWN0LmltYWdlc1swXT8uZmlsZT8udXJsKSA/P1xuICAgICAgICAgICAgJ2h0dHBzOi8vbG9uZGluaXVtZXNwcmVzc28uY29tL3N0b3JlL2ltYWdlL2NhY2hlL2NhdGFsb2cvYWxsLW1hY2hpbmVzL2xvbmRpbml1bS1SMjQtMjAyMS04MDB4ODAwLmpwZydcbiAgICAgICAgICB9XG4gICAgICAgICAgYWx0PVwiXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJtYXgtaC0xNiByb3VuZGVkLW1kXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtbC0zXCI+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1iYXNlIGZvbnQtc2VtaWJvbGQgdGV4dC1ibGFja1wiPntwcm9kdWN0Lm5hbWV9PC9wPlxuICAgICAgICAgIHt2YXJpYW50Py5uYW1lICYmIChcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ibGFjayB0ZXh0LW9wYWNpdHktODBcIj5cbiAgICAgICAgICAgICAge3ZhcmlhbnQubmFtZX1cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LXNlbWlib2xkIHRleHQtYmxhY2tcIj5cbiAgICAgICAge2dldFByaWNlKHByaWNlLCAnQVVEJyl9XG4gICAgICA8L3A+XG4gICAgPC9saT5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRQcmljZSIsIk9yZGVyU3VtbWFyeUl0ZW0iLCJwcm9kdWN0IiwicHJpY2UiLCJ2YXJpYW50IiwibGkiLCJjbGFzc05hbWUiLCJkaXYiLCJpbWciLCJzcmMiLCJpbWFnZXMiLCJmaWxlIiwidXJsIiwiYWx0IiwicCIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/order_summary_item.tsx\n"));

/***/ }),

/***/ "./src/layouts/Meta.tsx":
/*!******************************!*\
  !*** ./src/layouts/Meta.tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Meta\": function() { return /* binding */ Meta; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_seo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next-seo */ \"./node_modules/next-seo/lib/next-seo.module.js\");\n/* harmony import */ var _utils_AppConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/AppConfig */ \"./src/utils/AppConfig.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Meta = (props)=>{\n    _s();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        charSet: \"UTF-8\"\n                    }, \"charset\", false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                        lineNumber: 19,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width,initial-scale=1\"\n                    }, \"viewport\", false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                        lineNumber: 20,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"apple-touch-icon\",\n                        href: \"\".concat(router.basePath, \"/apple-touch-icon.png\")\n                    }, \"apple\", false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                        lineNumber: 25,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        type: \"image/png\",\n                        sizes: \"32x32\",\n                        href: \"\".concat(router.basePath, \"/favicon-32x32.png\")\n                    }, \"icon32\", false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                        lineNumber: 30,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        type: \"image/png\",\n                        sizes: \"16x16\",\n                        href: \"\".concat(router.basePath, \"/favicon-16x16.png\")\n                    }, \"icon16\", false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                        lineNumber: 37,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"\".concat(router.basePath, \"/favicon.ico\")\n                    }, \"favicon\", false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                        lineNumber: 44,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_seo__WEBPACK_IMPORTED_MODULE_3__.NextSeo, {\n                title: props.title,\n                description: props.description,\n                canonical: props.canonical,\n                openGraph: {\n                    title: props.title,\n                    description: props.description,\n                    url: props.canonical,\n                    locale: _utils_AppConfig__WEBPACK_IMPORTED_MODULE_4__.AppConfig.locale,\n                    site_name: _utils_AppConfig__WEBPACK_IMPORTED_MODULE_4__.AppConfig.site_name\n                }\n            }, void 0, false, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\layouts\\\\Meta.tsx\",\n                lineNumber: 50,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_s(Meta, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = Meta;\n\nvar _c;\n$RefreshReg$(_c, \"Meta\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGF5b3V0cy9NZXRhLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFBNkI7QUFDVztBQUNMO0FBRVc7QUFROUMsTUFBTUksT0FBTyxDQUFDQyxRQUFzQjs7SUFDbEMsTUFBTUMsU0FBU0wsc0RBQVNBO0lBRXhCLHFCQUNFOzswQkFDRSw4REFBQ0Qsa0RBQUlBOztrQ0FDSCw4REFBQ087d0JBQUtDLFNBQVE7dUJBQVk7Ozs7O2tDQUMxQiw4REFBQ0Q7d0JBQ0NFLE1BQUs7d0JBQ0xDLFNBQVE7dUJBQ0o7Ozs7O2tDQUVOLDhEQUFDQzt3QkFDQ0MsS0FBSTt3QkFDSkMsTUFBTSxHQUFtQixPQUFoQlAsT0FBT1EsUUFBUSxFQUFDO3VCQUNyQjs7Ozs7a0NBRU4sOERBQUNIO3dCQUNDQyxLQUFJO3dCQUNKRyxNQUFLO3dCQUNMQyxPQUFNO3dCQUNOSCxNQUFNLEdBQW1CLE9BQWhCUCxPQUFPUSxRQUFRLEVBQUM7dUJBQ3JCOzs7OztrQ0FFTiw4REFBQ0g7d0JBQ0NDLEtBQUk7d0JBQ0pHLE1BQUs7d0JBQ0xDLE9BQU07d0JBQ05ILE1BQU0sR0FBbUIsT0FBaEJQLE9BQU9RLFFBQVEsRUFBQzt1QkFDckI7Ozs7O2tDQUVOLDhEQUFDSDt3QkFDQ0MsS0FBSTt3QkFDSkMsTUFBTSxHQUFtQixPQUFoQlAsT0FBT1EsUUFBUSxFQUFDO3VCQUNyQjs7Ozs7Ozs7Ozs7MEJBR1IsOERBQUNaLDZDQUFPQTtnQkFDTmUsT0FBT1osTUFBTVksS0FBSztnQkFDbEJDLGFBQWFiLE1BQU1hLFdBQVc7Z0JBQzlCQyxXQUFXZCxNQUFNYyxTQUFTO2dCQUMxQkMsV0FBVztvQkFDVEgsT0FBT1osTUFBTVksS0FBSztvQkFDbEJDLGFBQWFiLE1BQU1hLFdBQVc7b0JBQzlCRyxLQUFLaEIsTUFBTWMsU0FBUztvQkFDcEJHLFFBQVFuQiw4REFBZ0I7b0JBQ3hCb0IsV0FBV3BCLGlFQUFtQjtnQkFDaEM7Ozs7Ozs7O0FBSVI7R0FuRE1DOztRQUNXSCxrREFBU0E7OztLQURwQkc7QUFxRFUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xheW91dHMvTWV0YS50c3g/MGY5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInO1xuaW1wb3J0IHsgTmV4dFNlbyB9IGZyb20gJ25leHQtc2VvJztcblxuaW1wb3J0IHsgQXBwQ29uZmlnIH0gZnJvbSAnQC91dGlscy9BcHBDb25maWcnO1xuXG50eXBlIElNZXRhUHJvcHMgPSB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGNhbm9uaWNhbD86IHN0cmluZztcbn07XG5cbmNvbnN0IE1ldGEgPSAocHJvcHM6IElNZXRhUHJvcHMpID0+IHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEhlYWQ+XG4gICAgICAgIDxtZXRhIGNoYXJTZXQ9XCJVVEYtOFwiIGtleT1cImNoYXJzZXRcIiAvPlxuICAgICAgICA8bWV0YVxuICAgICAgICAgIG5hbWU9XCJ2aWV3cG9ydFwiXG4gICAgICAgICAgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTFcIlxuICAgICAgICAgIGtleT1cInZpZXdwb3J0XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGxpbmtcbiAgICAgICAgICByZWw9XCJhcHBsZS10b3VjaC1pY29uXCJcbiAgICAgICAgICBocmVmPXtgJHtyb3V0ZXIuYmFzZVBhdGh9L2FwcGxlLXRvdWNoLWljb24ucG5nYH1cbiAgICAgICAgICBrZXk9XCJhcHBsZVwiXG4gICAgICAgIC8+XG4gICAgICAgIDxsaW5rXG4gICAgICAgICAgcmVsPVwiaWNvblwiXG4gICAgICAgICAgdHlwZT1cImltYWdlL3BuZ1wiXG4gICAgICAgICAgc2l6ZXM9XCIzMngzMlwiXG4gICAgICAgICAgaHJlZj17YCR7cm91dGVyLmJhc2VQYXRofS9mYXZpY29uLTMyeDMyLnBuZ2B9XG4gICAgICAgICAga2V5PVwiaWNvbjMyXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGxpbmtcbiAgICAgICAgICByZWw9XCJpY29uXCJcbiAgICAgICAgICB0eXBlPVwiaW1hZ2UvcG5nXCJcbiAgICAgICAgICBzaXplcz1cIjE2eDE2XCJcbiAgICAgICAgICBocmVmPXtgJHtyb3V0ZXIuYmFzZVBhdGh9L2Zhdmljb24tMTZ4MTYucG5nYH1cbiAgICAgICAgICBrZXk9XCJpY29uMTZcIlxuICAgICAgICAvPlxuICAgICAgICA8bGlua1xuICAgICAgICAgIHJlbD1cImljb25cIlxuICAgICAgICAgIGhyZWY9e2Ake3JvdXRlci5iYXNlUGF0aH0vZmF2aWNvbi5pY29gfVxuICAgICAgICAgIGtleT1cImZhdmljb25cIlxuICAgICAgICAvPlxuICAgICAgPC9IZWFkPlxuICAgICAgPE5leHRTZW9cbiAgICAgICAgdGl0bGU9e3Byb3BzLnRpdGxlfVxuICAgICAgICBkZXNjcmlwdGlvbj17cHJvcHMuZGVzY3JpcHRpb259XG4gICAgICAgIGNhbm9uaWNhbD17cHJvcHMuY2Fub25pY2FsfVxuICAgICAgICBvcGVuR3JhcGg9e3tcbiAgICAgICAgICB0aXRsZTogcHJvcHMudGl0bGUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHByb3BzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHVybDogcHJvcHMuY2Fub25pY2FsLFxuICAgICAgICAgIGxvY2FsZTogQXBwQ29uZmlnLmxvY2FsZSxcbiAgICAgICAgICBzaXRlX25hbWU6IEFwcENvbmZpZy5zaXRlX25hbWUsXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IHsgTWV0YSB9O1xuIl0sIm5hbWVzIjpbIkhlYWQiLCJ1c2VSb3V0ZXIiLCJOZXh0U2VvIiwiQXBwQ29uZmlnIiwiTWV0YSIsInByb3BzIiwicm91dGVyIiwibWV0YSIsImNoYXJTZXQiLCJuYW1lIiwiY29udGVudCIsImxpbmsiLCJyZWwiLCJocmVmIiwiYmFzZVBhdGgiLCJ0eXBlIiwic2l6ZXMiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiY2Fub25pY2FsIiwib3BlbkdyYXBoIiwidXJsIiwibG9jYWxlIiwic2l0ZV9uYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/layouts/Meta.tsx\n"));

/***/ }),

/***/ "./src/pages/[slug].tsx":
/*!******************************!*\
  !*** ./src/pages/[slug].tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__N_SSP\": function() { return /* binding */ __N_SSP; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var swell_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swell-js */ \"./node_modules/swell-js/dist/swell.umd.min.js\");\n/* harmony import */ var swell_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(swell_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_form__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/form */ \"./src/components/form.tsx\");\n/* harmony import */ var _components_loading__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/loading */ \"./src/components/loading.tsx\");\n/* harmony import */ var _components_order_summary__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/order_summary */ \"./src/components/order_summary.tsx\");\n/* harmony import */ var _layouts_Meta__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/layouts/Meta */ \"./src/layouts/Meta.tsx\");\n/* harmony import */ var _templates_Main__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/templates/Main */ \"./src/templates/Main.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst Index = (param)=>{\n    let { checkout_id  } = param;\n    _s();\n    swell_js__WEBPACK_IMPORTED_MODULE_2___default().init(\"toggly\", \"pk_Qo600k0BZTFLNJzuwLIgqAdmzkh720h5\");\n    // Initialize the client first\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [cart, setCart] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setLoading(true);\n        // @ts-ignore\n        swell_js__WEBPACK_IMPORTED_MODULE_2___default().cart.recover(checkout_id).then((e)=>{\n            setCart({\n                ...e\n            });\n        });\n        setLoading(false);\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_templates_Main__WEBPACK_IMPORTED_MODULE_7__.Main, {\n        meta: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_layouts_Meta__WEBPACK_IMPORTED_MODULE_6__.Meta, {\n            title: \"Next.js checkout Presentation\",\n            description: \"Next js checkout is the perfect starter code for your project. Build your React application with the Next.js framework.\"\n        }, void 0, false, void 0, void 0),\n        children: [\n            loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"loading-screen\",\n                className: \"fixed top-0 left-0 z-50 block h-full w-full bg-white\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"relative top-1/2 my-0 mx-auto block h-0 w-0 opacity-75\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_loading__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                        lineNumber: 45,\n                        columnNumber: 13\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                    lineNumber: 44,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                lineNumber: 40,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative bg-white\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mx-auto grid min-h-screen grid-cols-12\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"mx-auto mr-6 py-6 sm:py-12 lg:col-span-3 lg:col-start-4\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"ml-auto w-full\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                        className: \"relative text-center text-2xl font-medium text-gray-700 sm:text-3xl\",\n                                        children: \"Londinium\"\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                        lineNumber: 54,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex flex-wrap items-center justify-center text-xs\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                            className: \"flex items-center gap-2\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    className: \"inline-flex items-center\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                                            href: \"#\",\n                                                            className: \"text-gray-900 hover:text-gray-900\",\n                                                            children: \"Customer Information\"\n                                                        }, void 0, false, {\n                                                            fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                            lineNumber: 60,\n                                                            columnNumber: 21\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"ml-2 h-auto font-medium text-gray-400\",\n                                                            children: \"/\"\n                                                        }, void 0, false, {\n                                                            fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                            lineNumber: 63,\n                                                            columnNumber: 21\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                    lineNumber: 59,\n                                                    columnNumber: 19\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    className: \"inline-flex items-center\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                                            href: \"#\",\n                                                            className: \"text-gray-600 hover:text-gray-900\",\n                                                            children: \"Shipping Method\"\n                                                        }, void 0, false, {\n                                                            fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                            lineNumber: 69,\n                                                            columnNumber: 21\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                            className: \"ml-2 h-auto font-medium text-gray-400\",\n                                                            children: \"/\"\n                                                        }, void 0, false, {\n                                                            fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                            lineNumber: 73,\n                                                            columnNumber: 21\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                    lineNumber: 68,\n                                                    columnNumber: 19\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    className: \"inline-flex items-center\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                                        href: \"#\",\n                                                        className: \" text-gray-600 hover:text-gray-900\",\n                                                        children: \"Payment Method\"\n                                                    }, void 0, false, {\n                                                        fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                        lineNumber: 79,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                }, void 0, false, {\n                                                    fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                                    lineNumber: 78,\n                                                    columnNumber: 19\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                            lineNumber: 58,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                        lineNumber: 57,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_form__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                        lineNumber: 86,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                                lineNumber: 53,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                            lineNumber: 52,\n                            columnNumber: 11\n                        }, undefined),\n                        cart !== null && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_order_summary__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                            ...cart\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                            lineNumber: 89,\n                            columnNumber: 29\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                    lineNumber: 51,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n                lineNumber: 50,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\dev_test\\\\src\\\\pages\\\\[slug].tsx\",\n        lineNumber: 31,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Index, \"kSrK87d3FFXhl+vk/QUq6tTnClk=\");\n_c = Index;\nvar __N_SSP = true;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Index);\nvar _c;\n$RefreshReg$(_c, \"Index\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvW3NsdWddLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFBNEM7QUFFZjtBQUVnQjtBQUNIO0FBQ1k7QUFDaEI7QUFDRTtBQUV4QyxNQUFNUSxRQUFRLFNBQThDO1FBQTdDLEVBQUVDLFlBQVcsRUFBMkI7O0lBQ3JEUCxvREFBVSxDQUNSUyxRQUFtQyxFQUNuQ0EscUNBQXVDO0lBR3pDLDhCQUE4QjtJQUU5QixNQUFNLENBQUNJLFNBQVNDLFdBQVcsR0FBR2YsK0NBQVFBLENBQVUsS0FBSztJQUNyRCxNQUFNLENBQUNnQixNQUFNQyxRQUFRLEdBQUdqQiwrQ0FBUUEsQ0FBYSxJQUFJO0lBQ2pERCxnREFBU0EsQ0FBQyxJQUFNO1FBQ2RnQixXQUFXLElBQUk7UUFDZixhQUFhO1FBQ2JkLDREQUFrQixDQUFDTyxhQUFhVyxJQUFJLENBQUMsQ0FBQ0MsSUFBVztZQUMvQ0gsUUFBUTtnQkFBRSxHQUFHRyxDQUFDO1lBQUM7UUFDakI7UUFDQUwsV0FBVyxLQUFLO0lBQ2xCLEdBQUcsRUFBRTtJQUVMLHFCQUNFLDhEQUFDVCxpREFBSUE7UUFDSGUsb0JBQ0UsOERBQUNoQiwrQ0FBSUE7WUFDSGlCLE9BQU07WUFDTkMsYUFBWTs7O1lBSWZULHlCQUNDLDhEQUFDVTtnQkFDQ0MsSUFBRztnQkFDSEMsV0FBVTswQkFFViw0RUFBQ0M7b0JBQUtELFdBQVU7OEJBQ2QsNEVBQUN2QiwyREFBTUE7Ozs7Ozs7Ozs7Ozs7OzswQkFLYiw4REFBQ3FCO2dCQUFJRSxXQUFVOzBCQUNiLDRFQUFDRjtvQkFBSUUsV0FBVTs7c0NBQ2IsOERBQUNGOzRCQUFJRSxXQUFVO3NDQUNiLDRFQUFDRjtnQ0FBSUUsV0FBVTs7a0RBQ2IsOERBQUNFO3dDQUFHRixXQUFVO2tEQUFzRTs7Ozs7O2tEQUdwRiw4REFBQ0Y7d0NBQUlFLFdBQVU7a0RBQ2IsNEVBQUNHOzRDQUFHSCxXQUFVOzs4REFDWiw4REFBQ0k7b0RBQUdKLFdBQVU7O3NFQUNaLDhEQUFDSzs0REFBRUMsTUFBSzs0REFBSU4sV0FBVTtzRUFBb0M7Ozs7OztzRUFHMUQsOERBQUNDOzREQUFLRCxXQUFVO3NFQUF3Qzs7Ozs7Ozs7Ozs7OzhEQUsxRCw4REFBQ0k7b0RBQUdKLFdBQVU7O3NFQUNaLDhEQUFDSzs0REFBRUMsTUFBSzs0REFBSU4sV0FBVTtzRUFBb0M7Ozs7OztzRUFJMUQsOERBQUNDOzREQUFLRCxXQUFVO3NFQUF3Qzs7Ozs7Ozs7Ozs7OzhEQUsxRCw4REFBQ0k7b0RBQUdKLFdBQVU7OERBQ1osNEVBQUNLO3dEQUFFQyxNQUFLO3dEQUFJTixXQUFVO2tFQUFxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrREFPakUsOERBQUN4Qix3REFBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBR2hCYyxTQUFTLElBQUksa0JBQUksOERBQUNaLGlFQUFZQTs0QkFBRSxHQUFHWSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtsRDtHQW5GTVQ7S0FBQUE7O0FBNkZOLCtEQUFlQSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wYWdlcy9bc2x1Z10udHN4PzZmNDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgQ2FydCB9IGZyb20gJ3N3ZWxsLWpzJztcbmltcG9ydCBzd2VsbCBmcm9tICdzd2VsbC1qcyc7XG5cbmltcG9ydCBDaGVja291dEZvcm0gZnJvbSAnQC9jb21wb25lbnRzL2Zvcm0nO1xuaW1wb3J0IExvYWRlciBmcm9tICdAL2NvbXBvbmVudHMvbG9hZGluZyc7XG5pbXBvcnQgT3JkZXJTdW1tYXJ5IGZyb20gJ0AvY29tcG9uZW50cy9vcmRlcl9zdW1tYXJ5JztcbmltcG9ydCB7IE1ldGEgfSBmcm9tICdAL2xheW91dHMvTWV0YSc7XG5pbXBvcnQgeyBNYWluIH0gZnJvbSAnQC90ZW1wbGF0ZXMvTWFpbic7XG5cbmNvbnN0IEluZGV4ID0gKHsgY2hlY2tvdXRfaWQgfTogeyBjaGVja291dF9pZDogc3RyaW5nIH0pID0+IHtcbiAgc3dlbGwuaW5pdChcbiAgICBwcm9jZXNzLmVudi5ORVhUX1NXRUxMX1BVQkxJQ19TVE9SRSBhcyBzdHJpbmcsXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9TV0VMTF9QVUJMSUNfQVBJX1RPS0VOIGFzIHN0cmluZ1xuICApO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGNsaWVudCBmaXJzdFxuXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2NhcnQsIHNldENhcnRdID0gdXNlU3RhdGU8Q2FydCB8IGFueT4obnVsbCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc3dlbGwuY2FydC5yZWNvdmVyKGNoZWNrb3V0X2lkKS50aGVuKChlOiBhbnkpID0+IHtcbiAgICAgIHNldENhcnQoeyAuLi5lIH0pO1xuICAgIH0pO1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8TWFpblxuICAgICAgbWV0YT17XG4gICAgICAgIDxNZXRhXG4gICAgICAgICAgdGl0bGU9XCJOZXh0LmpzIGNoZWNrb3V0IFByZXNlbnRhdGlvblwiXG4gICAgICAgICAgZGVzY3JpcHRpb249XCJOZXh0IGpzIGNoZWNrb3V0IGlzIHRoZSBwZXJmZWN0IHN0YXJ0ZXIgY29kZSBmb3IgeW91ciBwcm9qZWN0LiBCdWlsZCB5b3VyIFJlYWN0IGFwcGxpY2F0aW9uIHdpdGggdGhlIE5leHQuanMgZnJhbWV3b3JrLlwiXG4gICAgICAgIC8+XG4gICAgICB9XG4gICAgPlxuICAgICAge2xvYWRpbmcgJiYgKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgaWQ9XCJsb2FkaW5nLXNjcmVlblwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgbGVmdC0wIHotNTAgYmxvY2sgIGgtZnVsbCB3LWZ1bGwgYmctd2hpdGVcIlxuICAgICAgICA+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicmVsYXRpdmUgdG9wLTEvMiBteS0wIG14LWF1dG8gYmxvY2sgaC0wIHctMCAgb3BhY2l0eS03NVwiPlxuICAgICAgICAgICAgPExvYWRlciAvPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIGJnLXdoaXRlXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXgtYXV0byBncmlkIG1pbi1oLXNjcmVlbiBncmlkLWNvbHMtMTJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14LWF1dG8gbXItNiAgcHktNiBzbTpweS0xMiBsZzpjb2wtc3Bhbi0zIGxnOmNvbC1zdGFydC00XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1sLWF1dG8gdy1mdWxsXCI+XG4gICAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJyZWxhdGl2ZSB0ZXh0LWNlbnRlciB0ZXh0LTJ4bCBmb250LW1lZGl1bSB0ZXh0LWdyYXktNzAwIHNtOnRleHQtM3hsXCI+XG4gICAgICAgICAgICAgICAgTG9uZGluaXVtXG4gICAgICAgICAgICAgIDwvaDE+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXdyYXAgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQteHNcIj5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktOTAwIGhvdmVyOnRleHQtZ3JheS05MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICBDdXN0b21lciBJbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm1sLTIgaC1hdXRvIGZvbnQtbWVkaXVtIHRleHQtZ3JheS00MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAvXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvbGk+XG5cbiAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICBTaGlwcGluZyBNZXRob2RcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm1sLTIgaC1hdXRvIGZvbnQtbWVkaXVtIHRleHQtZ3JheS00MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAvXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvbGk+XG5cbiAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzc05hbWU9XCIgdGV4dC1ncmF5LTYwMCBob3Zlcjp0ZXh0LWdyYXktOTAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgUGF5bWVudCBNZXRob2RcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICA8Q2hlY2tvdXRGb3JtIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7Y2FydCAhPT0gbnVsbCAmJiA8T3JkZXJTdW1tYXJ5IHsuLi5jYXJ0fSAvPn1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L01haW4+XG4gICk7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmVyU2lkZVByb3BzKGNvbnRleHQ6IGFueSkge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiB7XG4gICAgICBjaGVja291dF9pZDogY29udGV4dC5xdWVyeS5zbHVnLFxuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEluZGV4O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwic3dlbGwiLCJDaGVja291dEZvcm0iLCJMb2FkZXIiLCJPcmRlclN1bW1hcnkiLCJNZXRhIiwiTWFpbiIsIkluZGV4IiwiY2hlY2tvdXRfaWQiLCJpbml0IiwicHJvY2VzcyIsImVudiIsIk5FWFRfU1dFTExfUFVCTElDX1NUT1JFIiwiTkVYVF9TV0VMTF9QVUJMSUNfQVBJX1RPS0VOIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjYXJ0Iiwic2V0Q2FydCIsInJlY292ZXIiLCJ0aGVuIiwiZSIsIm1ldGEiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZGl2IiwiaWQiLCJjbGFzc05hbWUiLCJzcGFuIiwiaDEiLCJ1bCIsImxpIiwiYSIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/[slug].tsx\n"));

/***/ }),

/***/ "./src/templates/Main.tsx":
/*!********************************!*\
  !*** ./src/templates/Main.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Main\": function() { return /* binding */ Main; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_AppConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/AppConfig */ \"./src/utils/AppConfig.ts\");\n\n\n\nconst Main = (props)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full px-1 text-gray-700 antialiased\",\n        children: [\n            props.meta,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mx-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"content text-xl\",\n                        children: props.children\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"border-t text-center\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                className: \"flex flex-wrap justify-center text-xl\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"mr-6\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                            href: \"/\",\n                                            className: \"border-none text-gray-700 hover:text-gray-900\",\n                                            children: \"Home\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                            lineNumber: 20,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                        lineNumber: 19,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"mr-6\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                            href: \"/about/\",\n                                            className: \"border-none text-gray-700 hover:text-gray-900\",\n                                            children: \"About\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                            lineNumber: 28,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                        lineNumber: 27,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"mr-6\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                                            href: \"/blog/\",\n                                            className: \"border-none text-gray-700 hover:text-gray-900\",\n                                            children: \"Blog\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                            lineNumber: 36,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                        lineNumber: 35,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                lineNumber: 18,\n                                columnNumber: 11\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                            lineNumber: 17,\n                            columnNumber: 9\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                        lineNumber: 16,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \" border-gray-300 py-8 text-center text-sm\",\n                        children: [\n                            \"\\xa9 Copyright \",\n                            new Date().getFullYear(),\n                            \" \",\n                            _utils_AppConfig__WEBPACK_IMPORTED_MODULE_2__.AppConfig.title,\n                            \".\",\n                            \" \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"#\",\n                                children: \"Store name\"\n                            }, void 0, false, {\n                                fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                                lineNumber: 48,\n                                columnNumber: 9\n                            }, undefined),\n                            \".\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                        lineNumber: 46,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n                lineNumber: 14,\n                columnNumber: 5\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\dev_test\\\\src\\\\templates\\\\Main.tsx\",\n        lineNumber: 12,\n        columnNumber: 3\n    }, undefined);\n_c = Main;\n\nvar _c;\n$RefreshReg$(_c, \"Main\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdGVtcGxhdGVzL01haW4udHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQTZCO0FBR2lCO0FBTzlDLE1BQU1FLE9BQU8sQ0FBQ0Msc0JBQ1osOERBQUNDO1FBQUlDLFdBQVU7O1lBQ1pGLE1BQU1HLElBQUk7MEJBQ1gsOERBQUNGO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQW1CRixNQUFNSSxRQUFROzs7Ozs7a0NBQ2hELDhEQUFDSDt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ0Q7c0NBQ0MsNEVBQUNJO2dDQUFHSCxXQUFVOztrREFDWiw4REFBQ0k7d0NBQUdKLFdBQVU7a0RBQ1osNEVBQUNMLGtEQUFJQTs0Q0FDSFUsTUFBSzs0Q0FDTEwsV0FBVTtzREFDWDs7Ozs7Ozs7Ozs7a0RBSUgsOERBQUNJO3dDQUFHSixXQUFVO2tEQUNaLDRFQUFDTCxrREFBSUE7NENBQ0hVLE1BQUs7NENBQ0xMLFdBQVU7c0RBQ1g7Ozs7Ozs7Ozs7O2tEQUlILDhEQUFDSTt3Q0FBR0osV0FBVTtrREFDWiw0RUFBQ0wsa0RBQUlBOzRDQUNIVSxNQUFLOzRDQUNMTCxXQUFVO3NEQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBT1QsOERBQUNEO3dCQUFJQyxXQUFVOzs0QkFBNEM7NEJBQzVDLElBQUlNLE9BQU9DLFdBQVc7NEJBQUc7NEJBQUVYLDZEQUFlOzRCQUFDOzRCQUFFOzBDQUMxRCw4REFBQ2E7Z0NBQUVKLE1BQUs7MENBQUk7Ozs7Ozs0QkFBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXJDNUJSO0FBaURVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy90ZW1wbGF0ZXMvTWFpbi50c3g/MDI2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnO1xuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEFwcENvbmZpZyB9IGZyb20gJ0AvdXRpbHMvQXBwQ29uZmlnJztcblxudHlwZSBJTWFpblByb3BzID0ge1xuICBtZXRhOiBSZWFjdE5vZGU7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59O1xuXG5jb25zdCBNYWluID0gKHByb3BzOiBJTWFpblByb3BzKSA9PiAoXG4gIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIHB4LTEgdGV4dC1ncmF5LTcwMCBhbnRpYWxpYXNlZFwiPlxuICAgIHtwcm9wcy5tZXRhfVxuICAgIDxkaXYgY2xhc3NOYW1lPVwibXgtYXV0b1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50IHRleHQteGxcIj57cHJvcHMuY2hpbGRyZW59PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImJvcmRlci10IHRleHQtY2VudGVyXCI+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHVsIGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGp1c3RpZnktY2VudGVyIHRleHQteGxcIj5cbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci02XCI+XG4gICAgICAgICAgICAgIDxMaW5rXG4gICAgICAgICAgICAgICAgaHJlZj1cIi9cIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJvcmRlci1ub25lIHRleHQtZ3JheS03MDAgaG92ZXI6dGV4dC1ncmF5LTkwMFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBIb21lXG4gICAgICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXItNlwiPlxuICAgICAgICAgICAgICA8TGlua1xuICAgICAgICAgICAgICAgIGhyZWY9XCIvYWJvdXQvXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXItbm9uZSB0ZXh0LWdyYXktNzAwIGhvdmVyOnRleHQtZ3JheS05MDBcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQWJvdXRcbiAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtci02XCI+XG4gICAgICAgICAgICAgIDxMaW5rXG4gICAgICAgICAgICAgICAgaHJlZj1cIi9ibG9nL1wiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyLW5vbmUgdGV4dC1ncmF5LTcwMCBob3Zlcjp0ZXh0LWdyYXktOTAwXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIEJsb2dcbiAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCIgYm9yZGVyLWdyYXktMzAwIHB5LTggdGV4dC1jZW50ZXIgdGV4dC1zbVwiPlxuICAgICAgICDCqSBDb3B5cmlnaHQge25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX0ge0FwcENvbmZpZy50aXRsZX0ueycgJ31cbiAgICAgICAgPGEgaHJlZj1cIiNcIj5TdG9yZSBuYW1lPC9hPi5cbiAgICAgICAgey8qXG4gICAgICAgICAqIFBMRUFTRSBSRUFEIFRISVMgU0VDVElPTlxuICAgICAgICAgKiBJJ20gYW4gaW5kaWUgbWFrZXIgd2l0aCBsaW1pdGVkIHJlc291cmNlcyBhbmQgZnVuZHMsIEknbGwgcmVhbGx5IGFwcHJlY2lhdGUgaWYgeW91IGNvdWxkIGhhdmUgYSBsaW5rIHRvIG15IHdlYnNpdGUuXG4gICAgICAgICAqIFRoZSBsaW5rIGRvZXNuJ3QgbmVlZCB0byBhcHBlYXIgb24gZXZlcnkgcGFnZXMsIG9uZSBsaW5rIG9uIG9uZSBwYWdlIGlzIGVub3VnaC5cbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGluIHRoZSBgQWJvdXRgIHBhZ2UuIFRoYW5rIHlvdSBmb3IgeW91ciBzdXBwb3J0LCBpdCdsbCBtZWFuIGEgbG90IHRvIG1lLlxuICAgICAgICAgKi99XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgeyBNYWluIH07XG4iXSwibmFtZXMiOlsiTGluayIsIkFwcENvbmZpZyIsIk1haW4iLCJwcm9wcyIsImRpdiIsImNsYXNzTmFtZSIsIm1ldGEiLCJjaGlsZHJlbiIsInVsIiwibGkiLCJocmVmIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwidGl0bGUiLCJhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/templates/Main.tsx\n"));

/***/ }),

/***/ "./src/utils/AppConfig.ts":
/*!********************************!*\
  !*** ./src/utils/AppConfig.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppConfig\": function() { return /* binding */ AppConfig; }\n/* harmony export */ });\n// FIXME: Update this configuration file based on your project information\nconst AppConfig = {\n    site_name: \"Starter\",\n    title: \"Nextjs Starter\",\n    description: \"Starter code for your Nextjs checkout with Tailwind CSS\",\n    locale: \"en\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvQXBwQ29uZmlnLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwwRUFBMEU7QUFFbkUsTUFBTUEsWUFBWTtJQUN2QkMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLGFBQWE7SUFDYkMsUUFBUTtBQUNWLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL0FwcENvbmZpZy50cz84YTliIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZJWE1FOiBVcGRhdGUgdGhpcyBjb25maWd1cmF0aW9uIGZpbGUgYmFzZWQgb24geW91ciBwcm9qZWN0IGluZm9ybWF0aW9uXG5cbmV4cG9ydCBjb25zdCBBcHBDb25maWcgPSB7XG4gIHNpdGVfbmFtZTogJ1N0YXJ0ZXInLFxuICB0aXRsZTogJ05leHRqcyBTdGFydGVyJyxcbiAgZGVzY3JpcHRpb246ICdTdGFydGVyIGNvZGUgZm9yIHlvdXIgTmV4dGpzIGNoZWNrb3V0IHdpdGggVGFpbHdpbmQgQ1NTJyxcbiAgbG9jYWxlOiAnZW4nLFxufTtcbiJdLCJuYW1lcyI6WyJBcHBDb25maWciLCJzaXRlX25hbWUiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwibG9jYWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/AppConfig.ts\n"));

/***/ }),

/***/ "./src/utils/product.ts":
/*!******************************!*\
  !*** ./src/utils/product.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getPrice\": function() { return /* binding */ getPrice; }\n/* harmony export */ });\nconst getPrice = (price, currency)=>Intl.NumberFormat(undefined, {\n        currency,\n        minimumFractionDigits: 2,\n        style: \"currency\"\n    }).format(parseFloat(price ? \"\".concat(price) : \"0\"));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvcHJvZHVjdC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsV0FBVyxDQUN0QkMsT0FDQUMsV0FFQUMsS0FBS0MsWUFBWSxDQUFDQyxXQUFXO1FBQzNCSDtRQUNBSSx1QkFBdUI7UUFDdkJDLE9BQU87SUFDVCxHQUFHQyxNQUFNLENBQUNDLFdBQVdSLFFBQVEsR0FBUyxPQUFOQSxTQUFVLEdBQUcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvcHJvZHVjdC50cz8xZmM0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBnZXRQcmljZSA9IChcbiAgcHJpY2U6IHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgY3VycmVuY3k6IHN0cmluZ1xuKSA9PlxuICBJbnRsLk51bWJlckZvcm1hdCh1bmRlZmluZWQsIHtcbiAgICBjdXJyZW5jeSxcbiAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgc3R5bGU6ICdjdXJyZW5jeScsXG4gIH0pLmZvcm1hdChwYXJzZUZsb2F0KHByaWNlID8gYCR7cHJpY2V9YCA6ICcwJykpO1xuIl0sIm5hbWVzIjpbImdldFByaWNlIiwicHJpY2UiLCJjdXJyZW5jeSIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJ1bmRlZmluZWQiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJzdHlsZSIsImZvcm1hdCIsInBhcnNlRmxvYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/product.ts\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/swell-js/dist/swell.umd.min.js":
/*!*****************************************************!*\
  !*** ./node_modules/swell-js/dist/swell.umd.min.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* module decorator */ module = __webpack_require__.nmd(module);\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n})(this, (function () { 'use strict';\n\n\tfunction getAugmentedNamespace(n) {\n\t  var f = n.default;\n\t\tif (typeof f == \"function\") {\n\t\t\tvar a = function () {\n\t\t\t\treturn f.apply(this, arguments);\n\t\t\t};\n\t\t\ta.prototype = f.prototype;\n\t  } else a = {};\n\t  Object.defineProperty(a, '__esModule', {value: true});\n\t\tObject.keys(n).forEach(function (k) {\n\t\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn n[k];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn a;\n\t}\n\n\t/* eslint complexity: [2, 18], max-statements: [2, 33] */\n\tvar shams = function hasSymbols() {\n\t\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\t\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t\tvar obj = {};\n\t\tvar sym = Symbol('test');\n\t\tvar symObj = Object(sym);\n\t\tif (typeof sym === 'string') { return false; }\n\n\t\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\t\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t\t// if (sym instanceof Symbol) { return false; }\n\t\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\t\tvar symVal = 42;\n\t\tobj[sym] = symVal;\n\t\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\t\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\t\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\t\tvar syms = Object.getOwnPropertySymbols(obj);\n\t\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\t\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\t\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\n\tvar hasSymbolSham = shams;\n\n\tvar hasSymbols$1 = function hasNativeSymbols() {\n\t\tif (typeof origSymbol !== 'function') { return false; }\n\t\tif (typeof Symbol !== 'function') { return false; }\n\t\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\t\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\t\treturn hasSymbolSham();\n\t};\n\n\t/* eslint no-invalid-this: 1 */\n\n\tvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\n\tvar slice = Array.prototype.slice;\n\tvar toStr$1 = Object.prototype.toString;\n\tvar funcType = '[object Function]';\n\n\tvar implementation$1 = function bind(that) {\n\t    var target = this;\n\t    if (typeof target !== 'function' || toStr$1.call(target) !== funcType) {\n\t        throw new TypeError(ERROR_MESSAGE + target);\n\t    }\n\t    var args = slice.call(arguments, 1);\n\n\t    var bound;\n\t    var binder = function () {\n\t        if (this instanceof bound) {\n\t            var result = target.apply(\n\t                this,\n\t                args.concat(slice.call(arguments))\n\t            );\n\t            if (Object(result) === result) {\n\t                return result;\n\t            }\n\t            return this;\n\t        } else {\n\t            return target.apply(\n\t                that,\n\t                args.concat(slice.call(arguments))\n\t            );\n\t        }\n\t    };\n\n\t    var boundLength = Math.max(0, target.length - args.length);\n\t    var boundArgs = [];\n\t    for (var i = 0; i < boundLength; i++) {\n\t        boundArgs.push('$' + i);\n\t    }\n\n\t    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n\t    if (target.prototype) {\n\t        var Empty = function Empty() {};\n\t        Empty.prototype = target.prototype;\n\t        bound.prototype = new Empty();\n\t        Empty.prototype = null;\n\t    }\n\n\t    return bound;\n\t};\n\n\tvar implementation = implementation$1;\n\n\tvar functionBind = Function.prototype.bind || implementation;\n\n\tvar bind$1 = functionBind;\n\n\tvar src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);\n\n\tvar undefined$1;\n\n\tvar $SyntaxError = SyntaxError;\n\tvar $Function = Function;\n\tvar $TypeError$1 = TypeError;\n\n\t// eslint-disable-next-line consistent-return\n\tvar getEvalledConstructor = function (expressionSyntax) {\n\t\ttry {\n\t\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t\t} catch (e) {}\n\t};\n\n\tvar $gOPD = Object.getOwnPropertyDescriptor;\n\tif ($gOPD) {\n\t\ttry {\n\t\t\t$gOPD({}, '');\n\t\t} catch (e) {\n\t\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t\t}\n\t}\n\n\tvar throwTypeError = function () {\n\t\tthrow new $TypeError$1();\n\t};\n\tvar ThrowTypeError = $gOPD\n\t\t? (function () {\n\t\t\ttry {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\t\treturn throwTypeError;\n\t\t\t} catch (calleeThrows) {\n\t\t\t\ttry {\n\t\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t\t} catch (gOPDthrows) {\n\t\t\t\t\treturn throwTypeError;\n\t\t\t\t}\n\t\t\t}\n\t\t}())\n\t\t: throwTypeError;\n\n\tvar hasSymbols = hasSymbols$1();\n\n\tvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\n\tvar needsEval = {};\n\n\tvar TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);\n\n\tvar INTRINSICS = {\n\t\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,\n\t\t'%Array%': Array,\n\t\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,\n\t\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,\n\t\t'%AsyncFromSyncIteratorPrototype%': undefined$1,\n\t\t'%AsyncFunction%': needsEval,\n\t\t'%AsyncGenerator%': needsEval,\n\t\t'%AsyncGeneratorFunction%': needsEval,\n\t\t'%AsyncIteratorPrototype%': needsEval,\n\t\t'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,\n\t\t'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,\n\t\t'%Boolean%': Boolean,\n\t\t'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,\n\t\t'%Date%': Date,\n\t\t'%decodeURI%': decodeURI,\n\t\t'%decodeURIComponent%': decodeURIComponent,\n\t\t'%encodeURI%': encodeURI,\n\t\t'%encodeURIComponent%': encodeURIComponent,\n\t\t'%Error%': Error,\n\t\t'%eval%': eval, // eslint-disable-line no-eval\n\t\t'%EvalError%': EvalError,\n\t\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,\n\t\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,\n\t\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,\n\t\t'%Function%': $Function,\n\t\t'%GeneratorFunction%': needsEval,\n\t\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,\n\t\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,\n\t\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,\n\t\t'%isFinite%': isFinite,\n\t\t'%isNaN%': isNaN,\n\t\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,\n\t\t'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,\n\t\t'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,\n\t\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Map()[Symbol.iterator]()),\n\t\t'%Math%': Math,\n\t\t'%Number%': Number,\n\t\t'%Object%': Object,\n\t\t'%parseFloat%': parseFloat,\n\t\t'%parseInt%': parseInt,\n\t\t'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,\n\t\t'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,\n\t\t'%RangeError%': RangeError,\n\t\t'%ReferenceError%': ReferenceError,\n\t\t'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,\n\t\t'%RegExp%': RegExp,\n\t\t'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,\n\t\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Set()[Symbol.iterator]()),\n\t\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,\n\t\t'%String%': String,\n\t\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined$1,\n\t\t'%Symbol%': hasSymbols ? Symbol : undefined$1,\n\t\t'%SyntaxError%': $SyntaxError,\n\t\t'%ThrowTypeError%': ThrowTypeError,\n\t\t'%TypedArray%': TypedArray,\n\t\t'%TypeError%': $TypeError$1,\n\t\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,\n\t\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,\n\t\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,\n\t\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,\n\t\t'%URIError%': URIError,\n\t\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,\n\t\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,\n\t\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet\n\t};\n\n\tvar doEval = function doEval(name) {\n\t\tvar value;\n\t\tif (name === '%AsyncFunction%') {\n\t\t\tvalue = getEvalledConstructor('async function () {}');\n\t\t} else if (name === '%GeneratorFunction%') {\n\t\t\tvalue = getEvalledConstructor('function* () {}');\n\t\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\t\tvalue = getEvalledConstructor('async function* () {}');\n\t\t} else if (name === '%AsyncGenerator%') {\n\t\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\t\tif (fn) {\n\t\t\t\tvalue = fn.prototype;\n\t\t\t}\n\t\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\t\tvar gen = doEval('%AsyncGenerator%');\n\t\t\tif (gen) {\n\t\t\t\tvalue = getProto(gen.prototype);\n\t\t\t}\n\t\t}\n\n\t\tINTRINSICS[name] = value;\n\n\t\treturn value;\n\t};\n\n\tvar LEGACY_ALIASES = {\n\t\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t\t'%DatePrototype%': ['Date', 'prototype'],\n\t\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t\t'%JSONParse%': ['JSON', 'parse'],\n\t\t'%JSONStringify%': ['JSON', 'stringify'],\n\t\t'%MapPrototype%': ['Map', 'prototype'],\n\t\t'%NumberPrototype%': ['Number', 'prototype'],\n\t\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t\t'%Promise_all%': ['Promise', 'all'],\n\t\t'%Promise_reject%': ['Promise', 'reject'],\n\t\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t\t'%SetPrototype%': ['Set', 'prototype'],\n\t\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t\t'%StringPrototype%': ['String', 'prototype'],\n\t\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n\t};\n\n\tvar bind = functionBind;\n\tvar hasOwn$1 = src;\n\tvar $concat = bind.call(Function.call, Array.prototype.concat);\n\tvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\n\tvar $replace = bind.call(Function.call, String.prototype.replace);\n\tvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n\t/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\n\tvar rePropName$1 = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n\tvar reEscapeChar$1 = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\n\tvar stringToPath$1 = function stringToPath(string) {\n\t\tvar first = $strSlice(string, 0, 1);\n\t\tvar last = $strSlice(string, -1);\n\t\tif (first === '%' && last !== '%') {\n\t\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t\t} else if (last === '%' && first !== '%') {\n\t\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t\t}\n\t\tvar result = [];\n\t\t$replace(string, rePropName$1, function (match, number, quote, subString) {\n\t\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar$1, '$1') : number || match;\n\t\t});\n\t\treturn result;\n\t};\n\t/* end adaptation */\n\n\tvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\t\tvar intrinsicName = name;\n\t\tvar alias;\n\t\tif (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {\n\t\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\t\tintrinsicName = '%' + alias[0] + '%';\n\t\t}\n\n\t\tif (hasOwn$1(INTRINSICS, intrinsicName)) {\n\t\t\tvar value = INTRINSICS[intrinsicName];\n\t\t\tif (value === needsEval) {\n\t\t\t\tvalue = doEval(intrinsicName);\n\t\t\t}\n\t\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\t\tthrow new $TypeError$1('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\talias: alias,\n\t\t\t\tname: intrinsicName,\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t}\n\n\t\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n\t};\n\n\tvar getIntrinsic = function GetIntrinsic(name, allowMissing) {\n\t\tif (typeof name !== 'string' || name.length === 0) {\n\t\t\tthrow new $TypeError$1('intrinsic name must be a non-empty string');\n\t\t}\n\t\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\t\tthrow new $TypeError$1('\"allowMissing\" argument must be a boolean');\n\t\t}\n\n\t\tvar parts = stringToPath$1(name);\n\t\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\t\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\t\tvar intrinsicRealName = intrinsic.name;\n\t\tvar value = intrinsic.value;\n\t\tvar skipFurtherCaching = false;\n\n\t\tvar alias = intrinsic.alias;\n\t\tif (alias) {\n\t\t\tintrinsicBaseName = alias[0];\n\t\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t\t}\n\n\t\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\t\tvar part = parts[i];\n\t\t\tvar first = $strSlice(part, 0, 1);\n\t\t\tvar last = $strSlice(part, -1);\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t\t)\n\t\t\t\t&& first !== last\n\t\t\t) {\n\t\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t\t}\n\t\t\tif (part === 'constructor' || !isOwn) {\n\t\t\t\tskipFurtherCaching = true;\n\t\t\t}\n\n\t\t\tintrinsicBaseName += '.' + part;\n\t\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\t\tif (hasOwn$1(INTRINSICS, intrinsicRealName)) {\n\t\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t\t} else if (value != null) {\n\t\t\t\tif (!(part in value)) {\n\t\t\t\t\tif (!allowMissing) {\n\t\t\t\t\t\tthrow new $TypeError$1('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t\t}\n\t\t\t\t\treturn void undefined$1;\n\t\t\t\t}\n\t\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t\t// itself.\n\t\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\t\tvalue = desc.get;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = value[part];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tisOwn = hasOwn$1(value, part);\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\n\t\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t};\n\n\tvar callBind$1 = {exports: {}};\n\n\t(function (module) {\n\n\t\tvar bind = functionBind;\n\t\tvar GetIntrinsic = getIntrinsic;\n\n\t\tvar $apply = GetIntrinsic('%Function.prototype.apply%');\n\t\tvar $call = GetIntrinsic('%Function.prototype.call%');\n\t\tvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\n\t\tvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\t\tvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\t\tvar $max = GetIntrinsic('%Math.max%');\n\n\t\tif ($defineProperty) {\n\t\t\ttry {\n\t\t\t\t$defineProperty({}, 'a', { value: 1 });\n\t\t\t} catch (e) {\n\t\t\t\t// IE 8 has a broken defineProperty\n\t\t\t\t$defineProperty = null;\n\t\t\t}\n\t\t}\n\n\t\tmodule.exports = function callBind(originalFunction) {\n\t\t\tvar func = $reflectApply(bind, $call, arguments);\n\t\t\tif ($gOPD && $defineProperty) {\n\t\t\t\tvar desc = $gOPD(func, 'length');\n\t\t\t\tif (desc.configurable) {\n\t\t\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t\t\t$defineProperty(\n\t\t\t\t\t\tfunc,\n\t\t\t\t\t\t'length',\n\t\t\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn func;\n\t\t};\n\n\t\tvar applyBind = function applyBind() {\n\t\t\treturn $reflectApply(bind, $apply, arguments);\n\t\t};\n\n\t\tif ($defineProperty) {\n\t\t\t$defineProperty(module.exports, 'apply', { value: applyBind });\n\t\t} else {\n\t\t\tmodule.exports.apply = applyBind;\n\t\t}\n\t} (callBind$1));\n\n\tvar GetIntrinsic$1 = getIntrinsic;\n\n\tvar callBind = callBind$1.exports;\n\n\tvar $indexOf = callBind(GetIntrinsic$1('String.prototype.indexOf'));\n\n\tvar callBound$1 = function callBoundIntrinsic(name, allowMissing) {\n\t\tvar intrinsic = GetIntrinsic$1(name, !!allowMissing);\n\t\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\t\treturn callBind(intrinsic);\n\t\t}\n\t\treturn intrinsic;\n\t};\n\n\tvar global$1 = (typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g :\n\t  typeof self !== \"undefined\" ? self :\n\t  typeof window !== \"undefined\" ? window : {});\n\n\tvar lookup = [];\n\tvar revLookup = [];\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\tvar inited = false;\n\tfunction init () {\n\t  inited = true;\n\t  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t  for (var i = 0, len = code.length; i < len; ++i) {\n\t    lookup[i] = code[i];\n\t    revLookup[code.charCodeAt(i)] = i;\n\t  }\n\n\t  revLookup['-'.charCodeAt(0)] = 62;\n\t  revLookup['_'.charCodeAt(0)] = 63;\n\t}\n\n\tfunction toByteArray (b64) {\n\t  if (!inited) {\n\t    init();\n\t  }\n\t  var i, j, l, tmp, placeHolders, arr;\n\t  var len = b64.length;\n\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  arr = new Arr(len * 3 / 4 - placeHolders);\n\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len;\n\n\t  var L = 0;\n\n\t  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n\t    arr[L++] = (tmp >> 16) & 0xFF;\n\t    arr[L++] = (tmp >> 8) & 0xFF;\n\t    arr[L++] = tmp & 0xFF;\n\t  }\n\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n\t    arr[L++] = tmp & 0xFF;\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n\t    arr[L++] = (tmp >> 8) & 0xFF;\n\t    arr[L++] = tmp & 0xFF;\n\t  }\n\n\t  return arr\n\t}\n\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp;\n\t  var output = [];\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t    output.push(tripletToBase64(tmp));\n\t  }\n\t  return output.join('')\n\t}\n\n\tfunction fromByteArray (uint8) {\n\t  if (!inited) {\n\t    init();\n\t  }\n\t  var tmp;\n\t  var len = uint8.length;\n\t  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\t  var output = '';\n\t  var parts = [];\n\t  var maxChunkLength = 16383; // must be multiple of 3\n\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n\t  }\n\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1];\n\t    output += lookup[tmp >> 2];\n\t    output += lookup[(tmp << 4) & 0x3F];\n\t    output += '==';\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n\t    output += lookup[tmp >> 10];\n\t    output += lookup[(tmp >> 4) & 0x3F];\n\t    output += lookup[(tmp << 2) & 0x3F];\n\t    output += '=';\n\t  }\n\n\t  parts.push(output);\n\n\t  return parts.join('')\n\t}\n\n\tfunction read (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m;\n\t  var eLen = nBytes * 8 - mLen - 1;\n\t  var eMax = (1 << eLen) - 1;\n\t  var eBias = eMax >> 1;\n\t  var nBits = -7;\n\t  var i = isLE ? (nBytes - 1) : 0;\n\t  var d = isLE ? -1 : 1;\n\t  var s = buffer[offset + i];\n\n\t  i += d;\n\n\t  e = s & ((1 << (-nBits)) - 1);\n\t  s >>= (-nBits);\n\t  nBits += eLen;\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  m = e & ((1 << (-nBits)) - 1);\n\t  e >>= (-nBits);\n\t  nBits += mLen;\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  if (e === 0) {\n\t    e = 1 - eBias;\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen);\n\t    e = e - eBias;\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\n\tfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c;\n\t  var eLen = nBytes * 8 - mLen - 1;\n\t  var eMax = (1 << eLen) - 1;\n\t  var eBias = eMax >> 1;\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n\t  var i = isLE ? 0 : (nBytes - 1);\n\t  var d = isLE ? 1 : -1;\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n\t  value = Math.abs(value);\n\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0;\n\t    e = eMax;\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2);\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--;\n\t      c *= 2;\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c;\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias);\n\t    }\n\t    if (value * c >= 2) {\n\t      e++;\n\t      c /= 2;\n\t    }\n\n\t    if (e + eBias >= eMax) {\n\t      m = 0;\n\t      e = eMax;\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen);\n\t      e = e + eBias;\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n\t      e = 0;\n\t    }\n\t  }\n\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n\t  e = (e << mLen) | m;\n\t  eLen += mLen;\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n\t  buffer[offset + i - d] |= s * 128;\n\t}\n\n\tvar toString$1 = {}.toString;\n\n\tvar isArray$6 = Array.isArray || function (arr) {\n\t  return toString$1.call(arr) == '[object Array]';\n\t};\n\n\t/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\n\tvar INSPECT_MAX_BYTES = 50;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer$3.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global$1.TYPED_ARRAY_SUPPORT\n\t  : true;\n\n\tfunction kMaxLength () {\n\t  return Buffer$3.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length);\n\t    that.__proto__ = Buffer$3.prototype;\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer$3(length);\n\t    }\n\t    that.length = length;\n\t  }\n\n\t  return that\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer$3 (arg, encodingOrOffset, length) {\n\t  if (!Buffer$3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$3)) {\n\t    return new Buffer$3(arg, encodingOrOffset, length)\n\t  }\n\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe$1(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\n\tBuffer$3.poolSize = 8192; // not used by this implementation\n\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer$3._augment = function (arr) {\n\t  arr.__proto__ = Buffer$3.prototype;\n\t  return arr\n\t};\n\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\n\t  return fromObject(that, value)\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer$3.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t};\n\n\tif (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t  Buffer$3.prototype.__proto__ = Uint8Array.prototype;\n\t  Buffer$3.__proto__ = Uint8Array;\n\t}\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer$3.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe$1 (that, size) {\n\t  assertSize(size);\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\t  if (!Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0;\n\t    }\n\t  }\n\t  return that\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer$3.allocUnsafe = function (size) {\n\t  return allocUnsafe$1(null, size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer$3.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe$1(null, size)\n\t};\n\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer$3.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\n\t  var length = byteLength(string, encoding) | 0;\n\t  that = createBuffer(that, length);\n\n\t  var actual = that.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual);\n\t  }\n\n\t  return that\n\t}\n\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  that = createBuffer(that, length);\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255;\n\t  }\n\t  return that\n\t}\n\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array);\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset);\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length);\n\t  }\n\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array;\n\t    that.__proto__ = Buffer$3.prototype;\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array);\n\t  }\n\t  return that\n\t}\n\n\tfunction fromObject (that, obj) {\n\t  if (internalIsBuffer(obj)) {\n\t    var len = checked(obj.length) | 0;\n\t    that = createBuffer(that, len);\n\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\n\t    obj.copy(that, 0, 0, len);\n\t    return that\n\t  }\n\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\n\t    if (obj.type === 'Buffer' && isArray$6(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\tBuffer$3.isBuffer = isBuffer$3;\n\tfunction internalIsBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\n\tBuffer$3.compare = function compare (a, b) {\n\t  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\n\t  if (a === b) return 0\n\n\t  var x = a.length;\n\t  var y = b.length;\n\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer$3.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer$3.concat = function concat (list, length) {\n\t  if (!isArray$6(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer$3.alloc(0)\n\t  }\n\n\t  var i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  var buffer = Buffer$3.allocUnsafe(length);\n\t  var pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i];\n\t    if (!internalIsBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos);\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (internalIsBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string;\n\t  }\n\n\t  var len = string.length;\n\t  if (len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer$3.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer$3.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  var i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer$3.prototype.swap16 = function swap16 () {\n\t  var len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer$3.prototype.swap32 = function swap32 () {\n\t  var len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer$3.prototype.swap64 = function swap64 () {\n\t  var len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer$3.prototype.toString = function toString () {\n\t  var length = this.length | 0;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer$3.prototype.equals = function equals (b) {\n\t  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer$3.compare(this, b) === 0\n\t};\n\n\tBuffer$3.prototype.inspect = function inspect () {\n\t  var str = '';\n\t  var max = INSPECT_MAX_BYTES;\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n\t    if (this.length > max) str += ' ... ';\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t};\n\n\tBuffer$3.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!internalIsBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  var x = thisEnd - thisStart;\n\t  var y = end - start;\n\t  var len = Math.min(x, y);\n\n\t  var thisCopy = this.slice(thisStart, thisEnd);\n\t  var targetCopy = target.slice(start, end);\n\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000;\n\t  }\n\t  byteOffset = +byteOffset;  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer$3.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (internalIsBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (Buffer$3.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1;\n\t  var arrLength = arr.length;\n\t  var valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  var i;\n\t  if (dir) {\n\t    var foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true;\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer$3.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer$3.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer$3.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  var remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  // must be an even number of digits\n\t  var strLen = string.length;\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer$3.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0;\n\t    if (isFinite(length)) {\n\t      length = length | 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  var remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  var loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer$3.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return fromByteArray(buf)\n\t  } else {\n\t    return fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  var res = [];\n\n\t  var i = start;\n\t  while (i < end) {\n\t    var firstByte = buf[i];\n\t    var codePoint = null;\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = '';\n\t  var i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  var out = '';\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i]);\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end);\n\t  var res = '';\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n\t  }\n\t  return res\n\t}\n\n\tBuffer$3.prototype.slice = function slice (start, end) {\n\t  var len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  var newBuf;\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end);\n\t    newBuf.__proto__ = Buffer$3.prototype;\n\t  } else {\n\t    var sliceLen = end - start;\n\t    newBuf = new Buffer$3(sliceLen, undefined);\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start];\n\t    }\n\t  }\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer$3.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var val = this[offset];\n\t  var mul = 1;\n\t  var i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer$3.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  var val = this[offset + --byteLength];\n\t  var mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer$3.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer$3.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer$3.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer$3.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer$3.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer$3.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var val = this[offset];\n\t  var mul = 1;\n\t  var i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer$3.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var i = byteLength;\n\t  var mul = 1;\n\t  var val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer$3.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer$3.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  var val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer$3.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  var val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer$3.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer$3.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer$3.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer$3.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer$3.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer$3.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer$3.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  var mul = 1;\n\t  var i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer$3.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  var i = byteLength - 1;\n\t  var mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer$3.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  if (!Buffer$3.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1;\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8;\n\t  }\n\t}\n\n\tBuffer$3.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer$3.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8);\n\t    this[offset + 1] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false);\n\t  }\n\t  return offset + 2\n\t};\n\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n\t  }\n\t}\n\n\tBuffer$3.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24);\n\t    this[offset + 2] = (value >>> 16);\n\t    this[offset + 1] = (value >>> 8);\n\t    this[offset] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer$3.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24);\n\t    this[offset + 1] = (value >>> 16);\n\t    this[offset + 2] = (value >>> 8);\n\t    this[offset + 3] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer$3.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  var i = 0;\n\t  var mul = 1;\n\t  var sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer$3.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  var i = byteLength - 1;\n\t  var mul = 1;\n\t  var sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer$3.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n\t  if (!Buffer$3.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer$3.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer$3.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8);\n\t    this[offset + 1] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer$3.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t    this[offset + 2] = (value >>> 16);\n\t    this[offset + 3] = (value >>> 24);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer$3.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  if (Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24);\n\t    this[offset + 1] = (value >>> 16);\n\t    this[offset + 2] = (value >>> 8);\n\t    this[offset + 3] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false);\n\t  }\n\t  return offset + 4\n\t};\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer$3.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer$3.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer$3.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer$3.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer$3.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  var len = end - start;\n\t  var i;\n\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start];\n\t    }\n\t  } else if (len < 1000 || !Buffer$3.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start];\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer$3.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0);\n\t      if (code < 256) {\n\t        val = code;\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer$3.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  var i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    var bytes = internalIsBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer$3(val, encoding).toString());\n\t    var len = bytes.length;\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  var codePoint;\n\t  var length = string.length;\n\t  var leadSurrogate = null;\n\t  var bytes = [];\n\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  var byteArray = [];\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo;\n\t  var byteArray = [];\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\n\tfunction base64ToBytes (str) {\n\t  return toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\n\n\t// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n\t// The _isBuffer check is for Safari 5-7 support, because it's missing\n\t// Object.prototype.constructor. Remove this eventually\n\tfunction isBuffer$3(obj) {\n\t  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n\t}\n\n\tfunction isFastBuffer (obj) {\n\t  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n\t}\n\n\t// For Node v0.10 support. Remove this eventually.\n\tfunction isSlowBuffer (obj) {\n\t  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n\t}\n\n\t// shim for using process in browser\n\t// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\tvar cachedSetTimeout = defaultSetTimout;\n\tvar cachedClearTimeout = defaultClearTimeout;\n\tif (typeof global$1.setTimeout === 'function') {\n\t    cachedSetTimeout = setTimeout;\n\t}\n\tif (typeof global$1.clearTimeout === 'function') {\n\t    cachedClearTimeout = clearTimeout;\n\t}\n\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\n\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\n\n\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\tfunction nextTick(fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t}\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tvar title = 'browser';\n\tvar platform = 'browser';\n\tvar browser = true;\n\tvar env = {};\n\tvar argv = [];\n\tvar version = ''; // empty string to avoid regexp issues\n\tvar versions = {};\n\tvar release = {};\n\tvar config = {};\n\n\tfunction noop$1() {}\n\n\tvar on = noop$1;\n\tvar addListener = noop$1;\n\tvar once = noop$1;\n\tvar off = noop$1;\n\tvar removeListener = noop$1;\n\tvar removeAllListeners = noop$1;\n\tvar emit = noop$1;\n\n\tfunction binding(name) {\n\t    throw new Error('process.binding is not supported');\n\t}\n\n\tfunction cwd () { return '/' }\n\tfunction chdir (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t}function umask() { return 0; }\n\n\t// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\n\tvar performance = global$1.performance || {};\n\tvar performanceNow =\n\t  performance.now        ||\n\t  performance.mozNow     ||\n\t  performance.msNow      ||\n\t  performance.oNow       ||\n\t  performance.webkitNow  ||\n\t  function(){ return (new Date()).getTime() };\n\n\t// generate timestamp or delta\n\t// see http://nodejs.org/api/process.html#process_process_hrtime\n\tfunction hrtime(previousTimestamp){\n\t  var clocktime = performanceNow.call(performance)*1e-3;\n\t  var seconds = Math.floor(clocktime);\n\t  var nanoseconds = Math.floor((clocktime%1)*1e9);\n\t  if (previousTimestamp) {\n\t    seconds = seconds - previousTimestamp[0];\n\t    nanoseconds = nanoseconds - previousTimestamp[1];\n\t    if (nanoseconds<0) {\n\t      seconds--;\n\t      nanoseconds += 1e9;\n\t    }\n\t  }\n\t  return [seconds,nanoseconds]\n\t}\n\n\tvar startTime = new Date();\n\tfunction uptime() {\n\t  var currentTime = new Date();\n\t  var dif = currentTime - startTime;\n\t  return dif / 1000;\n\t}\n\n\tvar browser$1 = {\n\t  nextTick: nextTick,\n\t  title: title,\n\t  browser: browser,\n\t  env: env,\n\t  argv: argv,\n\t  version: version,\n\t  versions: versions,\n\t  on: on,\n\t  addListener: addListener,\n\t  once: once,\n\t  off: off,\n\t  removeListener: removeListener,\n\t  removeAllListeners: removeAllListeners,\n\t  emit: emit,\n\t  binding: binding,\n\t  cwd: cwd,\n\t  chdir: chdir,\n\t  umask: umask,\n\t  hrtime: hrtime,\n\t  platform: platform,\n\t  release: release,\n\t  config: config,\n\t  uptime: uptime\n\t};\n\n\tvar inherits;\n\tif (typeof Object.create === 'function'){\n\t  inherits = function inherits(ctor, superCtor) {\n\t    // implementation from standard node.js 'util' module\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  inherits = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  };\n\t}\n\tvar inherits$1 = inherits;\n\n\tvar formatRegExp = /%[sdj%]/g;\n\tfunction format(f) {\n\t  if (!isString$1(f)) {\n\t    var objects = [];\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      objects.push(inspect$1(arguments[i]));\n\t    }\n\t    return objects.join(' ');\n\t  }\n\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function(x) {\n\t    if (x === '%%') return '%';\n\t    if (i >= len) return x;\n\t    switch (x) {\n\t      case '%s': return String(args[i++]);\n\t      case '%d': return Number(args[i++]);\n\t      case '%j':\n\t        try {\n\t          return JSON.stringify(args[i++]);\n\t        } catch (_) {\n\t          return '[Circular]';\n\t        }\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  for (var x = args[i]; i < len; x = args[++i]) {\n\t    if (isNull(x) || !isObject$2(x)) {\n\t      str += ' ' + x;\n\t    } else {\n\t      str += ' ' + inspect$1(x);\n\t    }\n\t  }\n\t  return str;\n\t}\n\n\t// Mark that a method should not be used.\n\t// Returns a modified function which warns once by default.\n\t// If --no-deprecation is set, then it is a no-op.\n\tfunction deprecate(fn, msg) {\n\t  // Allow for deprecating things in the process of starting up.\n\t  if (isUndefined(global$1.process)) {\n\t    return function() {\n\t      return deprecate(fn, msg).apply(this, arguments);\n\t    };\n\t  }\n\n\t  if (browser$1.noDeprecation === true) {\n\t    return fn;\n\t  }\n\n\t  var warned = false;\n\t  function deprecated() {\n\t    if (!warned) {\n\t      if (browser$1.throwDeprecation) {\n\t        throw new Error(msg);\n\t      } else if (browser$1.traceDeprecation) {\n\t        console.trace(msg);\n\t      } else {\n\t        console.error(msg);\n\t      }\n\t      warned = true;\n\t    }\n\t    return fn.apply(this, arguments);\n\t  }\n\n\t  return deprecated;\n\t}\n\n\tvar debugs = {};\n\tvar debugEnviron;\n\tfunction debuglog(set) {\n\t  if (isUndefined(debugEnviron))\n\t    debugEnviron = browser$1.env.NODE_DEBUG || '';\n\t  set = set.toUpperCase();\n\t  if (!debugs[set]) {\n\t    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n\t      var pid = 0;\n\t      debugs[set] = function() {\n\t        var msg = format.apply(null, arguments);\n\t        console.error('%s %d: %s', set, pid, msg);\n\t      };\n\t    } else {\n\t      debugs[set] = function() {};\n\t    }\n\t  }\n\t  return debugs[set];\n\t}\n\n\t/**\n\t * Echos the value of a value. Trys to print the value out\n\t * in the best way possible given the different types.\n\t *\n\t * @param {Object} obj The object to print out.\n\t * @param {Object} opts Optional options object that alters the output.\n\t */\n\t/* legacy: obj, showHidden, depth, colors*/\n\tfunction inspect$1(obj, opts) {\n\t  // default options\n\t  var ctx = {\n\t    seen: [],\n\t    stylize: stylizeNoColor\n\t  };\n\t  // legacy...\n\t  if (arguments.length >= 3) ctx.depth = arguments[2];\n\t  if (arguments.length >= 4) ctx.colors = arguments[3];\n\t  if (isBoolean$1(opts)) {\n\t    // legacy...\n\t    ctx.showHidden = opts;\n\t  } else if (opts) {\n\t    // got an \"options\" object\n\t    _extend(ctx, opts);\n\t  }\n\t  // set default options\n\t  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n\t  if (isUndefined(ctx.depth)) ctx.depth = 2;\n\t  if (isUndefined(ctx.colors)) ctx.colors = false;\n\t  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n\t  if (ctx.colors) ctx.stylize = stylizeWithColor;\n\t  return formatValue(ctx, obj, ctx.depth);\n\t}\n\n\t// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\tinspect$1.colors = {\n\t  'bold' : [1, 22],\n\t  'italic' : [3, 23],\n\t  'underline' : [4, 24],\n\t  'inverse' : [7, 27],\n\t  'white' : [37, 39],\n\t  'grey' : [90, 39],\n\t  'black' : [30, 39],\n\t  'blue' : [34, 39],\n\t  'cyan' : [36, 39],\n\t  'green' : [32, 39],\n\t  'magenta' : [35, 39],\n\t  'red' : [31, 39],\n\t  'yellow' : [33, 39]\n\t};\n\n\t// Don't use 'blue' not visible on cmd.exe\n\tinspect$1.styles = {\n\t  'special': 'cyan',\n\t  'number': 'yellow',\n\t  'boolean': 'yellow',\n\t  'undefined': 'grey',\n\t  'null': 'bold',\n\t  'string': 'green',\n\t  'date': 'magenta',\n\t  // \"name\": intentionally not styling\n\t  'regexp': 'red'\n\t};\n\n\n\tfunction stylizeWithColor(str, styleType) {\n\t  var style = inspect$1.styles[styleType];\n\n\t  if (style) {\n\t    return '\\u001b[' + inspect$1.colors[style][0] + 'm' + str +\n\t           '\\u001b[' + inspect$1.colors[style][1] + 'm';\n\t  } else {\n\t    return str;\n\t  }\n\t}\n\n\n\tfunction stylizeNoColor(str, styleType) {\n\t  return str;\n\t}\n\n\n\tfunction arrayToHash(array) {\n\t  var hash = {};\n\n\t  array.forEach(function(val, idx) {\n\t    hash[val] = true;\n\t  });\n\n\t  return hash;\n\t}\n\n\n\tfunction formatValue(ctx, value, recurseTimes) {\n\t  // Provide a hook for user-specified inspect functions.\n\t  // Check that value is an object with an inspect function on it\n\t  if (ctx.customInspect &&\n\t      value &&\n\t      isFunction$2(value.inspect) &&\n\t      // Filter out the util module, it's inspect function is special\n\t      value.inspect !== inspect$1 &&\n\t      // Also filter out any prototype objects using the circular check.\n\t      !(value.constructor && value.constructor.prototype === value)) {\n\t    var ret = value.inspect(recurseTimes, ctx);\n\t    if (!isString$1(ret)) {\n\t      ret = formatValue(ctx, ret, recurseTimes);\n\t    }\n\t    return ret;\n\t  }\n\n\t  // Primitive types cannot have properties\n\t  var primitive = formatPrimitive(ctx, value);\n\t  if (primitive) {\n\t    return primitive;\n\t  }\n\n\t  // Look up the keys of the object.\n\t  var keys = Object.keys(value);\n\t  var visibleKeys = arrayToHash(keys);\n\n\t  if (ctx.showHidden) {\n\t    keys = Object.getOwnPropertyNames(value);\n\t  }\n\n\t  // IE doesn't make error fields non-enumerable\n\t  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\t  if (isError$1(value)\n\t      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n\t    return formatError(value);\n\t  }\n\n\t  // Some type of object without properties can be shortcutted.\n\t  if (keys.length === 0) {\n\t    if (isFunction$2(value)) {\n\t      var name = value.name ? ': ' + value.name : '';\n\t      return ctx.stylize('[Function' + name + ']', 'special');\n\t    }\n\t    if (isRegExp$2(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    }\n\t    if (isDate$1(value)) {\n\t      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n\t    }\n\t    if (isError$1(value)) {\n\t      return formatError(value);\n\t    }\n\t  }\n\n\t  var base = '', array = false, braces = ['{', '}'];\n\n\t  // Make Array say that they are Array\n\t  if (isArray$5(value)) {\n\t    array = true;\n\t    braces = ['[', ']'];\n\t  }\n\n\t  // Make functions say that they are functions\n\t  if (isFunction$2(value)) {\n\t    var n = value.name ? ': ' + value.name : '';\n\t    base = ' [Function' + n + ']';\n\t  }\n\n\t  // Make RegExps say that they are RegExps\n\t  if (isRegExp$2(value)) {\n\t    base = ' ' + RegExp.prototype.toString.call(value);\n\t  }\n\n\t  // Make dates with properties first say the date\n\t  if (isDate$1(value)) {\n\t    base = ' ' + Date.prototype.toUTCString.call(value);\n\t  }\n\n\t  // Make error with message first say the error\n\t  if (isError$1(value)) {\n\t    base = ' ' + formatError(value);\n\t  }\n\n\t  if (keys.length === 0 && (!array || value.length == 0)) {\n\t    return braces[0] + base + braces[1];\n\t  }\n\n\t  if (recurseTimes < 0) {\n\t    if (isRegExp$2(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    } else {\n\t      return ctx.stylize('[Object]', 'special');\n\t    }\n\t  }\n\n\t  ctx.seen.push(value);\n\n\t  var output;\n\t  if (array) {\n\t    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n\t  } else {\n\t    output = keys.map(function(key) {\n\t      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n\t    });\n\t  }\n\n\t  ctx.seen.pop();\n\n\t  return reduceToSingleString(output, base, braces);\n\t}\n\n\n\tfunction formatPrimitive(ctx, value) {\n\t  if (isUndefined(value))\n\t    return ctx.stylize('undefined', 'undefined');\n\t  if (isString$1(value)) {\n\t    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n\t                                             .replace(/'/g, \"\\\\'\")\n\t                                             .replace(/\\\\\"/g, '\"') + '\\'';\n\t    return ctx.stylize(simple, 'string');\n\t  }\n\t  if (isNumber$1(value))\n\t    return ctx.stylize('' + value, 'number');\n\t  if (isBoolean$1(value))\n\t    return ctx.stylize('' + value, 'boolean');\n\t  // For some reason typeof null is \"object\", so special case here.\n\t  if (isNull(value))\n\t    return ctx.stylize('null', 'null');\n\t}\n\n\n\tfunction formatError(value) {\n\t  return '[' + Error.prototype.toString.call(value) + ']';\n\t}\n\n\n\tfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n\t  var output = [];\n\t  for (var i = 0, l = value.length; i < l; ++i) {\n\t    if (hasOwnProperty$d(value, String(i))) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          String(i), true));\n\t    } else {\n\t      output.push('');\n\t    }\n\t  }\n\t  keys.forEach(function(key) {\n\t    if (!key.match(/^\\d+$/)) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          key, true));\n\t    }\n\t  });\n\t  return output;\n\t}\n\n\n\tfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n\t  var name, str, desc;\n\t  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n\t  if (desc.get) {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Getter/Setter]', 'special');\n\t    } else {\n\t      str = ctx.stylize('[Getter]', 'special');\n\t    }\n\t  } else {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Setter]', 'special');\n\t    }\n\t  }\n\t  if (!hasOwnProperty$d(visibleKeys, key)) {\n\t    name = '[' + key + ']';\n\t  }\n\t  if (!str) {\n\t    if (ctx.seen.indexOf(desc.value) < 0) {\n\t      if (isNull(recurseTimes)) {\n\t        str = formatValue(ctx, desc.value, null);\n\t      } else {\n\t        str = formatValue(ctx, desc.value, recurseTimes - 1);\n\t      }\n\t      if (str.indexOf('\\n') > -1) {\n\t        if (array) {\n\t          str = str.split('\\n').map(function(line) {\n\t            return '  ' + line;\n\t          }).join('\\n').substr(2);\n\t        } else {\n\t          str = '\\n' + str.split('\\n').map(function(line) {\n\t            return '   ' + line;\n\t          }).join('\\n');\n\t        }\n\t      }\n\t    } else {\n\t      str = ctx.stylize('[Circular]', 'special');\n\t    }\n\t  }\n\t  if (isUndefined(name)) {\n\t    if (array && key.match(/^\\d+$/)) {\n\t      return str;\n\t    }\n\t    name = JSON.stringify('' + key);\n\t    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n\t      name = name.substr(1, name.length - 2);\n\t      name = ctx.stylize(name, 'name');\n\t    } else {\n\t      name = name.replace(/'/g, \"\\\\'\")\n\t                 .replace(/\\\\\"/g, '\"')\n\t                 .replace(/(^\"|\"$)/g, \"'\");\n\t      name = ctx.stylize(name, 'string');\n\t    }\n\t  }\n\n\t  return name + ': ' + str;\n\t}\n\n\n\tfunction reduceToSingleString(output, base, braces) {\n\t  var length = output.reduce(function(prev, cur) {\n\t    if (cur.indexOf('\\n') >= 0) ;\n\t    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n\t  }, 0);\n\n\t  if (length > 60) {\n\t    return braces[0] +\n\t           (base === '' ? '' : base + '\\n ') +\n\t           ' ' +\n\t           output.join(',\\n  ') +\n\t           ' ' +\n\t           braces[1];\n\t  }\n\n\t  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n\t}\n\n\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\tfunction isArray$5(ar) {\n\t  return Array.isArray(ar);\n\t}\n\n\tfunction isBoolean$1(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\n\tfunction isNumber$1(arg) {\n\t  return typeof arg === 'number';\n\t}\n\n\tfunction isString$1(arg) {\n\t  return typeof arg === 'string';\n\t}\n\n\tfunction isSymbol$2(arg) {\n\t  return typeof arg === 'symbol';\n\t}\n\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\tfunction isRegExp$2(re) {\n\t  return isObject$2(re) && objectToString$2(re) === '[object RegExp]';\n\t}\n\n\tfunction isObject$2(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\n\tfunction isDate$1(d) {\n\t  return isObject$2(d) && objectToString$2(d) === '[object Date]';\n\t}\n\n\tfunction isError$1(e) {\n\t  return isObject$2(e) &&\n\t      (objectToString$2(e) === '[object Error]' || e instanceof Error);\n\t}\n\n\tfunction isFunction$2(arg) {\n\t  return typeof arg === 'function';\n\t}\n\n\tfunction isPrimitive(arg) {\n\t  return arg === null ||\n\t         typeof arg === 'boolean' ||\n\t         typeof arg === 'number' ||\n\t         typeof arg === 'string' ||\n\t         typeof arg === 'symbol' ||  // ES6 symbol\n\t         typeof arg === 'undefined';\n\t}\n\n\tfunction isBuffer$2(maybeBuf) {\n\t  return Buffer$3.isBuffer(maybeBuf);\n\t}\n\n\tfunction objectToString$2(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\n\n\tfunction pad(n) {\n\t  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n\t}\n\n\n\tvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n\t              'Oct', 'Nov', 'Dec'];\n\n\t// 26 Feb 16:19:34\n\tfunction timestamp() {\n\t  var d = new Date();\n\t  var time = [pad(d.getHours()),\n\t              pad(d.getMinutes()),\n\t              pad(d.getSeconds())].join(':');\n\t  return [d.getDate(), months[d.getMonth()], time].join(' ');\n\t}\n\n\n\t// log is just a thin wrapper to console.log that prepends a timestamp\n\tfunction log() {\n\t  console.log('%s - %s', timestamp(), format.apply(null, arguments));\n\t}\n\n\tfunction _extend(origin, add) {\n\t  // Don't do anything if add isn't an object\n\t  if (!add || !isObject$2(add)) return origin;\n\n\t  var keys = Object.keys(add);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    origin[keys[i]] = add[keys[i]];\n\t  }\n\t  return origin;\n\t}\n\tfunction hasOwnProperty$d(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\n\tvar _polyfillNode_util = {\n\t  inherits: inherits$1,\n\t  _extend: _extend,\n\t  log: log,\n\t  isBuffer: isBuffer$2,\n\t  isPrimitive: isPrimitive,\n\t  isFunction: isFunction$2,\n\t  isError: isError$1,\n\t  isDate: isDate$1,\n\t  isObject: isObject$2,\n\t  isRegExp: isRegExp$2,\n\t  isUndefined: isUndefined,\n\t  isSymbol: isSymbol$2,\n\t  isString: isString$1,\n\t  isNumber: isNumber$1,\n\t  isNullOrUndefined: isNullOrUndefined,\n\t  isNull: isNull,\n\t  isBoolean: isBoolean$1,\n\t  isArray: isArray$5,\n\t  inspect: inspect$1,\n\t  deprecate: deprecate,\n\t  format: format,\n\t  debuglog: debuglog\n\t};\n\n\tvar _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tformat: format,\n\t\tdeprecate: deprecate,\n\t\tdebuglog: debuglog,\n\t\tinspect: inspect$1,\n\t\tisArray: isArray$5,\n\t\tisBoolean: isBoolean$1,\n\t\tisNull: isNull,\n\t\tisNullOrUndefined: isNullOrUndefined,\n\t\tisNumber: isNumber$1,\n\t\tisString: isString$1,\n\t\tisSymbol: isSymbol$2,\n\t\tisUndefined: isUndefined,\n\t\tisRegExp: isRegExp$2,\n\t\tisObject: isObject$2,\n\t\tisDate: isDate$1,\n\t\tisError: isError$1,\n\t\tisFunction: isFunction$2,\n\t\tisPrimitive: isPrimitive,\n\t\tisBuffer: isBuffer$2,\n\t\tlog: log,\n\t\tinherits: inherits$1,\n\t\t_extend: _extend,\n\t\t'default': _polyfillNode_util\n\t});\n\n\tvar require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);\n\n\tvar util_inspect = require$$0.inspect;\n\n\tvar hasMap = typeof Map === 'function' && Map.prototype;\n\tvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\n\tvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\n\tvar mapForEach = hasMap && Map.prototype.forEach;\n\tvar hasSet = typeof Set === 'function' && Set.prototype;\n\tvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\n\tvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\n\tvar setForEach = hasSet && Set.prototype.forEach;\n\tvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\n\tvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\n\tvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\n\tvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\n\tvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\n\tvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\n\tvar booleanValueOf = Boolean.prototype.valueOf;\n\tvar objectToString$1 = Object.prototype.toString;\n\tvar functionToString = Function.prototype.toString;\n\tvar match = String.prototype.match;\n\tvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\n\tvar gOPS = Object.getOwnPropertySymbols;\n\tvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\n\tvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\n\tvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n\t    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n\t        ? function (O) {\n\t            return O.__proto__; // eslint-disable-line no-proto\n\t        }\n\t        : null\n\t);\n\n\tvar inspectCustom = util_inspect.custom;\n\tvar inspectSymbol = inspectCustom && isSymbol$1(inspectCustom) ? inspectCustom : null;\n\tvar toStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag !== 'undefined' ? Symbol.toStringTag : null;\n\n\tvar objectInspect = function inspect_(obj, options, depth, seen) {\n\t    var opts = options || {};\n\n\t    if (has$3(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {\n\t        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n\t    }\n\t    if (\n\t        has$3(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n\t            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n\t            : opts.maxStringLength !== null\n\t        )\n\t    ) {\n\t        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n\t    }\n\t    var customInspect = has$3(opts, 'customInspect') ? opts.customInspect : true;\n\t    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n\t        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n\t    }\n\n\t    if (\n\t        has$3(opts, 'indent')\n\t        && opts.indent !== null\n\t        && opts.indent !== '\\t'\n\t        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n\t    ) {\n\t        throw new TypeError('options \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n\t    }\n\n\t    if (typeof obj === 'undefined') {\n\t        return 'undefined';\n\t    }\n\t    if (obj === null) {\n\t        return 'null';\n\t    }\n\t    if (typeof obj === 'boolean') {\n\t        return obj ? 'true' : 'false';\n\t    }\n\n\t    if (typeof obj === 'string') {\n\t        return inspectString(obj, opts);\n\t    }\n\t    if (typeof obj === 'number') {\n\t        if (obj === 0) {\n\t            return Infinity / obj > 0 ? '0' : '-0';\n\t        }\n\t        return String(obj);\n\t    }\n\t    if (typeof obj === 'bigint') {\n\t        return String(obj) + 'n';\n\t    }\n\n\t    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n\t    if (typeof depth === 'undefined') { depth = 0; }\n\t    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n\t        return isArray$4(obj) ? '[Array]' : '[Object]';\n\t    }\n\n\t    var indent = getIndent(opts, depth);\n\n\t    if (typeof seen === 'undefined') {\n\t        seen = [];\n\t    } else if (indexOf(seen, obj) >= 0) {\n\t        return '[Circular]';\n\t    }\n\n\t    function inspect(value, from, noIndent) {\n\t        if (from) {\n\t            seen = seen.slice();\n\t            seen.push(from);\n\t        }\n\t        if (noIndent) {\n\t            var newOpts = {\n\t                depth: opts.depth\n\t            };\n\t            if (has$3(opts, 'quoteStyle')) {\n\t                newOpts.quoteStyle = opts.quoteStyle;\n\t            }\n\t            return inspect_(value, newOpts, depth + 1, seen);\n\t        }\n\t        return inspect_(value, opts, depth + 1, seen);\n\t    }\n\n\t    if (typeof obj === 'function') {\n\t        var name = nameOf(obj);\n\t        var keys = arrObjKeys(obj, inspect);\n\t        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + keys.join(', ') + ' }' : '');\n\t    }\n\t    if (isSymbol$1(obj)) {\n\t        var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n\t        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n\t    }\n\t    if (isElement(obj)) {\n\t        var s = '<' + String(obj.nodeName).toLowerCase();\n\t        var attrs = obj.attributes || [];\n\t        for (var i = 0; i < attrs.length; i++) {\n\t            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n\t        }\n\t        s += '>';\n\t        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n\t        s += '</' + String(obj.nodeName).toLowerCase() + '>';\n\t        return s;\n\t    }\n\t    if (isArray$4(obj)) {\n\t        if (obj.length === 0) { return '[]'; }\n\t        var xs = arrObjKeys(obj, inspect);\n\t        if (indent && !singleLineValues(xs)) {\n\t            return '[' + indentedJoin(xs, indent) + ']';\n\t        }\n\t        return '[ ' + xs.join(', ') + ' ]';\n\t    }\n\t    if (isError(obj)) {\n\t        var parts = arrObjKeys(obj, inspect);\n\t        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n\t        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';\n\t    }\n\t    if (typeof obj === 'object' && customInspect) {\n\t        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {\n\t            return obj[inspectSymbol]();\n\t        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n\t            return obj.inspect();\n\t        }\n\t    }\n\t    if (isMap$1(obj)) {\n\t        var mapParts = [];\n\t        mapForEach.call(obj, function (value, key) {\n\t            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n\t        });\n\t        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n\t    }\n\t    if (isSet$1(obj)) {\n\t        var setParts = [];\n\t        setForEach.call(obj, function (value) {\n\t            setParts.push(inspect(value, obj));\n\t        });\n\t        return collectionOf('Set', setSize.call(obj), setParts, indent);\n\t    }\n\t    if (isWeakMap(obj)) {\n\t        return weakCollectionOf('WeakMap');\n\t    }\n\t    if (isWeakSet(obj)) {\n\t        return weakCollectionOf('WeakSet');\n\t    }\n\t    if (isWeakRef(obj)) {\n\t        return weakCollectionOf('WeakRef');\n\t    }\n\t    if (isNumber(obj)) {\n\t        return markBoxed(inspect(Number(obj)));\n\t    }\n\t    if (isBigInt(obj)) {\n\t        return markBoxed(inspect(bigIntValueOf.call(obj)));\n\t    }\n\t    if (isBoolean(obj)) {\n\t        return markBoxed(booleanValueOf.call(obj));\n\t    }\n\t    if (isString(obj)) {\n\t        return markBoxed(inspect(String(obj)));\n\t    }\n\t    if (!isDate(obj) && !isRegExp$1(obj)) {\n\t        var ys = arrObjKeys(obj, inspect);\n\t        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n\t        var protoTag = obj instanceof Object ? '' : 'null prototype';\n\t        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? 'Object' : '';\n\t        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n\t        var tag = constructorTag + (stringTag || protoTag ? '[' + [].concat(stringTag || [], protoTag || []).join(': ') + '] ' : '');\n\t        if (ys.length === 0) { return tag + '{}'; }\n\t        if (indent) {\n\t            return tag + '{' + indentedJoin(ys, indent) + '}';\n\t        }\n\t        return tag + '{ ' + ys.join(', ') + ' }';\n\t    }\n\t    return String(obj);\n\t};\n\n\tfunction wrapQuotes(s, defaultStyle, opts) {\n\t    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '\"' : \"'\";\n\t    return quoteChar + s + quoteChar;\n\t}\n\n\tfunction quote(s) {\n\t    return String(s).replace(/\"/g, '&quot;');\n\t}\n\n\tfunction isArray$4(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\tfunction isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\tfunction isRegExp$1(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\tfunction isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\tfunction isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\tfunction isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\tfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\n\n\t// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\n\tfunction isSymbol$1(obj) {\n\t    if (hasShammedSymbols) {\n\t        return obj && typeof obj === 'object' && obj instanceof Symbol;\n\t    }\n\t    if (typeof obj === 'symbol') {\n\t        return true;\n\t    }\n\t    if (!obj || typeof obj !== 'object' || !symToString) {\n\t        return false;\n\t    }\n\t    try {\n\t        symToString.call(obj);\n\t        return true;\n\t    } catch (e) {}\n\t    return false;\n\t}\n\n\tfunction isBigInt(obj) {\n\t    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n\t        return false;\n\t    }\n\t    try {\n\t        bigIntValueOf.call(obj);\n\t        return true;\n\t    } catch (e) {}\n\t    return false;\n\t}\n\n\tvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\n\tfunction has$3(obj, key) {\n\t    return hasOwn.call(obj, key);\n\t}\n\n\tfunction toStr(obj) {\n\t    return objectToString$1.call(obj);\n\t}\n\n\tfunction nameOf(f) {\n\t    if (f.name) { return f.name; }\n\t    var m = match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n\t    if (m) { return m[1]; }\n\t    return null;\n\t}\n\n\tfunction indexOf(xs, x) {\n\t    if (xs.indexOf) { return xs.indexOf(x); }\n\t    for (var i = 0, l = xs.length; i < l; i++) {\n\t        if (xs[i] === x) { return i; }\n\t    }\n\t    return -1;\n\t}\n\n\tfunction isMap$1(x) {\n\t    if (!mapSize || !x || typeof x !== 'object') {\n\t        return false;\n\t    }\n\t    try {\n\t        mapSize.call(x);\n\t        try {\n\t            setSize.call(x);\n\t        } catch (s) {\n\t            return true;\n\t        }\n\t        return x instanceof Map; // core-js workaround, pre-v2.5.0\n\t    } catch (e) {}\n\t    return false;\n\t}\n\n\tfunction isWeakMap(x) {\n\t    if (!weakMapHas || !x || typeof x !== 'object') {\n\t        return false;\n\t    }\n\t    try {\n\t        weakMapHas.call(x, weakMapHas);\n\t        try {\n\t            weakSetHas.call(x, weakSetHas);\n\t        } catch (s) {\n\t            return true;\n\t        }\n\t        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n\t    } catch (e) {}\n\t    return false;\n\t}\n\n\tfunction isWeakRef(x) {\n\t    if (!weakRefDeref || !x || typeof x !== 'object') {\n\t        return false;\n\t    }\n\t    try {\n\t        weakRefDeref.call(x);\n\t        return true;\n\t    } catch (e) {}\n\t    return false;\n\t}\n\n\tfunction isSet$1(x) {\n\t    if (!setSize || !x || typeof x !== 'object') {\n\t        return false;\n\t    }\n\t    try {\n\t        setSize.call(x);\n\t        try {\n\t            mapSize.call(x);\n\t        } catch (m) {\n\t            return true;\n\t        }\n\t        return x instanceof Set; // core-js workaround, pre-v2.5.0\n\t    } catch (e) {}\n\t    return false;\n\t}\n\n\tfunction isWeakSet(x) {\n\t    if (!weakSetHas || !x || typeof x !== 'object') {\n\t        return false;\n\t    }\n\t    try {\n\t        weakSetHas.call(x, weakSetHas);\n\t        try {\n\t            weakMapHas.call(x, weakMapHas);\n\t        } catch (s) {\n\t            return true;\n\t        }\n\t        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n\t    } catch (e) {}\n\t    return false;\n\t}\n\n\tfunction isElement(x) {\n\t    if (!x || typeof x !== 'object') { return false; }\n\t    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n\t        return true;\n\t    }\n\t    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n\t}\n\n\tfunction inspectString(str, opts) {\n\t    if (str.length > opts.maxStringLength) {\n\t        var remaining = str.length - opts.maxStringLength;\n\t        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n\t        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;\n\t    }\n\t    // eslint-disable-next-line no-control-regex\n\t    var s = str.replace(/(['\\\\])/g, '\\\\$1').replace(/[\\x00-\\x1f]/g, lowbyte);\n\t    return wrapQuotes(s, 'single', opts);\n\t}\n\n\tfunction lowbyte(c) {\n\t    var n = c.charCodeAt(0);\n\t    var x = {\n\t        8: 'b',\n\t        9: 't',\n\t        10: 'n',\n\t        12: 'f',\n\t        13: 'r'\n\t    }[n];\n\t    if (x) { return '\\\\' + x; }\n\t    return '\\\\x' + (n < 0x10 ? '0' : '') + n.toString(16).toUpperCase();\n\t}\n\n\tfunction markBoxed(str) {\n\t    return 'Object(' + str + ')';\n\t}\n\n\tfunction weakCollectionOf(type) {\n\t    return type + ' { ? }';\n\t}\n\n\tfunction collectionOf(type, size, entries, indent) {\n\t    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');\n\t    return type + ' (' + size + ') {' + joinedEntries + '}';\n\t}\n\n\tfunction singleLineValues(xs) {\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (indexOf(xs[i], '\\n') >= 0) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\n\tfunction getIndent(opts, depth) {\n\t    var baseIndent;\n\t    if (opts.indent === '\\t') {\n\t        baseIndent = '\\t';\n\t    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n\t        baseIndent = Array(opts.indent + 1).join(' ');\n\t    } else {\n\t        return null;\n\t    }\n\t    return {\n\t        base: baseIndent,\n\t        prev: Array(depth + 1).join(baseIndent)\n\t    };\n\t}\n\n\tfunction indentedJoin(xs, indent) {\n\t    if (xs.length === 0) { return ''; }\n\t    var lineJoiner = '\\n' + indent.prev + indent.base;\n\t    return lineJoiner + xs.join(',' + lineJoiner) + '\\n' + indent.prev;\n\t}\n\n\tfunction arrObjKeys(obj, inspect) {\n\t    var isArr = isArray$4(obj);\n\t    var xs = [];\n\t    if (isArr) {\n\t        xs.length = obj.length;\n\t        for (var i = 0; i < obj.length; i++) {\n\t            xs[i] = has$3(obj, i) ? inspect(obj[i], obj) : '';\n\t        }\n\t    }\n\t    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n\t    var symMap;\n\t    if (hasShammedSymbols) {\n\t        symMap = {};\n\t        for (var k = 0; k < syms.length; k++) {\n\t            symMap['$' + syms[k]] = syms[k];\n\t        }\n\t    }\n\n\t    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n\t        if (!has$3(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n\t        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n\t        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n\t            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n\t            continue; // eslint-disable-line no-restricted-syntax, no-continue\n\t        } else if ((/[^\\w$]/).test(key)) {\n\t            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n\t        } else {\n\t            xs.push(key + ': ' + inspect(obj[key], obj));\n\t        }\n\t    }\n\t    if (typeof gOPS === 'function') {\n\t        for (var j = 0; j < syms.length; j++) {\n\t            if (isEnumerable.call(obj, syms[j])) {\n\t                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n\t            }\n\t        }\n\t    }\n\t    return xs;\n\t}\n\n\tvar GetIntrinsic = getIntrinsic;\n\tvar callBound = callBound$1;\n\tvar inspect = objectInspect;\n\n\tvar $TypeError = GetIntrinsic('%TypeError%');\n\tvar $WeakMap = GetIntrinsic('%WeakMap%', true);\n\tvar $Map = GetIntrinsic('%Map%', true);\n\n\tvar $weakMapGet = callBound('WeakMap.prototype.get', true);\n\tvar $weakMapSet = callBound('WeakMap.prototype.set', true);\n\tvar $weakMapHas = callBound('WeakMap.prototype.has', true);\n\tvar $mapGet = callBound('Map.prototype.get', true);\n\tvar $mapSet = callBound('Map.prototype.set', true);\n\tvar $mapHas = callBound('Map.prototype.has', true);\n\n\t/*\n\t * This function traverses the list returning the node corresponding to the\n\t * given key.\n\t *\n\t * That node is also moved to the head of the list, so that if it's accessed\n\t * again we don't need to traverse the whole list. By doing so, all the recently\n\t * used nodes can be accessed relatively quickly.\n\t */\n\tvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\n\t\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n\t\t\tif (curr.key === key) {\n\t\t\t\tprev.next = curr.next;\n\t\t\t\tcurr.next = list.next;\n\t\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\t\treturn curr;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar listGet = function (objects, key) {\n\t\tvar node = listGetNode(objects, key);\n\t\treturn node && node.value;\n\t};\n\tvar listSet = function (objects, key, value) {\n\t\tvar node = listGetNode(objects, key);\n\t\tif (node) {\n\t\t\tnode.value = value;\n\t\t} else {\n\t\t\t// Prepend the new node to the beginning of the list\n\t\t\tobjects.next = { // eslint-disable-line no-param-reassign\n\t\t\t\tkey: key,\n\t\t\t\tnext: objects.next,\n\t\t\t\tvalue: value\n\t\t\t};\n\t\t}\n\t};\n\tvar listHas = function (objects, key) {\n\t\treturn !!listGetNode(objects, key);\n\t};\n\n\tvar sideChannel = function getSideChannel() {\n\t\tvar $wm;\n\t\tvar $m;\n\t\tvar $o;\n\t\tvar channel = {\n\t\t\tassert: function (key) {\n\t\t\t\tif (!channel.has(key)) {\n\t\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t\t}\n\t\t\t},\n\t\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t\t}\n\t\t\t\t} else if ($Map) {\n\t\t\t\t\tif ($m) {\n\t\t\t\t\t\treturn $mapGet($m, key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\t\treturn listGet($o, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\thas: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t\t}\n\t\t\t\t} else if ($Map) {\n\t\t\t\t\tif ($m) {\n\t\t\t\t\t\treturn $mapHas($m, key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\t\treturn listHas($o, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function (key, value) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif (!$wm) {\n\t\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t\t}\n\t\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t\t} else if ($Map) {\n\t\t\t\t\tif (!$m) {\n\t\t\t\t\t\t$m = new $Map();\n\t\t\t\t\t}\n\t\t\t\t\t$mapSet($m, key, value);\n\t\t\t\t} else {\n\t\t\t\t\tif (!$o) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\n\t\t\t\t\t\t * to special-case handling of the first node: we can always refer to\n\t\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\n\t\t\t\t\t\t */\n\t\t\t\t\t\t$o = { key: {}, next: null };\n\t\t\t\t\t}\n\t\t\t\t\tlistSet($o, key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn channel;\n\t};\n\n\tvar replace = String.prototype.replace;\n\tvar percentTwenties = /%20/g;\n\n\tvar Format = {\n\t    RFC1738: 'RFC1738',\n\t    RFC3986: 'RFC3986'\n\t};\n\n\tvar formats$3 = {\n\t    'default': Format.RFC3986,\n\t    formatters: {\n\t        RFC1738: function (value) {\n\t            return replace.call(value, percentTwenties, '+');\n\t        },\n\t        RFC3986: function (value) {\n\t            return String(value);\n\t        }\n\t    },\n\t    RFC1738: Format.RFC1738,\n\t    RFC3986: Format.RFC3986\n\t};\n\n\tvar formats$2 = formats$3;\n\n\tvar has$2 = Object.prototype.hasOwnProperty;\n\tvar isArray$3 = Array.isArray;\n\n\tvar hexTable = (function () {\n\t    var array = [];\n\t    for (var i = 0; i < 256; ++i) {\n\t        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n\t    }\n\n\t    return array;\n\t}());\n\n\tvar compactQueue = function compactQueue(queue) {\n\t    while (queue.length > 1) {\n\t        var item = queue.pop();\n\t        var obj = item.obj[item.prop];\n\n\t        if (isArray$3(obj)) {\n\t            var compacted = [];\n\n\t            for (var j = 0; j < obj.length; ++j) {\n\t                if (typeof obj[j] !== 'undefined') {\n\t                    compacted.push(obj[j]);\n\t                }\n\t            }\n\n\t            item.obj[item.prop] = compacted;\n\t        }\n\t    }\n\t};\n\n\tvar arrayToObject = function arrayToObject(source, options) {\n\t    var obj = options && options.plainObjects ? Object.create(null) : {};\n\t    for (var i = 0; i < source.length; ++i) {\n\t        if (typeof source[i] !== 'undefined') {\n\t            obj[i] = source[i];\n\t        }\n\t    }\n\n\t    return obj;\n\t};\n\n\tvar merge$1 = function merge(target, source, options) {\n\t    /* eslint no-param-reassign: 0 */\n\t    if (!source) {\n\t        return target;\n\t    }\n\n\t    if (typeof source !== 'object') {\n\t        if (isArray$3(target)) {\n\t            target.push(source);\n\t        } else if (target && typeof target === 'object') {\n\t            if ((options && (options.plainObjects || options.allowPrototypes)) || !has$2.call(Object.prototype, source)) {\n\t                target[source] = true;\n\t            }\n\t        } else {\n\t            return [target, source];\n\t        }\n\n\t        return target;\n\t    }\n\n\t    if (!target || typeof target !== 'object') {\n\t        return [target].concat(source);\n\t    }\n\n\t    var mergeTarget = target;\n\t    if (isArray$3(target) && !isArray$3(source)) {\n\t        mergeTarget = arrayToObject(target, options);\n\t    }\n\n\t    if (isArray$3(target) && isArray$3(source)) {\n\t        source.forEach(function (item, i) {\n\t            if (has$2.call(target, i)) {\n\t                var targetItem = target[i];\n\t                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n\t                    target[i] = merge(targetItem, item, options);\n\t                } else {\n\t                    target.push(item);\n\t                }\n\t            } else {\n\t                target[i] = item;\n\t            }\n\t        });\n\t        return target;\n\t    }\n\n\t    return Object.keys(source).reduce(function (acc, key) {\n\t        var value = source[key];\n\n\t        if (has$2.call(acc, key)) {\n\t            acc[key] = merge(acc[key], value, options);\n\t        } else {\n\t            acc[key] = value;\n\t        }\n\t        return acc;\n\t    }, mergeTarget);\n\t};\n\n\tvar assign = function assignSingleSource(target, source) {\n\t    return Object.keys(source).reduce(function (acc, key) {\n\t        acc[key] = source[key];\n\t        return acc;\n\t    }, target);\n\t};\n\n\tvar decode = function (str, decoder, charset) {\n\t    var strWithoutPlus = str.replace(/\\+/g, ' ');\n\t    if (charset === 'iso-8859-1') {\n\t        // unescape never throws, no try...catch needed:\n\t        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n\t    }\n\t    // utf-8\n\t    try {\n\t        return decodeURIComponent(strWithoutPlus);\n\t    } catch (e) {\n\t        return strWithoutPlus;\n\t    }\n\t};\n\n\tvar encode = function encode(str, defaultEncoder, charset, kind, format) {\n\t    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n\t    // It has been adapted here for stricter adherence to RFC 3986\n\t    if (str.length === 0) {\n\t        return str;\n\t    }\n\n\t    var string = str;\n\t    if (typeof str === 'symbol') {\n\t        string = Symbol.prototype.toString.call(str);\n\t    } else if (typeof str !== 'string') {\n\t        string = String(str);\n\t    }\n\n\t    if (charset === 'iso-8859-1') {\n\t        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n\t            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n\t        });\n\t    }\n\n\t    var out = '';\n\t    for (var i = 0; i < string.length; ++i) {\n\t        var c = string.charCodeAt(i);\n\n\t        if (\n\t            c === 0x2D // -\n\t            || c === 0x2E // .\n\t            || c === 0x5F // _\n\t            || c === 0x7E // ~\n\t            || (c >= 0x30 && c <= 0x39) // 0-9\n\t            || (c >= 0x41 && c <= 0x5A) // a-z\n\t            || (c >= 0x61 && c <= 0x7A) // A-Z\n\t            || (format === formats$2.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\n\t        ) {\n\t            out += string.charAt(i);\n\t            continue;\n\t        }\n\n\t        if (c < 0x80) {\n\t            out = out + hexTable[c];\n\t            continue;\n\t        }\n\n\t        if (c < 0x800) {\n\t            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n\t            continue;\n\t        }\n\n\t        if (c < 0xD800 || c >= 0xE000) {\n\t            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n\t            continue;\n\t        }\n\n\t        i += 1;\n\t        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n\t        /* eslint operator-linebreak: [2, \"before\"] */\n\t        out += hexTable[0xF0 | (c >> 18)]\n\t            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n\t            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n\t            + hexTable[0x80 | (c & 0x3F)];\n\t    }\n\n\t    return out;\n\t};\n\n\tvar compact = function compact(value) {\n\t    var queue = [{ obj: { o: value }, prop: 'o' }];\n\t    var refs = [];\n\n\t    for (var i = 0; i < queue.length; ++i) {\n\t        var item = queue[i];\n\t        var obj = item.obj[item.prop];\n\n\t        var keys = Object.keys(obj);\n\t        for (var j = 0; j < keys.length; ++j) {\n\t            var key = keys[j];\n\t            var val = obj[key];\n\t            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n\t                queue.push({ obj: obj, prop: key });\n\t                refs.push(val);\n\t            }\n\t        }\n\t    }\n\n\t    compactQueue(queue);\n\n\t    return value;\n\t};\n\n\tvar isRegExp = function isRegExp(obj) {\n\t    return Object.prototype.toString.call(obj) === '[object RegExp]';\n\t};\n\n\tvar isBuffer$1 = function isBuffer(obj) {\n\t    if (!obj || typeof obj !== 'object') {\n\t        return false;\n\t    }\n\n\t    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n\t};\n\n\tvar combine = function combine(a, b) {\n\t    return [].concat(a, b);\n\t};\n\n\tvar maybeMap = function maybeMap(val, fn) {\n\t    if (isArray$3(val)) {\n\t        var mapped = [];\n\t        for (var i = 0; i < val.length; i += 1) {\n\t            mapped.push(fn(val[i]));\n\t        }\n\t        return mapped;\n\t    }\n\t    return fn(val);\n\t};\n\n\tvar utils$3 = {\n\t    arrayToObject: arrayToObject,\n\t    assign: assign,\n\t    combine: combine,\n\t    compact: compact,\n\t    decode: decode,\n\t    encode: encode,\n\t    isBuffer: isBuffer$1,\n\t    isRegExp: isRegExp,\n\t    maybeMap: maybeMap,\n\t    merge: merge$1\n\t};\n\n\tvar getSideChannel = sideChannel;\n\tvar utils$2 = utils$3;\n\tvar formats$1 = formats$3;\n\tvar has$1 = Object.prototype.hasOwnProperty;\n\n\tvar arrayPrefixGenerators = {\n\t    brackets: function brackets(prefix) {\n\t        return prefix + '[]';\n\t    },\n\t    comma: 'comma',\n\t    indices: function indices(prefix, key) {\n\t        return prefix + '[' + key + ']';\n\t    },\n\t    repeat: function repeat(prefix) {\n\t        return prefix;\n\t    }\n\t};\n\n\tvar isArray$2 = Array.isArray;\n\tvar split = String.prototype.split;\n\tvar push = Array.prototype.push;\n\tvar pushToArray = function (arr, valueOrArray) {\n\t    push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);\n\t};\n\n\tvar toISO = Date.prototype.toISOString;\n\n\tvar defaultFormat = formats$1['default'];\n\tvar defaults$1 = {\n\t    addQueryPrefix: false,\n\t    allowDots: false,\n\t    charset: 'utf-8',\n\t    charsetSentinel: false,\n\t    delimiter: '&',\n\t    encode: true,\n\t    encoder: utils$2.encode,\n\t    encodeValuesOnly: false,\n\t    format: defaultFormat,\n\t    formatter: formats$1.formatters[defaultFormat],\n\t    // deprecated\n\t    indices: false,\n\t    serializeDate: function serializeDate(date) {\n\t        return toISO.call(date);\n\t    },\n\t    skipNulls: false,\n\t    strictNullHandling: false\n\t};\n\n\tvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n\t    return typeof v === 'string'\n\t        || typeof v === 'number'\n\t        || typeof v === 'boolean'\n\t        || typeof v === 'symbol'\n\t        || typeof v === 'bigint';\n\t};\n\n\tvar sentinel = {};\n\n\tvar stringify$1 = function stringify(\n\t    object,\n\t    prefix,\n\t    generateArrayPrefix,\n\t    strictNullHandling,\n\t    skipNulls,\n\t    encoder,\n\t    filter,\n\t    sort,\n\t    allowDots,\n\t    serializeDate,\n\t    format,\n\t    formatter,\n\t    encodeValuesOnly,\n\t    charset,\n\t    sideChannel\n\t) {\n\t    var obj = object;\n\n\t    var tmpSc = sideChannel;\n\t    var step = 0;\n\t    var findFlag = false;\n\t    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\n\t        // Where object last appeared in the ref tree\n\t        var pos = tmpSc.get(object);\n\t        step += 1;\n\t        if (typeof pos !== 'undefined') {\n\t            if (pos === step) {\n\t                throw new RangeError('Cyclic object value');\n\t            } else {\n\t                findFlag = true; // Break while\n\t            }\n\t        }\n\t        if (typeof tmpSc.get(sentinel) === 'undefined') {\n\t            step = 0;\n\t        }\n\t    }\n\n\t    if (typeof filter === 'function') {\n\t        obj = filter(prefix, obj);\n\t    } else if (obj instanceof Date) {\n\t        obj = serializeDate(obj);\n\t    } else if (generateArrayPrefix === 'comma' && isArray$2(obj)) {\n\t        obj = utils$2.maybeMap(obj, function (value) {\n\t            if (value instanceof Date) {\n\t                return serializeDate(value);\n\t            }\n\t            return value;\n\t        });\n\t    }\n\n\t    if (obj === null) {\n\t        if (strictNullHandling) {\n\t            return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, 'key', format) : prefix;\n\t        }\n\n\t        obj = '';\n\t    }\n\n\t    if (isNonNullishPrimitive(obj) || utils$2.isBuffer(obj)) {\n\t        if (encoder) {\n\t            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, 'key', format);\n\t            if (generateArrayPrefix === 'comma' && encodeValuesOnly) {\n\t                var valuesArray = split.call(String(obj), ',');\n\t                var valuesJoined = '';\n\t                for (var i = 0; i < valuesArray.length; ++i) {\n\t                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults$1.encoder, charset, 'value', format));\n\t                }\n\t                return [formatter(keyValue) + '=' + valuesJoined];\n\t            }\n\t            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$1.encoder, charset, 'value', format))];\n\t        }\n\t        return [formatter(prefix) + '=' + formatter(String(obj))];\n\t    }\n\n\t    var values = [];\n\n\t    if (typeof obj === 'undefined') {\n\t        return values;\n\t    }\n\n\t    var objKeys;\n\t    if (generateArrayPrefix === 'comma' && isArray$2(obj)) {\n\t        // we need to join elements in\n\t        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\n\t    } else if (isArray$2(filter)) {\n\t        objKeys = filter;\n\t    } else {\n\t        var keys = Object.keys(obj);\n\t        objKeys = sort ? keys.sort(sort) : keys;\n\t    }\n\n\t    for (var j = 0; j < objKeys.length; ++j) {\n\t        var key = objKeys[j];\n\t        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\n\n\t        if (skipNulls && value === null) {\n\t            continue;\n\t        }\n\n\t        var keyPrefix = isArray$2(obj)\n\t            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix\n\t            : prefix + (allowDots ? '.' + key : '[' + key + ']');\n\n\t        sideChannel.set(object, step);\n\t        var valueSideChannel = getSideChannel();\n\t        valueSideChannel.set(sentinel, sideChannel);\n\t        pushToArray(values, stringify(\n\t            value,\n\t            keyPrefix,\n\t            generateArrayPrefix,\n\t            strictNullHandling,\n\t            skipNulls,\n\t            encoder,\n\t            filter,\n\t            sort,\n\t            allowDots,\n\t            serializeDate,\n\t            format,\n\t            formatter,\n\t            encodeValuesOnly,\n\t            charset,\n\t            valueSideChannel\n\t        ));\n\t    }\n\n\t    return values;\n\t};\n\n\tvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n\t    if (!opts) {\n\t        return defaults$1;\n\t    }\n\n\t    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\n\t        throw new TypeError('Encoder has to be a function.');\n\t    }\n\n\t    var charset = opts.charset || defaults$1.charset;\n\t    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n\t        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n\t    }\n\n\t    var format = formats$1['default'];\n\t    if (typeof opts.format !== 'undefined') {\n\t        if (!has$1.call(formats$1.formatters, opts.format)) {\n\t            throw new TypeError('Unknown format option provided.');\n\t        }\n\t        format = opts.format;\n\t    }\n\t    var formatter = formats$1.formatters[format];\n\n\t    var filter = defaults$1.filter;\n\t    if (typeof opts.filter === 'function' || isArray$2(opts.filter)) {\n\t        filter = opts.filter;\n\t    }\n\n\t    return {\n\t        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults$1.addQueryPrefix,\n\t        allowDots: typeof opts.allowDots === 'undefined' ? defaults$1.allowDots : !!opts.allowDots,\n\t        charset: charset,\n\t        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,\n\t        delimiter: typeof opts.delimiter === 'undefined' ? defaults$1.delimiter : opts.delimiter,\n\t        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults$1.encode,\n\t        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults$1.encoder,\n\t        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,\n\t        filter: filter,\n\t        format: format,\n\t        formatter: formatter,\n\t        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults$1.serializeDate,\n\t        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults$1.skipNulls,\n\t        sort: typeof opts.sort === 'function' ? opts.sort : null,\n\t        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling\n\t    };\n\t};\n\n\tvar stringify_1 = function (object, opts) {\n\t    var obj = object;\n\t    var options = normalizeStringifyOptions(opts);\n\n\t    var objKeys;\n\t    var filter;\n\n\t    if (typeof options.filter === 'function') {\n\t        filter = options.filter;\n\t        obj = filter('', obj);\n\t    } else if (isArray$2(options.filter)) {\n\t        filter = options.filter;\n\t        objKeys = filter;\n\t    }\n\n\t    var keys = [];\n\n\t    if (typeof obj !== 'object' || obj === null) {\n\t        return '';\n\t    }\n\n\t    var arrayFormat;\n\t    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n\t        arrayFormat = opts.arrayFormat;\n\t    } else if (opts && 'indices' in opts) {\n\t        arrayFormat = opts.indices ? 'indices' : 'repeat';\n\t    } else {\n\t        arrayFormat = 'indices';\n\t    }\n\n\t    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n\t    if (!objKeys) {\n\t        objKeys = Object.keys(obj);\n\t    }\n\n\t    if (options.sort) {\n\t        objKeys.sort(options.sort);\n\t    }\n\n\t    var sideChannel = getSideChannel();\n\t    for (var i = 0; i < objKeys.length; ++i) {\n\t        var key = objKeys[i];\n\n\t        if (options.skipNulls && obj[key] === null) {\n\t            continue;\n\t        }\n\t        pushToArray(keys, stringify$1(\n\t            obj[key],\n\t            key,\n\t            generateArrayPrefix,\n\t            options.strictNullHandling,\n\t            options.skipNulls,\n\t            options.encode ? options.encoder : null,\n\t            options.filter,\n\t            options.sort,\n\t            options.allowDots,\n\t            options.serializeDate,\n\t            options.format,\n\t            options.formatter,\n\t            options.encodeValuesOnly,\n\t            options.charset,\n\t            sideChannel\n\t        ));\n\t    }\n\n\t    var joined = keys.join(options.delimiter);\n\t    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n\t    if (options.charsetSentinel) {\n\t        if (options.charset === 'iso-8859-1') {\n\t            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n\t            prefix += 'utf8=%26%2310003%3B&';\n\t        } else {\n\t            // encodeURIComponent('')\n\t            prefix += 'utf8=%E2%9C%93&';\n\t        }\n\t    }\n\n\t    return joined.length > 0 ? prefix + joined : '';\n\t};\n\n\tvar utils$1 = utils$3;\n\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar isArray$1 = Array.isArray;\n\n\tvar defaults = {\n\t    allowDots: false,\n\t    allowPrototypes: false,\n\t    allowSparse: false,\n\t    arrayLimit: 20,\n\t    charset: 'utf-8',\n\t    charsetSentinel: false,\n\t    comma: false,\n\t    decoder: utils$1.decode,\n\t    delimiter: '&',\n\t    depth: 5,\n\t    ignoreQueryPrefix: false,\n\t    interpretNumericEntities: false,\n\t    parameterLimit: 1000,\n\t    parseArrays: true,\n\t    plainObjects: false,\n\t    strictNullHandling: false\n\t};\n\n\tvar interpretNumericEntities = function (str) {\n\t    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n\t        return String.fromCharCode(parseInt(numberStr, 10));\n\t    });\n\t};\n\n\tvar parseArrayValue = function (val, options) {\n\t    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n\t        return val.split(',');\n\t    }\n\n\t    return val;\n\t};\n\n\t// This is what browsers will submit when the  character occurs in an\n\t// application/x-www-form-urlencoded body and the encoding of the page containing\n\t// the form is iso-8859-1, or when the submitted form has an accept-charset\n\t// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n\t// the  character, such as us-ascii.\n\tvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n\t// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\n\tvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')\n\n\tvar parseValues = function parseQueryStringValues(str, options) {\n\t    var obj = {};\n\t    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n\t    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n\t    var parts = cleanStr.split(options.delimiter, limit);\n\t    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n\t    var i;\n\n\t    var charset = options.charset;\n\t    if (options.charsetSentinel) {\n\t        for (i = 0; i < parts.length; ++i) {\n\t            if (parts[i].indexOf('utf8=') === 0) {\n\t                if (parts[i] === charsetSentinel) {\n\t                    charset = 'utf-8';\n\t                } else if (parts[i] === isoSentinel) {\n\t                    charset = 'iso-8859-1';\n\t                }\n\t                skipIndex = i;\n\t                i = parts.length; // The eslint settings do not allow break;\n\t            }\n\t        }\n\t    }\n\n\t    for (i = 0; i < parts.length; ++i) {\n\t        if (i === skipIndex) {\n\t            continue;\n\t        }\n\t        var part = parts[i];\n\n\t        var bracketEqualsPos = part.indexOf(']=');\n\t        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n\t        var key, val;\n\t        if (pos === -1) {\n\t            key = options.decoder(part, defaults.decoder, charset, 'key');\n\t            val = options.strictNullHandling ? null : '';\n\t        } else {\n\t            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n\t            val = utils$1.maybeMap(\n\t                parseArrayValue(part.slice(pos + 1), options),\n\t                function (encodedVal) {\n\t                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');\n\t                }\n\t            );\n\t        }\n\n\t        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n\t            val = interpretNumericEntities(val);\n\t        }\n\n\t        if (part.indexOf('[]=') > -1) {\n\t            val = isArray$1(val) ? [val] : val;\n\t        }\n\n\t        if (has.call(obj, key)) {\n\t            obj[key] = utils$1.combine(obj[key], val);\n\t        } else {\n\t            obj[key] = val;\n\t        }\n\t    }\n\n\t    return obj;\n\t};\n\n\tvar parseObject = function (chain, val, options, valuesParsed) {\n\t    var leaf = valuesParsed ? val : parseArrayValue(val, options);\n\n\t    for (var i = chain.length - 1; i >= 0; --i) {\n\t        var obj;\n\t        var root = chain[i];\n\n\t        if (root === '[]' && options.parseArrays) {\n\t            obj = [].concat(leaf);\n\t        } else {\n\t            obj = options.plainObjects ? Object.create(null) : {};\n\t            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n\t            var index = parseInt(cleanRoot, 10);\n\t            if (!options.parseArrays && cleanRoot === '') {\n\t                obj = { 0: leaf };\n\t            } else if (\n\t                !isNaN(index)\n\t                && root !== cleanRoot\n\t                && String(index) === cleanRoot\n\t                && index >= 0\n\t                && (options.parseArrays && index <= options.arrayLimit)\n\t            ) {\n\t                obj = [];\n\t                obj[index] = leaf;\n\t            } else if (cleanRoot !== '__proto__') {\n\t                obj[cleanRoot] = leaf;\n\t            }\n\t        }\n\n\t        leaf = obj;\n\t    }\n\n\t    return leaf;\n\t};\n\n\tvar parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\n\t    if (!givenKey) {\n\t        return;\n\t    }\n\n\t    // Transform dot notation to bracket notation\n\t    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n\t    // The regex chunks\n\n\t    var brackets = /(\\[[^[\\]]*])/;\n\t    var child = /(\\[[^[\\]]*])/g;\n\n\t    // Get the parent\n\n\t    var segment = options.depth > 0 && brackets.exec(key);\n\t    var parent = segment ? key.slice(0, segment.index) : key;\n\n\t    // Stash the parent if it exists\n\n\t    var keys = [];\n\t    if (parent) {\n\t        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n\t        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n\t            if (!options.allowPrototypes) {\n\t                return;\n\t            }\n\t        }\n\n\t        keys.push(parent);\n\t    }\n\n\t    // Loop through children appending to the array until we hit depth\n\n\t    var i = 0;\n\t    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n\t        i += 1;\n\t        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n\t            if (!options.allowPrototypes) {\n\t                return;\n\t            }\n\t        }\n\t        keys.push(segment[1]);\n\t    }\n\n\t    // If there's a remainder, just add whatever is left\n\n\t    if (segment) {\n\t        keys.push('[' + key.slice(segment.index) + ']');\n\t    }\n\n\t    return parseObject(keys, val, options, valuesParsed);\n\t};\n\n\tvar normalizeParseOptions = function normalizeParseOptions(opts) {\n\t    if (!opts) {\n\t        return defaults;\n\t    }\n\n\t    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n\t        throw new TypeError('Decoder has to be a function.');\n\t    }\n\n\t    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n\t        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n\t    }\n\t    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n\t    return {\n\t        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n\t        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n\t        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\n\t        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n\t        charset: charset,\n\t        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n\t        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n\t        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n\t        delimiter: typeof opts.delimiter === 'string' || utils$1.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n\t        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n\t        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n\t        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n\t        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n\t        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n\t        parseArrays: opts.parseArrays !== false,\n\t        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n\t        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n\t    };\n\t};\n\n\tvar parse$1 = function (str, opts) {\n\t    var options = normalizeParseOptions(opts);\n\n\t    if (str === '' || str === null || typeof str === 'undefined') {\n\t        return options.plainObjects ? Object.create(null) : {};\n\t    }\n\n\t    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n\t    var obj = options.plainObjects ? Object.create(null) : {};\n\n\t    // Iterate over the keys and setup the new object\n\n\t    var keys = Object.keys(tempObj);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');\n\t        obj = utils$1.merge(obj, newObj, options);\n\t    }\n\n\t    if (options.allowSparse === true) {\n\t        return obj;\n\t    }\n\n\t    return utils$1.compact(obj);\n\t};\n\n\tvar stringify = stringify_1;\n\tvar parse = parse$1;\n\tvar formats = formats$3;\n\n\tvar lib = {\n\t    formats: formats,\n\t    parse: parse,\n\t    stringify: stringify\n\t};\n\n\t/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof global$1 == 'object' && global$1 && global$1.Object === Object && global$1;\n\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\n\t/** Built-in value references. */\n\tvar Symbol$1 = root.Symbol;\n\n\t/** Used for built-in method references. */\n\tvar objectProto$f = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$c = objectProto$f.hasOwnProperty;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString$1 = objectProto$f.toString;\n\n\t/** Built-in value references. */\n\tvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n\t/**\n\t * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the raw `toStringTag`.\n\t */\n\tfunction getRawTag(value) {\n\t  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1),\n\t      tag = value[symToStringTag$1];\n\n\t  try {\n\t    value[symToStringTag$1] = undefined;\n\t    var unmasked = true;\n\t  } catch (e) {}\n\n\t  var result = nativeObjectToString$1.call(value);\n\t  if (unmasked) {\n\t    if (isOwn) {\n\t      value[symToStringTag$1] = tag;\n\t    } else {\n\t      delete value[symToStringTag$1];\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$e = Object.prototype;\n\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString = objectProto$e.toString;\n\n\t/**\n\t * Converts `value` to a string using `Object.prototype.toString`.\n\t *\n\t * @private\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t */\n\tfunction objectToString(value) {\n\t  return nativeObjectToString.call(value);\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar nullTag = '[object Null]',\n\t    undefinedTag = '[object Undefined]';\n\n\t/** Built-in value references. */\n\tvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n\t/**\n\t * The base implementation of `getTag` without fallbacks for buggy environments.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */\n\tfunction baseGetTag(value) {\n\t  if (value == null) {\n\t    return value === undefined ? undefinedTag : nullTag;\n\t  }\n\t  return (symToStringTag && symToStringTag in Object(value))\n\t    ? getRawTag(value)\n\t    : objectToString(value);\n\t}\n\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject$1(value) {\n\t  var type = typeof value;\n\t  return value != null && (type == 'object' || type == 'function');\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar asyncTag = '[object AsyncFunction]',\n\t    funcTag$2 = '[object Function]',\n\t    genTag$1 = '[object GeneratorFunction]',\n\t    proxyTag = '[object Proxy]';\n\n\t/**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */\n\tfunction isFunction$1(value) {\n\t  if (!isObject$1(value)) {\n\t    return false;\n\t  }\n\t  // The use of `Object#toString` avoids issues with the `typeof` operator\n\t  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\t  var tag = baseGetTag(value);\n\t  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;\n\t}\n\n\t/** Used to detect overreaching core-js shims. */\n\tvar coreJsData = root['__core-js_shared__'];\n\n\t/** Used to detect methods masquerading as native. */\n\tvar maskSrcKey = (function() {\n\t  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n\t  return uid ? ('Symbol(src)_1.' + uid) : '';\n\t}());\n\n\t/**\n\t * Checks if `func` has its source masked.\n\t *\n\t * @private\n\t * @param {Function} func The function to check.\n\t * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t */\n\tfunction isMasked(func) {\n\t  return !!maskSrcKey && (maskSrcKey in func);\n\t}\n\n\t/** Used for built-in method references. */\n\tvar funcProto$1 = Function.prototype;\n\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString$1 = funcProto$1.toString;\n\n\t/**\n\t * Converts `func` to its source code.\n\t *\n\t * @private\n\t * @param {Function} func The function to convert.\n\t * @returns {string} Returns the source code.\n\t */\n\tfunction toSource(func) {\n\t  if (func != null) {\n\t    try {\n\t      return funcToString$1.call(func);\n\t    } catch (e) {}\n\t    try {\n\t      return (func + '');\n\t    } catch (e) {}\n\t  }\n\t  return '';\n\t}\n\n\t/**\n\t * Used to match `RegExp`\n\t * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t */\n\tvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n\t/** Used to detect host constructors (Safari). */\n\tvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n\t/** Used for built-in method references. */\n\tvar funcProto = Function.prototype,\n\t    objectProto$d = Object.prototype;\n\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$b = objectProto$d.hasOwnProperty;\n\n\t/** Used to detect if a method is native. */\n\tvar reIsNative = RegExp('^' +\n\t  funcToString.call(hasOwnProperty$b).replace(reRegExpChar, '\\\\$&')\n\t  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\n\t/**\n\t * The base implementation of `_.isNative` without bad shim checks.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function,\n\t *  else `false`.\n\t */\n\tfunction baseIsNative(value) {\n\t  if (!isObject$1(value) || isMasked(value)) {\n\t    return false;\n\t  }\n\t  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;\n\t  return pattern.test(toSource(value));\n\t}\n\n\t/**\n\t * Gets the value at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} [object] The object to query.\n\t * @param {string} key The key of the property to get.\n\t * @returns {*} Returns the property value.\n\t */\n\tfunction getValue(object, key) {\n\t  return object == null ? undefined : object[key];\n\t}\n\n\t/**\n\t * Gets the native function at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {string} key The key of the method to get.\n\t * @returns {*} Returns the function if it's native, else `undefined`.\n\t */\n\tfunction getNative(object, key) {\n\t  var value = getValue(object, key);\n\t  return baseIsNative(value) ? value : undefined;\n\t}\n\n\tvar defineProperty = (function() {\n\t  try {\n\t    var func = getNative(Object, 'defineProperty');\n\t    func({}, '', {});\n\t    return func;\n\t  } catch (e) {}\n\t}());\n\n\t/**\n\t * The base implementation of `assignValue` and `assignMergeValue` without\n\t * value checks.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */\n\tfunction baseAssignValue(object, key, value) {\n\t  if (key == '__proto__' && defineProperty) {\n\t    defineProperty(object, key, {\n\t      'configurable': true,\n\t      'enumerable': true,\n\t      'value': value,\n\t      'writable': true\n\t    });\n\t  } else {\n\t    object[key] = value;\n\t  }\n\t}\n\n\t/**\n\t * Performs a\n\t * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * comparison between two values to determine if they are equivalent.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t * var other = { 'a': 1 };\n\t *\n\t * _.eq(object, object);\n\t * // => true\n\t *\n\t * _.eq(object, other);\n\t * // => false\n\t *\n\t * _.eq('a', 'a');\n\t * // => true\n\t *\n\t * _.eq('a', Object('a'));\n\t * // => false\n\t *\n\t * _.eq(NaN, NaN);\n\t * // => true\n\t */\n\tfunction eq(value, other) {\n\t  return value === other || (value !== value && other !== other);\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$c = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$a = objectProto$c.hasOwnProperty;\n\n\t/**\n\t * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * for equality comparisons.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */\n\tfunction assignValue(object, key, value) {\n\t  var objValue = object[key];\n\t  if (!(hasOwnProperty$a.call(object, key) && eq(objValue, value)) ||\n\t      (value === undefined && !(key in object))) {\n\t    baseAssignValue(object, key, value);\n\t  }\n\t}\n\n\t/**\n\t * Checks if `value` is classified as an `Array` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n\t * @example\n\t *\n\t * _.isArray([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArray(document.body.children);\n\t * // => false\n\t *\n\t * _.isArray('abc');\n\t * // => false\n\t *\n\t * _.isArray(_.noop);\n\t * // => false\n\t */\n\tvar isArray = Array.isArray;\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return value != null && typeof value == 'object';\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar symbolTag$3 = '[object Symbol]';\n\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol(value) {\n\t  return typeof value == 'symbol' ||\n\t    (isObjectLike(value) && baseGetTag(value) == symbolTag$3);\n\t}\n\n\t/** Used to match property names within property paths. */\n\tvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n\t    reIsPlainProp = /^\\w*$/;\n\n\t/**\n\t * Checks if `value` is a property name and not a property path.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t */\n\tfunction isKey(value, object) {\n\t  if (isArray(value)) {\n\t    return false;\n\t  }\n\t  var type = typeof value;\n\t  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n\t      value == null || isSymbol(value)) {\n\t    return true;\n\t  }\n\t  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n\t    (object != null && value in Object(object));\n\t}\n\n\t/* Built-in method references that are verified to be native. */\n\tvar nativeCreate = getNative(Object, 'create');\n\n\t/**\n\t * Removes all key-value entries from the hash.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Hash\n\t */\n\tfunction hashClear() {\n\t  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n\t  this.size = 0;\n\t}\n\n\t/**\n\t * Removes `key` and its value from the hash.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf Hash\n\t * @param {Object} hash The hash to modify.\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction hashDelete(key) {\n\t  var result = this.has(key) && delete this.__data__[key];\n\t  this.size -= result ? 1 : 0;\n\t  return result;\n\t}\n\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED$2 = '__lodash_hash_undefined__';\n\n\t/** Used for built-in method references. */\n\tvar objectProto$b = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$9 = objectProto$b.hasOwnProperty;\n\n\t/**\n\t * Gets the hash value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction hashGet(key) {\n\t  var data = this.__data__;\n\t  if (nativeCreate) {\n\t    var result = data[key];\n\t    return result === HASH_UNDEFINED$2 ? undefined : result;\n\t  }\n\t  return hasOwnProperty$9.call(data, key) ? data[key] : undefined;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$a = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$8 = objectProto$a.hasOwnProperty;\n\n\t/**\n\t * Checks if a hash value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Hash\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction hashHas(key) {\n\t  var data = this.__data__;\n\t  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);\n\t}\n\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n\t/**\n\t * Sets the hash `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the hash instance.\n\t */\n\tfunction hashSet(key, value) {\n\t  var data = this.__data__;\n\t  this.size += this.has(key) ? 0 : 1;\n\t  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;\n\t  return this;\n\t}\n\n\t/**\n\t * Creates a hash object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction Hash(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\n\t// Add methods to `Hash`.\n\tHash.prototype.clear = hashClear;\n\tHash.prototype['delete'] = hashDelete;\n\tHash.prototype.get = hashGet;\n\tHash.prototype.has = hashHas;\n\tHash.prototype.set = hashSet;\n\n\t/**\n\t * Removes all key-value entries from the list cache.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf ListCache\n\t */\n\tfunction listCacheClear() {\n\t  this.__data__ = [];\n\t  this.size = 0;\n\t}\n\n\t/**\n\t * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} key The key to search for.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction assocIndexOf(array, key) {\n\t  var length = array.length;\n\t  while (length--) {\n\t    if (eq(array[length][0], key)) {\n\t      return length;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar arrayProto = Array.prototype;\n\n\t/** Built-in value references. */\n\tvar splice = arrayProto.splice;\n\n\t/**\n\t * Removes `key` and its value from the list cache.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction listCacheDelete(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\n\t  if (index < 0) {\n\t    return false;\n\t  }\n\t  var lastIndex = data.length - 1;\n\t  if (index == lastIndex) {\n\t    data.pop();\n\t  } else {\n\t    splice.call(data, index, 1);\n\t  }\n\t  --this.size;\n\t  return true;\n\t}\n\n\t/**\n\t * Gets the list cache value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction listCacheGet(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\n\t  return index < 0 ? undefined : data[index][1];\n\t}\n\n\t/**\n\t * Checks if a list cache value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf ListCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction listCacheHas(key) {\n\t  return assocIndexOf(this.__data__, key) > -1;\n\t}\n\n\t/**\n\t * Sets the list cache `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the list cache instance.\n\t */\n\tfunction listCacheSet(key, value) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\n\t  if (index < 0) {\n\t    ++this.size;\n\t    data.push([key, value]);\n\t  } else {\n\t    data[index][1] = value;\n\t  }\n\t  return this;\n\t}\n\n\t/**\n\t * Creates an list cache object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction ListCache(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\n\t// Add methods to `ListCache`.\n\tListCache.prototype.clear = listCacheClear;\n\tListCache.prototype['delete'] = listCacheDelete;\n\tListCache.prototype.get = listCacheGet;\n\tListCache.prototype.has = listCacheHas;\n\tListCache.prototype.set = listCacheSet;\n\n\t/* Built-in method references that are verified to be native. */\n\tvar Map$1 = getNative(root, 'Map');\n\n\t/**\n\t * Removes all key-value entries from the map.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf MapCache\n\t */\n\tfunction mapCacheClear() {\n\t  this.size = 0;\n\t  this.__data__ = {\n\t    'hash': new Hash,\n\t    'map': new (Map$1 || ListCache),\n\t    'string': new Hash\n\t  };\n\t}\n\n\t/**\n\t * Checks if `value` is suitable for use as unique object key.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n\t */\n\tfunction isKeyable(value) {\n\t  var type = typeof value;\n\t  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n\t    ? (value !== '__proto__')\n\t    : (value === null);\n\t}\n\n\t/**\n\t * Gets the data for `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to query.\n\t * @param {string} key The reference key.\n\t * @returns {*} Returns the map data.\n\t */\n\tfunction getMapData(map, key) {\n\t  var data = map.__data__;\n\t  return isKeyable(key)\n\t    ? data[typeof key == 'string' ? 'string' : 'hash']\n\t    : data.map;\n\t}\n\n\t/**\n\t * Removes `key` and its value from the map.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction mapCacheDelete(key) {\n\t  var result = getMapData(this, key)['delete'](key);\n\t  this.size -= result ? 1 : 0;\n\t  return result;\n\t}\n\n\t/**\n\t * Gets the map value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction mapCacheGet(key) {\n\t  return getMapData(this, key).get(key);\n\t}\n\n\t/**\n\t * Checks if a map value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf MapCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction mapCacheHas(key) {\n\t  return getMapData(this, key).has(key);\n\t}\n\n\t/**\n\t * Sets the map `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the map cache instance.\n\t */\n\tfunction mapCacheSet(key, value) {\n\t  var data = getMapData(this, key),\n\t      size = data.size;\n\n\t  data.set(key, value);\n\t  this.size += data.size == size ? 0 : 1;\n\t  return this;\n\t}\n\n\t/**\n\t * Creates a map cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction MapCache(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\n\t// Add methods to `MapCache`.\n\tMapCache.prototype.clear = mapCacheClear;\n\tMapCache.prototype['delete'] = mapCacheDelete;\n\tMapCache.prototype.get = mapCacheGet;\n\tMapCache.prototype.has = mapCacheHas;\n\tMapCache.prototype.set = mapCacheSet;\n\n\t/** Error message constants. */\n\tvar FUNC_ERROR_TEXT = 'Expected a function';\n\n\t/**\n\t * Creates a function that memoizes the result of `func`. If `resolver` is\n\t * provided, it determines the cache key for storing the result based on the\n\t * arguments provided to the memoized function. By default, the first argument\n\t * provided to the memoized function is used as the map cache key. The `func`\n\t * is invoked with the `this` binding of the memoized function.\n\t *\n\t * **Note:** The cache is exposed as the `cache` property on the memoized\n\t * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t * constructor with one whose instances implement the\n\t * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n\t * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to have its output memoized.\n\t * @param {Function} [resolver] The function to resolve the cache key.\n\t * @returns {Function} Returns the new memoized function.\n\t * @example\n\t *\n\t * var object = { 'a': 1, 'b': 2 };\n\t * var other = { 'c': 3, 'd': 4 };\n\t *\n\t * var values = _.memoize(_.values);\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * values(other);\n\t * // => [3, 4]\n\t *\n\t * object.a = 2;\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * // Modify the result cache.\n\t * values.cache.set(object, ['a', 'b']);\n\t * values(object);\n\t * // => ['a', 'b']\n\t *\n\t * // Replace `_.memoize.Cache`.\n\t * _.memoize.Cache = WeakMap;\n\t */\n\tfunction memoize(func, resolver) {\n\t  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  var memoized = function() {\n\t    var args = arguments,\n\t        key = resolver ? resolver.apply(this, args) : args[0],\n\t        cache = memoized.cache;\n\n\t    if (cache.has(key)) {\n\t      return cache.get(key);\n\t    }\n\t    var result = func.apply(this, args);\n\t    memoized.cache = cache.set(key, result) || cache;\n\t    return result;\n\t  };\n\t  memoized.cache = new (memoize.Cache || MapCache);\n\t  return memoized;\n\t}\n\n\t// Expose `MapCache`.\n\tmemoize.Cache = MapCache;\n\n\t/** Used as the maximum memoize cache size. */\n\tvar MAX_MEMOIZE_SIZE = 500;\n\n\t/**\n\t * A specialized version of `_.memoize` which clears the memoized function's\n\t * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n\t *\n\t * @private\n\t * @param {Function} func The function to have its output memoized.\n\t * @returns {Function} Returns the new memoized function.\n\t */\n\tfunction memoizeCapped(func) {\n\t  var result = memoize(func, function(key) {\n\t    if (cache.size === MAX_MEMOIZE_SIZE) {\n\t      cache.clear();\n\t    }\n\t    return key;\n\t  });\n\n\t  var cache = result.cache;\n\t  return result;\n\t}\n\n\t/** Used to match property names within property paths. */\n\tvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n\t/** Used to match backslashes in property paths. */\n\tvar reEscapeChar = /\\\\(\\\\)?/g;\n\n\t/**\n\t * Converts `string` to a property path array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the property path array.\n\t */\n\tvar stringToPath = memoizeCapped(function(string) {\n\t  var result = [];\n\t  if (string.charCodeAt(0) === 46 /* . */) {\n\t    result.push('');\n\t  }\n\t  string.replace(rePropName, function(match, number, quote, subString) {\n\t    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n\t  });\n\t  return result;\n\t});\n\n\t/**\n\t * A specialized version of `_.map` for arrays without support for iteratee\n\t * shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the new mapped array.\n\t */\n\tfunction arrayMap(array, iteratee) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length,\n\t      result = Array(length);\n\n\t  while (++index < length) {\n\t    result[index] = iteratee(array[index], index, array);\n\t  }\n\t  return result;\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY$3 = 1 / 0;\n\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,\n\t    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;\n\n\t/**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  // Exit early for strings to avoid a performance hit in some environments.\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  if (isArray(value)) {\n\t    // Recursively convert values (susceptible to call stack limits).\n\t    return arrayMap(value, baseToString) + '';\n\t  }\n\t  if (isSymbol(value)) {\n\t    return symbolToString ? symbolToString.call(value) : '';\n\t  }\n\t  var result = (value + '');\n\t  return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;\n\t}\n\n\t/**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */\n\tfunction toString(value) {\n\t  return value == null ? '' : baseToString(value);\n\t}\n\n\t/**\n\t * Casts `value` to a path array if it's not one.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {Array} Returns the cast property path array.\n\t */\n\tfunction castPath(value, object) {\n\t  if (isArray(value)) {\n\t    return value;\n\t  }\n\t  return isKey(value, object) ? [value] : stringToPath(toString(value));\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n\t/** Used to detect unsigned integer values. */\n\tvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t  var type = typeof value;\n\t  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n\n\t  return !!length &&\n\t    (type == 'number' ||\n\t      (type != 'symbol' && reIsUint.test(value))) &&\n\t        (value > -1 && value % 1 == 0 && value < length);\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY$2 = 1 / 0;\n\n\t/**\n\t * Converts `value` to a string key if it's not a string or symbol.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @returns {string|symbol} Returns the key.\n\t */\n\tfunction toKey(value) {\n\t  if (typeof value == 'string' || isSymbol(value)) {\n\t    return value;\n\t  }\n\t  var result = (value + '');\n\t  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;\n\t}\n\n\t/**\n\t * The base implementation of `_.set`.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @param {Function} [customizer] The function to customize path creation.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseSet(object, path, value, customizer) {\n\t  if (!isObject$1(object)) {\n\t    return object;\n\t  }\n\t  path = castPath(path, object);\n\n\t  var index = -1,\n\t      length = path.length,\n\t      lastIndex = length - 1,\n\t      nested = object;\n\n\t  while (nested != null && ++index < length) {\n\t    var key = toKey(path[index]),\n\t        newValue = value;\n\n\t    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n\t      return object;\n\t    }\n\n\t    if (index != lastIndex) {\n\t      var objValue = nested[key];\n\t      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n\t      if (newValue === undefined) {\n\t        newValue = isObject$1(objValue)\n\t          ? objValue\n\t          : (isIndex(path[index + 1]) ? [] : {});\n\t      }\n\t    }\n\t    assignValue(nested, key, newValue);\n\t    nested = nested[key];\n\t  }\n\t  return object;\n\t}\n\n\t/**\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n\t * it's created. Arrays are created for missing index properties while objects\n\t * are created for all other missing properties. Use `_.setWith` to customize\n\t * `path` creation.\n\t *\n\t * **Note:** This method mutates `object`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns `object`.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.set(object, 'a[0].b.c', 4);\n\t * console.log(object.a[0].b.c);\n\t * // => 4\n\t *\n\t * _.set(object, ['x', '0', 'y', 'z'], 5);\n\t * console.log(object.x[0].y.z);\n\t * // => 5\n\t */\n\tfunction set(object, path, value) {\n\t  return object == null ? object : baseSet(object, path, value);\n\t}\n\n\t/**\n\t * The base implementation of `_.get` without support for default values.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {*} Returns the resolved value.\n\t */\n\tfunction baseGet(object, path) {\n\t  path = castPath(path, object);\n\n\t  var index = 0,\n\t      length = path.length;\n\n\t  while (object != null && index < length) {\n\t    object = object[toKey(path[index++])];\n\t  }\n\t  return (index && index == length) ? object : undefined;\n\t}\n\n\t/**\n\t * Gets the value at `path` of `object`. If the resolved value is\n\t * `undefined`, the `defaultValue` is returned in its place.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n\t * @returns {*} Returns the resolved value.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.get(object, 'a[0].b.c');\n\t * // => 3\n\t *\n\t * _.get(object, ['a', '0', 'b', 'c']);\n\t * // => 3\n\t *\n\t * _.get(object, 'a.b.c', 'default');\n\t * // => 'default'\n\t */\n\tfunction get(object, path, defaultValue) {\n\t  var result = object == null ? undefined : baseGet(object, path);\n\t  return result === undefined ? defaultValue : result;\n\t}\n\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n\t/**\n\t * Adds `value` to the array cache.\n\t *\n\t * @private\n\t * @name add\n\t * @memberOf SetCache\n\t * @alias push\n\t * @param {*} value The value to cache.\n\t * @returns {Object} Returns the cache instance.\n\t */\n\tfunction setCacheAdd(value) {\n\t  this.__data__.set(value, HASH_UNDEFINED);\n\t  return this;\n\t}\n\n\t/**\n\t * Checks if `value` is in the array cache.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf SetCache\n\t * @param {*} value The value to search for.\n\t * @returns {number} Returns `true` if `value` is found, else `false`.\n\t */\n\tfunction setCacheHas(value) {\n\t  return this.__data__.has(value);\n\t}\n\n\t/**\n\t *\n\t * Creates an array cache object to store unique values.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [values] The values to cache.\n\t */\n\tfunction SetCache(values) {\n\t  var index = -1,\n\t      length = values == null ? 0 : values.length;\n\n\t  this.__data__ = new MapCache;\n\t  while (++index < length) {\n\t    this.add(values[index]);\n\t  }\n\t}\n\n\t// Add methods to `SetCache`.\n\tSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n\tSetCache.prototype.has = setCacheHas;\n\n\t/**\n\t * The base implementation of `_.findIndex` and `_.findLastIndex` without\n\t * support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {Function} predicate The function invoked per iteration.\n\t * @param {number} fromIndex The index to search from.\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n\t  var length = array.length,\n\t      index = fromIndex + (fromRight ? 1 : -1);\n\n\t  while ((fromRight ? index-- : ++index < length)) {\n\t    if (predicate(array[index], index, array)) {\n\t      return index;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\t/**\n\t * The base implementation of `_.isNaN` without support for number objects.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t */\n\tfunction baseIsNaN(value) {\n\t  return value !== value;\n\t}\n\n\t/**\n\t * A specialized version of `_.indexOf` which performs strict equality\n\t * comparisons of values, i.e. `===`.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} value The value to search for.\n\t * @param {number} fromIndex The index to search from.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction strictIndexOf(array, value, fromIndex) {\n\t  var index = fromIndex - 1,\n\t      length = array.length;\n\n\t  while (++index < length) {\n\t    if (array[index] === value) {\n\t      return index;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\t/**\n\t * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} value The value to search for.\n\t * @param {number} fromIndex The index to search from.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction baseIndexOf(array, value, fromIndex) {\n\t  return value === value\n\t    ? strictIndexOf(array, value, fromIndex)\n\t    : baseFindIndex(array, baseIsNaN, fromIndex);\n\t}\n\n\t/**\n\t * A specialized version of `_.includes` for arrays without support for\n\t * specifying an index to search from.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to inspect.\n\t * @param {*} target The value to search for.\n\t * @returns {boolean} Returns `true` if `target` is found, else `false`.\n\t */\n\tfunction arrayIncludes(array, value) {\n\t  var length = array == null ? 0 : array.length;\n\t  return !!length && baseIndexOf(array, value, 0) > -1;\n\t}\n\n\t/**\n\t * This function is like `arrayIncludes` except that it accepts a comparator.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to inspect.\n\t * @param {*} target The value to search for.\n\t * @param {Function} comparator The comparator invoked per element.\n\t * @returns {boolean} Returns `true` if `target` is found, else `false`.\n\t */\n\tfunction arrayIncludesWith(array, value, comparator) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\n\t  while (++index < length) {\n\t    if (comparator(value, array[index])) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\n\t/**\n\t * Checks if a `cache` value for `key` exists.\n\t *\n\t * @private\n\t * @param {Object} cache The cache to query.\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction cacheHas(cache, key) {\n\t  return cache.has(key);\n\t}\n\n\t/* Built-in method references that are verified to be native. */\n\tvar Set$1 = getNative(root, 'Set');\n\n\t/**\n\t * This method returns `undefined`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.3.0\n\t * @category Util\n\t * @example\n\t *\n\t * _.times(2, _.noop);\n\t * // => [undefined, undefined]\n\t */\n\tfunction noop() {\n\t  // No operation performed.\n\t}\n\n\t/**\n\t * Converts `set` to an array of its values.\n\t *\n\t * @private\n\t * @param {Object} set The set to convert.\n\t * @returns {Array} Returns the values.\n\t */\n\tfunction setToArray(set) {\n\t  var index = -1,\n\t      result = Array(set.size);\n\n\t  set.forEach(function(value) {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY$1 = 1 / 0;\n\n\t/**\n\t * Creates a set object of `values`.\n\t *\n\t * @private\n\t * @param {Array} values The values to add to the set.\n\t * @returns {Object} Returns the new set.\n\t */\n\tvar createSet = !(Set$1 && (1 / setToArray(new Set$1([,-0]))[1]) == INFINITY$1) ? noop : function(values) {\n\t  return new Set$1(values);\n\t};\n\n\t/** Used as the size to enable large array optimizations. */\n\tvar LARGE_ARRAY_SIZE$1 = 200;\n\n\t/**\n\t * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {Function} [iteratee] The iteratee invoked per element.\n\t * @param {Function} [comparator] The comparator invoked per element.\n\t * @returns {Array} Returns the new duplicate free array.\n\t */\n\tfunction baseUniq(array, iteratee, comparator) {\n\t  var index = -1,\n\t      includes = arrayIncludes,\n\t      length = array.length,\n\t      isCommon = true,\n\t      result = [],\n\t      seen = result;\n\n\t  if (comparator) {\n\t    isCommon = false;\n\t    includes = arrayIncludesWith;\n\t  }\n\t  else if (length >= LARGE_ARRAY_SIZE$1) {\n\t    var set = iteratee ? null : createSet(array);\n\t    if (set) {\n\t      return setToArray(set);\n\t    }\n\t    isCommon = false;\n\t    includes = cacheHas;\n\t    seen = new SetCache;\n\t  }\n\t  else {\n\t    seen = iteratee ? [] : result;\n\t  }\n\t  outer:\n\t  while (++index < length) {\n\t    var value = array[index],\n\t        computed = iteratee ? iteratee(value) : value;\n\n\t    value = (comparator || value !== 0) ? value : 0;\n\t    if (isCommon && computed === computed) {\n\t      var seenIndex = seen.length;\n\t      while (seenIndex--) {\n\t        if (seen[seenIndex] === computed) {\n\t          continue outer;\n\t        }\n\t      }\n\t      if (iteratee) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    }\n\t    else if (!includes(seen, computed, comparator)) {\n\t      if (seen !== result) {\n\t        seen.push(computed);\n\t      }\n\t      result.push(value);\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Creates a duplicate-free version of an array, using\n\t * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * for equality comparisons, in which only the first occurrence of each element\n\t * is kept. The order of result values is determined by the order they occur\n\t * in the array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Array\n\t * @param {Array} array The array to inspect.\n\t * @returns {Array} Returns the new duplicate free array.\n\t * @example\n\t *\n\t * _.uniq([2, 1, 2]);\n\t * // => [2, 1]\n\t */\n\tfunction uniq(array) {\n\t  return (array && array.length) ? baseUniq(array) : [];\n\t}\n\n\t/**\n\t * Removes all key-value entries from the stack.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Stack\n\t */\n\tfunction stackClear() {\n\t  this.__data__ = new ListCache;\n\t  this.size = 0;\n\t}\n\n\t/**\n\t * Removes `key` and its value from the stack.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction stackDelete(key) {\n\t  var data = this.__data__,\n\t      result = data['delete'](key);\n\n\t  this.size = data.size;\n\t  return result;\n\t}\n\n\t/**\n\t * Gets the stack value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction stackGet(key) {\n\t  return this.__data__.get(key);\n\t}\n\n\t/**\n\t * Checks if a stack value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Stack\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction stackHas(key) {\n\t  return this.__data__.has(key);\n\t}\n\n\t/** Used as the size to enable large array optimizations. */\n\tvar LARGE_ARRAY_SIZE = 200;\n\n\t/**\n\t * Sets the stack `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the stack cache instance.\n\t */\n\tfunction stackSet(key, value) {\n\t  var data = this.__data__;\n\t  if (data instanceof ListCache) {\n\t    var pairs = data.__data__;\n\t    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n\t      pairs.push([key, value]);\n\t      this.size = ++data.size;\n\t      return this;\n\t    }\n\t    data = this.__data__ = new MapCache(pairs);\n\t  }\n\t  data.set(key, value);\n\t  this.size = data.size;\n\t  return this;\n\t}\n\n\t/**\n\t * Creates a stack cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction Stack(entries) {\n\t  var data = this.__data__ = new ListCache(entries);\n\t  this.size = data.size;\n\t}\n\n\t// Add methods to `Stack`.\n\tStack.prototype.clear = stackClear;\n\tStack.prototype['delete'] = stackDelete;\n\tStack.prototype.get = stackGet;\n\tStack.prototype.has = stackHas;\n\tStack.prototype.set = stackSet;\n\n\t/**\n\t * A specialized version of `_.some` for arrays without support for iteratee\n\t * shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} predicate The function invoked per iteration.\n\t * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t *  else `false`.\n\t */\n\tfunction arraySome(array, predicate) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\n\t  while (++index < length) {\n\t    if (predicate(array[index], index, array)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG$5 = 1,\n\t    COMPARE_UNORDERED_FLAG$3 = 2;\n\n\t/**\n\t * A specialized version of `baseIsEqualDeep` for arrays with support for\n\t * partial deep comparisons.\n\t *\n\t * @private\n\t * @param {Array} array The array to compare.\n\t * @param {Array} other The other array to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} stack Tracks traversed `array` and `other` objects.\n\t * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n\t */\n\tfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n\t  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,\n\t      arrLength = array.length,\n\t      othLength = other.length;\n\n\t  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n\t    return false;\n\t  }\n\t  // Check that cyclic values are equal.\n\t  var arrStacked = stack.get(array);\n\t  var othStacked = stack.get(other);\n\t  if (arrStacked && othStacked) {\n\t    return arrStacked == other && othStacked == array;\n\t  }\n\t  var index = -1,\n\t      result = true,\n\t      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;\n\n\t  stack.set(array, other);\n\t  stack.set(other, array);\n\n\t  // Ignore non-index properties.\n\t  while (++index < arrLength) {\n\t    var arrValue = array[index],\n\t        othValue = other[index];\n\n\t    if (customizer) {\n\t      var compared = isPartial\n\t        ? customizer(othValue, arrValue, index, other, array, stack)\n\t        : customizer(arrValue, othValue, index, array, other, stack);\n\t    }\n\t    if (compared !== undefined) {\n\t      if (compared) {\n\t        continue;\n\t      }\n\t      result = false;\n\t      break;\n\t    }\n\t    // Recursively compare arrays (susceptible to call stack limits).\n\t    if (seen) {\n\t      if (!arraySome(other, function(othValue, othIndex) {\n\t            if (!cacheHas(seen, othIndex) &&\n\t                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n\t              return seen.push(othIndex);\n\t            }\n\t          })) {\n\t        result = false;\n\t        break;\n\t      }\n\t    } else if (!(\n\t          arrValue === othValue ||\n\t            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n\t        )) {\n\t      result = false;\n\t      break;\n\t    }\n\t  }\n\t  stack['delete'](array);\n\t  stack['delete'](other);\n\t  return result;\n\t}\n\n\t/** Built-in value references. */\n\tvar Uint8Array$1 = root.Uint8Array;\n\n\t/**\n\t * Converts `map` to its key-value pairs.\n\t *\n\t * @private\n\t * @param {Object} map The map to convert.\n\t * @returns {Array} Returns the key-value pairs.\n\t */\n\tfunction mapToArray(map) {\n\t  var index = -1,\n\t      result = Array(map.size);\n\n\t  map.forEach(function(value, key) {\n\t    result[++index] = [key, value];\n\t  });\n\t  return result;\n\t}\n\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG$4 = 1,\n\t    COMPARE_UNORDERED_FLAG$2 = 2;\n\n\t/** `Object#toString` result references. */\n\tvar boolTag$3 = '[object Boolean]',\n\t    dateTag$3 = '[object Date]',\n\t    errorTag$2 = '[object Error]',\n\t    mapTag$6 = '[object Map]',\n\t    numberTag$3 = '[object Number]',\n\t    regexpTag$3 = '[object RegExp]',\n\t    setTag$6 = '[object Set]',\n\t    stringTag$3 = '[object String]',\n\t    symbolTag$2 = '[object Symbol]';\n\n\tvar arrayBufferTag$3 = '[object ArrayBuffer]',\n\t    dataViewTag$4 = '[object DataView]';\n\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,\n\t    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;\n\n\t/**\n\t * A specialized version of `baseIsEqualDeep` for comparing objects of\n\t * the same `toStringTag`.\n\t *\n\t * **Note:** This function only supports comparing values with tags of\n\t * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t *\n\t * @private\n\t * @param {Object} object The object to compare.\n\t * @param {Object} other The other object to compare.\n\t * @param {string} tag The `toStringTag` of the objects to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} stack Tracks traversed `object` and `other` objects.\n\t * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t */\n\tfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n\t  switch (tag) {\n\t    case dataViewTag$4:\n\t      if ((object.byteLength != other.byteLength) ||\n\t          (object.byteOffset != other.byteOffset)) {\n\t        return false;\n\t      }\n\t      object = object.buffer;\n\t      other = other.buffer;\n\n\t    case arrayBufferTag$3:\n\t      if ((object.byteLength != other.byteLength) ||\n\t          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n\t        return false;\n\t      }\n\t      return true;\n\n\t    case boolTag$3:\n\t    case dateTag$3:\n\t    case numberTag$3:\n\t      // Coerce booleans to `1` or `0` and dates to milliseconds.\n\t      // Invalid dates are coerced to `NaN`.\n\t      return eq(+object, +other);\n\n\t    case errorTag$2:\n\t      return object.name == other.name && object.message == other.message;\n\n\t    case regexpTag$3:\n\t    case stringTag$3:\n\t      // Coerce regexes to strings and treat strings, primitives and objects,\n\t      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n\t      // for more details.\n\t      return object == (other + '');\n\n\t    case mapTag$6:\n\t      var convert = mapToArray;\n\n\t    case setTag$6:\n\t      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n\t      convert || (convert = setToArray);\n\n\t      if (object.size != other.size && !isPartial) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      var stacked = stack.get(object);\n\t      if (stacked) {\n\t        return stacked == other;\n\t      }\n\t      bitmask |= COMPARE_UNORDERED_FLAG$2;\n\n\t      // Recursively compare objects (susceptible to call stack limits).\n\t      stack.set(object, other);\n\t      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n\t      stack['delete'](object);\n\t      return result;\n\n\t    case symbolTag$2:\n\t      if (symbolValueOf$1) {\n\t        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);\n\t      }\n\t  }\n\t  return false;\n\t}\n\n\t/**\n\t * Appends the elements of `values` to `array`.\n\t *\n\t * @private\n\t * @param {Array} array The array to modify.\n\t * @param {Array} values The values to append.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction arrayPush(array, values) {\n\t  var index = -1,\n\t      length = values.length,\n\t      offset = array.length;\n\n\t  while (++index < length) {\n\t    array[offset + index] = values[index];\n\t  }\n\t  return array;\n\t}\n\n\t/**\n\t * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n\t * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n\t * symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Function} keysFunc The function to get the keys of `object`.\n\t * @param {Function} symbolsFunc The function to get the symbols of `object`.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n\t  var result = keysFunc(object);\n\t  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n\t}\n\n\t/**\n\t * A specialized version of `_.filter` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} predicate The function invoked per iteration.\n\t * @returns {Array} Returns the new filtered array.\n\t */\n\tfunction arrayFilter(array, predicate) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length,\n\t      resIndex = 0,\n\t      result = [];\n\n\t  while (++index < length) {\n\t    var value = array[index];\n\t    if (predicate(value, index, array)) {\n\t      result[resIndex++] = value;\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * This method returns a new empty array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.13.0\n\t * @category Util\n\t * @returns {Array} Returns the new empty array.\n\t * @example\n\t *\n\t * var arrays = _.times(2, _.stubArray);\n\t *\n\t * console.log(arrays);\n\t * // => [[], []]\n\t *\n\t * console.log(arrays[0] === arrays[1]);\n\t * // => false\n\t */\n\tfunction stubArray() {\n\t  return [];\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$9 = Object.prototype;\n\n\t/** Built-in value references. */\n\tvar propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeGetSymbols$1 = Object.getOwnPropertySymbols;\n\n\t/**\n\t * Creates an array of the own enumerable symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of symbols.\n\t */\n\tvar getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  object = Object(object);\n\t  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {\n\t    return propertyIsEnumerable$1.call(object, symbol);\n\t  });\n\t};\n\n\t/**\n\t * The base implementation of `_.times` without support for iteratee shorthands\n\t * or max array length checks.\n\t *\n\t * @private\n\t * @param {number} n The number of times to invoke `iteratee`.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the array of results.\n\t */\n\tfunction baseTimes(n, iteratee) {\n\t  var index = -1,\n\t      result = Array(n);\n\n\t  while (++index < n) {\n\t    result[index] = iteratee(index);\n\t  }\n\t  return result;\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar argsTag$3 = '[object Arguments]';\n\n\t/**\n\t * The base implementation of `_.isArguments`.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t */\n\tfunction baseIsArguments(value) {\n\t  return isObjectLike(value) && baseGetTag(value) == argsTag$3;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$8 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n\n\t/** Built-in value references. */\n\tvar propertyIsEnumerable = objectProto$8.propertyIsEnumerable;\n\n\t/**\n\t * Checks if `value` is likely an `arguments` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t *  else `false`.\n\t * @example\n\t *\n\t * _.isArguments(function() { return arguments; }());\n\t * // => true\n\t *\n\t * _.isArguments([1, 2, 3]);\n\t * // => false\n\t */\n\tvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n\t  return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') &&\n\t    !propertyIsEnumerable.call(value, 'callee');\n\t};\n\n\t/**\n\t * This method returns `false`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.13.0\n\t * @category Util\n\t * @returns {boolean} Returns `false`.\n\t * @example\n\t *\n\t * _.times(2, _.stubFalse);\n\t * // => [false, false]\n\t */\n\tfunction stubFalse() {\n\t  return false;\n\t}\n\n\t/** Detect free variable `exports`. */\n\tvar freeExports$2 =  true && exports && !exports.nodeType && exports;\n\n\t/** Detect free variable `module`. */\n\tvar freeModule$2 = freeExports$2 && \"object\" == 'object' && module && !module.nodeType && module;\n\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;\n\n\t/** Built-in value references. */\n\tvar Buffer$2 = moduleExports$2 ? root.Buffer : undefined;\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : undefined;\n\n\t/**\n\t * Checks if `value` is a buffer.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t * @example\n\t *\n\t * _.isBuffer(new Buffer(2));\n\t * // => true\n\t *\n\t * _.isBuffer(new Uint8Array(2));\n\t * // => false\n\t */\n\tvar isBuffer = nativeIsBuffer || stubFalse;\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER = 9007199254740991;\n\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This method is loosely based on\n\t * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t * @example\n\t *\n\t * _.isLength(3);\n\t * // => true\n\t *\n\t * _.isLength(Number.MIN_VALUE);\n\t * // => false\n\t *\n\t * _.isLength(Infinity);\n\t * // => false\n\t *\n\t * _.isLength('3');\n\t * // => false\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' &&\n\t    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar argsTag$2 = '[object Arguments]',\n\t    arrayTag$2 = '[object Array]',\n\t    boolTag$2 = '[object Boolean]',\n\t    dateTag$2 = '[object Date]',\n\t    errorTag$1 = '[object Error]',\n\t    funcTag$1 = '[object Function]',\n\t    mapTag$5 = '[object Map]',\n\t    numberTag$2 = '[object Number]',\n\t    objectTag$3 = '[object Object]',\n\t    regexpTag$2 = '[object RegExp]',\n\t    setTag$5 = '[object Set]',\n\t    stringTag$2 = '[object String]',\n\t    weakMapTag$2 = '[object WeakMap]';\n\n\tvar arrayBufferTag$2 = '[object ArrayBuffer]',\n\t    dataViewTag$3 = '[object DataView]',\n\t    float32Tag$2 = '[object Float32Array]',\n\t    float64Tag$2 = '[object Float64Array]',\n\t    int8Tag$2 = '[object Int8Array]',\n\t    int16Tag$2 = '[object Int16Array]',\n\t    int32Tag$2 = '[object Int32Array]',\n\t    uint8Tag$2 = '[object Uint8Array]',\n\t    uint8ClampedTag$2 = '[object Uint8ClampedArray]',\n\t    uint16Tag$2 = '[object Uint16Array]',\n\t    uint32Tag$2 = '[object Uint32Array]';\n\n\t/** Used to identify `toStringTag` values of typed arrays. */\n\tvar typedArrayTags = {};\n\ttypedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =\n\ttypedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =\n\ttypedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =\n\ttypedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =\n\ttypedArrayTags[uint32Tag$2] = true;\n\ttypedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =\n\ttypedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =\n\ttypedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =\n\ttypedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =\n\ttypedArrayTags[mapTag$5] = typedArrayTags[numberTag$2] =\n\ttypedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] =\n\ttypedArrayTags[setTag$5] = typedArrayTags[stringTag$2] =\n\ttypedArrayTags[weakMapTag$2] = false;\n\n\t/**\n\t * The base implementation of `_.isTypedArray` without Node.js optimizations.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t */\n\tfunction baseIsTypedArray(value) {\n\t  return isObjectLike(value) &&\n\t    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n\t}\n\n\t/**\n\t * The base implementation of `_.unary` without support for storing metadata.\n\t *\n\t * @private\n\t * @param {Function} func The function to cap arguments for.\n\t * @returns {Function} Returns the new capped function.\n\t */\n\tfunction baseUnary(func) {\n\t  return function(value) {\n\t    return func(value);\n\t  };\n\t}\n\n\t/** Detect free variable `exports`. */\n\tvar freeExports$1 =  true && exports && !exports.nodeType && exports;\n\n\t/** Detect free variable `module`. */\n\tvar freeModule$1 = freeExports$1 && \"object\" == 'object' && module && !module.nodeType && module;\n\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n\t/** Detect free variable `process` from Node.js. */\n\tvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n\t/** Used to access faster Node.js helpers. */\n\tvar nodeUtil = (function() {\n\t  try {\n\t    // Use `util.types` for Node.js 10+.\n\t    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;\n\n\t    if (types) {\n\t      return types;\n\t    }\n\n\t    // Legacy `process.binding('util')` for Node.js < 10.\n\t    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n\t  } catch (e) {}\n\t}());\n\n\t/* Node.js helper references. */\n\tvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n\t/**\n\t * Checks if `value` is classified as a typed array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t * @example\n\t *\n\t * _.isTypedArray(new Uint8Array);\n\t * // => true\n\t *\n\t * _.isTypedArray([]);\n\t * // => false\n\t */\n\tvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n\t/** Used for built-in method references. */\n\tvar objectProto$7 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$6 = objectProto$7.hasOwnProperty;\n\n\t/**\n\t * Creates an array of the enumerable property names of the array-like `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @param {boolean} inherited Specify returning inherited property names.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction arrayLikeKeys(value, inherited) {\n\t  var isArr = isArray(value),\n\t      isArg = !isArr && isArguments(value),\n\t      isBuff = !isArr && !isArg && isBuffer(value),\n\t      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n\t      skipIndexes = isArr || isArg || isBuff || isType,\n\t      result = skipIndexes ? baseTimes(value.length, String) : [],\n\t      length = result.length;\n\n\t  for (var key in value) {\n\t    if ((inherited || hasOwnProperty$6.call(value, key)) &&\n\t        !(skipIndexes && (\n\t           // Safari 9 has enumerable `arguments.length` in strict mode.\n\t           key == 'length' ||\n\t           // Node.js 0.10 has enumerable non-index properties on buffers.\n\t           (isBuff && (key == 'offset' || key == 'parent')) ||\n\t           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n\t           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n\t           // Skip index properties.\n\t           isIndex(key, length)\n\t        ))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$6 = Object.prototype;\n\n\t/**\n\t * Checks if `value` is likely a prototype object.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n\t */\n\tfunction isPrototype(value) {\n\t  var Ctor = value && value.constructor,\n\t      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;\n\n\t  return value === proto;\n\t}\n\n\t/**\n\t * Creates a unary function that invokes `func` with its argument transformed.\n\t *\n\t * @private\n\t * @param {Function} func The function to wrap.\n\t * @param {Function} transform The argument transform.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction overArg(func, transform) {\n\t  return function(arg) {\n\t    return func(transform(arg));\n\t  };\n\t}\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeKeys = overArg(Object.keys, Object);\n\n\t/** Used for built-in method references. */\n\tvar objectProto$5 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$5 = objectProto$5.hasOwnProperty;\n\n\t/**\n\t * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction baseKeys(object) {\n\t  if (!isPrototype(object)) {\n\t    return nativeKeys(object);\n\t  }\n\t  var result = [];\n\t  for (var key in Object(object)) {\n\t    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Checks if `value` is array-like. A value is considered array-like if it's\n\t * not a function and has a `value.length` that's an integer greater than or\n\t * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t * @example\n\t *\n\t * _.isArrayLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArrayLike(document.body.children);\n\t * // => true\n\t *\n\t * _.isArrayLike('abc');\n\t * // => true\n\t *\n\t * _.isArrayLike(_.noop);\n\t * // => false\n\t */\n\tfunction isArrayLike(value) {\n\t  return value != null && isLength(value.length) && !isFunction$1(value);\n\t}\n\n\t/**\n\t * Creates an array of the own enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects. See the\n\t * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t * for more details.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keys(new Foo);\n\t * // => ['a', 'b'] (iteration order is not guaranteed)\n\t *\n\t * _.keys('hi');\n\t * // => ['0', '1']\n\t */\n\tfunction keys(object) {\n\t  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n\t}\n\n\t/**\n\t * Creates an array of own enumerable property names and symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction getAllKeys(object) {\n\t  return baseGetAllKeys(object, keys, getSymbols);\n\t}\n\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG$3 = 1;\n\n\t/** Used for built-in method references. */\n\tvar objectProto$4 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n\n\t/**\n\t * A specialized version of `baseIsEqualDeep` for objects with support for\n\t * partial deep comparisons.\n\t *\n\t * @private\n\t * @param {Object} object The object to compare.\n\t * @param {Object} other The other object to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} stack Tracks traversed `object` and `other` objects.\n\t * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t */\n\tfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n\t  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,\n\t      objProps = getAllKeys(object),\n\t      objLength = objProps.length,\n\t      othProps = getAllKeys(other),\n\t      othLength = othProps.length;\n\n\t  if (objLength != othLength && !isPartial) {\n\t    return false;\n\t  }\n\t  var index = objLength;\n\t  while (index--) {\n\t    var key = objProps[index];\n\t    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {\n\t      return false;\n\t    }\n\t  }\n\t  // Check that cyclic values are equal.\n\t  var objStacked = stack.get(object);\n\t  var othStacked = stack.get(other);\n\t  if (objStacked && othStacked) {\n\t    return objStacked == other && othStacked == object;\n\t  }\n\t  var result = true;\n\t  stack.set(object, other);\n\t  stack.set(other, object);\n\n\t  var skipCtor = isPartial;\n\t  while (++index < objLength) {\n\t    key = objProps[index];\n\t    var objValue = object[key],\n\t        othValue = other[key];\n\n\t    if (customizer) {\n\t      var compared = isPartial\n\t        ? customizer(othValue, objValue, key, other, object, stack)\n\t        : customizer(objValue, othValue, key, object, other, stack);\n\t    }\n\t    // Recursively compare objects (susceptible to call stack limits).\n\t    if (!(compared === undefined\n\t          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n\t          : compared\n\t        )) {\n\t      result = false;\n\t      break;\n\t    }\n\t    skipCtor || (skipCtor = key == 'constructor');\n\t  }\n\t  if (result && !skipCtor) {\n\t    var objCtor = object.constructor,\n\t        othCtor = other.constructor;\n\n\t    // Non `Object` object instances with different constructors are not equal.\n\t    if (objCtor != othCtor &&\n\t        ('constructor' in object && 'constructor' in other) &&\n\t        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n\t          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n\t      result = false;\n\t    }\n\t  }\n\t  stack['delete'](object);\n\t  stack['delete'](other);\n\t  return result;\n\t}\n\n\t/* Built-in method references that are verified to be native. */\n\tvar DataView$1 = getNative(root, 'DataView');\n\n\t/* Built-in method references that are verified to be native. */\n\tvar Promise$1 = getNative(root, 'Promise');\n\n\t/* Built-in method references that are verified to be native. */\n\tvar WeakMap$1 = getNative(root, 'WeakMap');\n\n\t/** `Object#toString` result references. */\n\tvar mapTag$4 = '[object Map]',\n\t    objectTag$2 = '[object Object]',\n\t    promiseTag = '[object Promise]',\n\t    setTag$4 = '[object Set]',\n\t    weakMapTag$1 = '[object WeakMap]';\n\n\tvar dataViewTag$2 = '[object DataView]';\n\n\t/** Used to detect maps, sets, and weakmaps. */\n\tvar dataViewCtorString = toSource(DataView$1),\n\t    mapCtorString = toSource(Map$1),\n\t    promiseCtorString = toSource(Promise$1),\n\t    setCtorString = toSource(Set$1),\n\t    weakMapCtorString = toSource(WeakMap$1);\n\n\t/**\n\t * Gets the `toStringTag` of `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */\n\tvar getTag = baseGetTag;\n\n\t// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n\tif ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2) ||\n\t    (Map$1 && getTag(new Map$1) != mapTag$4) ||\n\t    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||\n\t    (Set$1 && getTag(new Set$1) != setTag$4) ||\n\t    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1)) {\n\t  getTag = function(value) {\n\t    var result = baseGetTag(value),\n\t        Ctor = result == objectTag$2 ? value.constructor : undefined,\n\t        ctorString = Ctor ? toSource(Ctor) : '';\n\n\t    if (ctorString) {\n\t      switch (ctorString) {\n\t        case dataViewCtorString: return dataViewTag$2;\n\t        case mapCtorString: return mapTag$4;\n\t        case promiseCtorString: return promiseTag;\n\t        case setCtorString: return setTag$4;\n\t        case weakMapCtorString: return weakMapTag$1;\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t}\n\n\tvar getTag$1 = getTag;\n\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG$2 = 1;\n\n\t/** `Object#toString` result references. */\n\tvar argsTag$1 = '[object Arguments]',\n\t    arrayTag$1 = '[object Array]',\n\t    objectTag$1 = '[object Object]';\n\n\t/** Used for built-in method references. */\n\tvar objectProto$3 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n\t/**\n\t * A specialized version of `baseIsEqual` for arrays and objects which performs\n\t * deep comparisons and tracks traversed objects enabling objects with circular\n\t * references to be compared.\n\t *\n\t * @private\n\t * @param {Object} object The object to compare.\n\t * @param {Object} other The other object to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n\t * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t */\n\tfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n\t  var objIsArr = isArray(object),\n\t      othIsArr = isArray(other),\n\t      objTag = objIsArr ? arrayTag$1 : getTag$1(object),\n\t      othTag = othIsArr ? arrayTag$1 : getTag$1(other);\n\n\t  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;\n\t  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;\n\n\t  var objIsObj = objTag == objectTag$1,\n\t      othIsObj = othTag == objectTag$1,\n\t      isSameTag = objTag == othTag;\n\n\t  if (isSameTag && isBuffer(object)) {\n\t    if (!isBuffer(other)) {\n\t      return false;\n\t    }\n\t    objIsArr = true;\n\t    objIsObj = false;\n\t  }\n\t  if (isSameTag && !objIsObj) {\n\t    stack || (stack = new Stack);\n\t    return (objIsArr || isTypedArray(object))\n\t      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n\t      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n\t  }\n\t  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n\t    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, '__wrapped__'),\n\t        othIsWrapped = othIsObj && hasOwnProperty$3.call(other, '__wrapped__');\n\n\t    if (objIsWrapped || othIsWrapped) {\n\t      var objUnwrapped = objIsWrapped ? object.value() : object,\n\t          othUnwrapped = othIsWrapped ? other.value() : other;\n\n\t      stack || (stack = new Stack);\n\t      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n\t    }\n\t  }\n\t  if (!isSameTag) {\n\t    return false;\n\t  }\n\t  stack || (stack = new Stack);\n\t  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n\t}\n\n\t/**\n\t * The base implementation of `_.isEqual` which supports partial comparisons\n\t * and tracks traversed objects.\n\t *\n\t * @private\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @param {boolean} bitmask The bitmask flags.\n\t *  1 - Unordered comparison\n\t *  2 - Partial comparison\n\t * @param {Function} [customizer] The function to customize comparisons.\n\t * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t */\n\tfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n\t  if (value === other) {\n\t    return true;\n\t  }\n\t  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n\t    return value !== value && other !== other;\n\t  }\n\t  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n\t}\n\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG$1 = 1,\n\t    COMPARE_UNORDERED_FLAG$1 = 2;\n\n\t/**\n\t * The base implementation of `_.isMatch` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Object} object The object to inspect.\n\t * @param {Object} source The object of property values to match.\n\t * @param {Array} matchData The property names, values, and compare flags to match.\n\t * @param {Function} [customizer] The function to customize comparisons.\n\t * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t */\n\tfunction baseIsMatch(object, source, matchData, customizer) {\n\t  var index = matchData.length,\n\t      length = index,\n\t      noCustomizer = !customizer;\n\n\t  if (object == null) {\n\t    return !length;\n\t  }\n\t  object = Object(object);\n\t  while (index--) {\n\t    var data = matchData[index];\n\t    if ((noCustomizer && data[2])\n\t          ? data[1] !== object[data[0]]\n\t          : !(data[0] in object)\n\t        ) {\n\t      return false;\n\t    }\n\t  }\n\t  while (++index < length) {\n\t    data = matchData[index];\n\t    var key = data[0],\n\t        objValue = object[key],\n\t        srcValue = data[1];\n\n\t    if (noCustomizer && data[2]) {\n\t      if (objValue === undefined && !(key in object)) {\n\t        return false;\n\t      }\n\t    } else {\n\t      var stack = new Stack;\n\t      if (customizer) {\n\t        var result = customizer(objValue, srcValue, key, object, source, stack);\n\t      }\n\t      if (!(result === undefined\n\t            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)\n\t            : result\n\t          )) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\t/**\n\t * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` if suitable for strict\n\t *  equality comparisons, else `false`.\n\t */\n\tfunction isStrictComparable(value) {\n\t  return value === value && !isObject$1(value);\n\t}\n\n\t/**\n\t * Gets the property names, values, and compare flags of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the match data of `object`.\n\t */\n\tfunction getMatchData(object) {\n\t  var result = keys(object),\n\t      length = result.length;\n\n\t  while (length--) {\n\t    var key = result[length],\n\t        value = object[key];\n\n\t    result[length] = [key, value, isStrictComparable(value)];\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * A specialized version of `matchesProperty` for source values suitable\n\t * for strict equality comparisons, i.e. `===`.\n\t *\n\t * @private\n\t * @param {string} key The key of the property to get.\n\t * @param {*} srcValue The value to match.\n\t * @returns {Function} Returns the new spec function.\n\t */\n\tfunction matchesStrictComparable(key, srcValue) {\n\t  return function(object) {\n\t    if (object == null) {\n\t      return false;\n\t    }\n\t    return object[key] === srcValue &&\n\t      (srcValue !== undefined || (key in Object(object)));\n\t  };\n\t}\n\n\t/**\n\t * The base implementation of `_.matches` which doesn't clone `source`.\n\t *\n\t * @private\n\t * @param {Object} source The object of property values to match.\n\t * @returns {Function} Returns the new spec function.\n\t */\n\tfunction baseMatches(source) {\n\t  var matchData = getMatchData(source);\n\t  if (matchData.length == 1 && matchData[0][2]) {\n\t    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n\t  }\n\t  return function(object) {\n\t    return object === source || baseIsMatch(object, source, matchData);\n\t  };\n\t}\n\n\t/**\n\t * The base implementation of `_.hasIn` without support for deep paths.\n\t *\n\t * @private\n\t * @param {Object} [object] The object to query.\n\t * @param {Array|string} key The key to check.\n\t * @returns {boolean} Returns `true` if `key` exists, else `false`.\n\t */\n\tfunction baseHasIn(object, key) {\n\t  return object != null && key in Object(object);\n\t}\n\n\t/**\n\t * Checks if `path` exists on `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path to check.\n\t * @param {Function} hasFunc The function to check properties.\n\t * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t */\n\tfunction hasPath(object, path, hasFunc) {\n\t  path = castPath(path, object);\n\n\t  var index = -1,\n\t      length = path.length,\n\t      result = false;\n\n\t  while (++index < length) {\n\t    var key = toKey(path[index]);\n\t    if (!(result = object != null && hasFunc(object, key))) {\n\t      break;\n\t    }\n\t    object = object[key];\n\t  }\n\t  if (result || ++index != length) {\n\t    return result;\n\t  }\n\t  length = object == null ? 0 : object.length;\n\t  return !!length && isLength(length) && isIndex(key, length) &&\n\t    (isArray(object) || isArguments(object));\n\t}\n\n\t/**\n\t * Checks if `path` is a direct or inherited property of `object`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path to check.\n\t * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t * @example\n\t *\n\t * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n\t *\n\t * _.hasIn(object, 'a');\n\t * // => true\n\t *\n\t * _.hasIn(object, 'a.b');\n\t * // => true\n\t *\n\t * _.hasIn(object, ['a', 'b']);\n\t * // => true\n\t *\n\t * _.hasIn(object, 'b');\n\t * // => false\n\t */\n\tfunction hasIn(object, path) {\n\t  return object != null && hasPath(object, path, baseHasIn);\n\t}\n\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG = 1,\n\t    COMPARE_UNORDERED_FLAG = 2;\n\n\t/**\n\t * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n\t *\n\t * @private\n\t * @param {string} path The path of the property to get.\n\t * @param {*} srcValue The value to match.\n\t * @returns {Function} Returns the new spec function.\n\t */\n\tfunction baseMatchesProperty(path, srcValue) {\n\t  if (isKey(path) && isStrictComparable(srcValue)) {\n\t    return matchesStrictComparable(toKey(path), srcValue);\n\t  }\n\t  return function(object) {\n\t    var objValue = get(object, path);\n\t    return (objValue === undefined && objValue === srcValue)\n\t      ? hasIn(object, path)\n\t      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n\t  };\n\t}\n\n\t/**\n\t * This method returns the first argument it receives.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Util\n\t * @param {*} value Any value.\n\t * @returns {*} Returns `value`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t *\n\t * console.log(_.identity(object) === object);\n\t * // => true\n\t */\n\tfunction identity(value) {\n\t  return value;\n\t}\n\n\t/**\n\t * The base implementation of `_.property` without support for deep paths.\n\t *\n\t * @private\n\t * @param {string} key The key of the property to get.\n\t * @returns {Function} Returns the new accessor function.\n\t */\n\tfunction baseProperty(key) {\n\t  return function(object) {\n\t    return object == null ? undefined : object[key];\n\t  };\n\t}\n\n\t/**\n\t * A specialized version of `baseProperty` which supports deep paths.\n\t *\n\t * @private\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {Function} Returns the new accessor function.\n\t */\n\tfunction basePropertyDeep(path) {\n\t  return function(object) {\n\t    return baseGet(object, path);\n\t  };\n\t}\n\n\t/**\n\t * Creates a function that returns the value at `path` of a given object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Util\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {Function} Returns the new accessor function.\n\t * @example\n\t *\n\t * var objects = [\n\t *   { 'a': { 'b': 2 } },\n\t *   { 'a': { 'b': 1 } }\n\t * ];\n\t *\n\t * _.map(objects, _.property('a.b'));\n\t * // => [2, 1]\n\t *\n\t * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n\t * // => [1, 2]\n\t */\n\tfunction property(path) {\n\t  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n\t}\n\n\t/**\n\t * The base implementation of `_.iteratee`.\n\t *\n\t * @private\n\t * @param {*} [value=_.identity] The value to convert to an iteratee.\n\t * @returns {Function} Returns the iteratee.\n\t */\n\tfunction baseIteratee(value) {\n\t  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n\t  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n\t  if (typeof value == 'function') {\n\t    return value;\n\t  }\n\t  if (value == null) {\n\t    return identity;\n\t  }\n\t  if (typeof value == 'object') {\n\t    return isArray(value)\n\t      ? baseMatchesProperty(value[0], value[1])\n\t      : baseMatches(value);\n\t  }\n\t  return property(value);\n\t}\n\n\t/**\n\t * Creates a `_.find` or `_.findLast` function.\n\t *\n\t * @private\n\t * @param {Function} findIndexFunc The function to find the collection index.\n\t * @returns {Function} Returns the new find function.\n\t */\n\tfunction createFind(findIndexFunc) {\n\t  return function(collection, predicate, fromIndex) {\n\t    var iterable = Object(collection);\n\t    if (!isArrayLike(collection)) {\n\t      var iteratee = baseIteratee(predicate);\n\t      collection = keys(collection);\n\t      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n\t    }\n\t    var index = findIndexFunc(collection, predicate, fromIndex);\n\t    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n\t  };\n\t}\n\n\t/** Used to match a single whitespace character. */\n\tvar reWhitespace = /\\s/;\n\n\t/**\n\t * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n\t * character of `string`.\n\t *\n\t * @private\n\t * @param {string} string The string to inspect.\n\t * @returns {number} Returns the index of the last non-whitespace character.\n\t */\n\tfunction trimmedEndIndex(string) {\n\t  var index = string.length;\n\n\t  while (index-- && reWhitespace.test(string.charAt(index))) {}\n\t  return index;\n\t}\n\n\t/** Used to match leading whitespace. */\n\tvar reTrimStart = /^\\s+/;\n\n\t/**\n\t * The base implementation of `_.trim`.\n\t *\n\t * @private\n\t * @param {string} string The string to trim.\n\t * @returns {string} Returns the trimmed string.\n\t */\n\tfunction baseTrim(string) {\n\t  return string\n\t    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n\t    : string;\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar NAN = 0 / 0;\n\n\t/** Used to detect bad signed hexadecimal string values. */\n\tvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n\t/** Used to detect binary string values. */\n\tvar reIsBinary = /^0b[01]+$/i;\n\n\t/** Used to detect octal string values. */\n\tvar reIsOctal = /^0o[0-7]+$/i;\n\n\t/** Built-in method references without a dependency on `root`. */\n\tvar freeParseInt = parseInt;\n\n\t/**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3.2);\n\t * // => 3.2\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3.2');\n\t * // => 3.2\n\t */\n\tfunction toNumber(value) {\n\t  if (typeof value == 'number') {\n\t    return value;\n\t  }\n\t  if (isSymbol(value)) {\n\t    return NAN;\n\t  }\n\t  if (isObject$1(value)) {\n\t    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n\t    value = isObject$1(other) ? (other + '') : other;\n\t  }\n\t  if (typeof value != 'string') {\n\t    return value === 0 ? value : +value;\n\t  }\n\t  value = baseTrim(value);\n\t  var isBinary = reIsBinary.test(value);\n\t  return (isBinary || reIsOctal.test(value))\n\t    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n\t    : (reIsBadHex.test(value) ? NAN : +value);\n\t}\n\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY = 1 / 0,\n\t    MAX_INTEGER = 1.7976931348623157e+308;\n\n\t/**\n\t * Converts `value` to a finite number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.12.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {number} Returns the converted number.\n\t * @example\n\t *\n\t * _.toFinite(3.2);\n\t * // => 3.2\n\t *\n\t * _.toFinite(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toFinite(Infinity);\n\t * // => 1.7976931348623157e+308\n\t *\n\t * _.toFinite('3.2');\n\t * // => 3.2\n\t */\n\tfunction toFinite(value) {\n\t  if (!value) {\n\t    return value === 0 ? value : 0;\n\t  }\n\t  value = toNumber(value);\n\t  if (value === INFINITY || value === -INFINITY) {\n\t    var sign = (value < 0 ? -1 : 1);\n\t    return sign * MAX_INTEGER;\n\t  }\n\t  return value === value ? value : 0;\n\t}\n\n\t/**\n\t * Converts `value` to an integer.\n\t *\n\t * **Note:** This method is loosely based on\n\t * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {number} Returns the converted integer.\n\t * @example\n\t *\n\t * _.toInteger(3.2);\n\t * // => 3\n\t *\n\t * _.toInteger(Number.MIN_VALUE);\n\t * // => 0\n\t *\n\t * _.toInteger(Infinity);\n\t * // => 1.7976931348623157e+308\n\t *\n\t * _.toInteger('3.2');\n\t * // => 3\n\t */\n\tfunction toInteger(value) {\n\t  var result = toFinite(value),\n\t      remainder = result % 1;\n\n\t  return result === result ? (remainder ? result - remainder : result) : 0;\n\t}\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeMax = Math.max;\n\n\t/**\n\t * This method is like `_.find` except that it returns the index of the first\n\t * element `predicate` returns truthy for instead of the element itself.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 1.1.0\n\t * @category Array\n\t * @param {Array} array The array to inspect.\n\t * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t * @param {number} [fromIndex=0] The index to search from.\n\t * @returns {number} Returns the index of the found element, else `-1`.\n\t * @example\n\t *\n\t * var users = [\n\t *   { 'user': 'barney',  'active': false },\n\t *   { 'user': 'fred',    'active': false },\n\t *   { 'user': 'pebbles', 'active': true }\n\t * ];\n\t *\n\t * _.findIndex(users, function(o) { return o.user == 'barney'; });\n\t * // => 0\n\t *\n\t * // The `_.matches` iteratee shorthand.\n\t * _.findIndex(users, { 'user': 'fred', 'active': false });\n\t * // => 1\n\t *\n\t * // The `_.matchesProperty` iteratee shorthand.\n\t * _.findIndex(users, ['active', false]);\n\t * // => 0\n\t *\n\t * // The `_.property` iteratee shorthand.\n\t * _.findIndex(users, 'active');\n\t * // => 2\n\t */\n\tfunction findIndex(array, predicate, fromIndex) {\n\t  var length = array == null ? 0 : array.length;\n\t  if (!length) {\n\t    return -1;\n\t  }\n\t  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n\t  if (index < 0) {\n\t    index = nativeMax(length + index, 0);\n\t  }\n\t  return baseFindIndex(array, baseIteratee(predicate), index);\n\t}\n\n\t/**\n\t * Iterates over elements of `collection`, returning the first element\n\t * `predicate` returns truthy for. The predicate is invoked with three\n\t * arguments: (value, index|key, collection).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Collection\n\t * @param {Array|Object} collection The collection to inspect.\n\t * @param {Function} [predicate=_.identity] The function invoked per iteration.\n\t * @param {number} [fromIndex=0] The index to search from.\n\t * @returns {*} Returns the matched element, else `undefined`.\n\t * @example\n\t *\n\t * var users = [\n\t *   { 'user': 'barney',  'age': 36, 'active': true },\n\t *   { 'user': 'fred',    'age': 40, 'active': false },\n\t *   { 'user': 'pebbles', 'age': 1,  'active': true }\n\t * ];\n\t *\n\t * _.find(users, function(o) { return o.age < 40; });\n\t * // => object for 'barney'\n\t *\n\t * // The `_.matches` iteratee shorthand.\n\t * _.find(users, { 'age': 1, 'active': true });\n\t * // => object for 'pebbles'\n\t *\n\t * // The `_.matchesProperty` iteratee shorthand.\n\t * _.find(users, ['active', false]);\n\t * // => object for 'fred'\n\t *\n\t * // The `_.property` iteratee shorthand.\n\t * _.find(users, 'active');\n\t * // => object for 'barney'\n\t */\n\tvar find = createFind(findIndex);\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeIsFinite = root.isFinite,\n\t    nativeMin = Math.min;\n\n\t/**\n\t * Creates a function like `_.round`.\n\t *\n\t * @private\n\t * @param {string} methodName The name of the `Math` method to use when rounding.\n\t * @returns {Function} Returns the new round function.\n\t */\n\tfunction createRound(methodName) {\n\t  var func = Math[methodName];\n\t  return function(number, precision) {\n\t    number = toNumber(number);\n\t    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n\t    if (precision && nativeIsFinite(number)) {\n\t      // Shift with exponential notation to avoid floating-point issues.\n\t      // See [MDN](https://mdn.io/round#Examples) for more details.\n\t      var pair = (toString(number) + 'e').split('e'),\n\t          value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n\t      pair = (toString(value) + 'e').split('e');\n\t      return +(pair[0] + 'e' + (+pair[1] - precision));\n\t    }\n\t    return func(number);\n\t  };\n\t}\n\n\t/**\n\t * Computes `number` rounded to `precision`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.10.0\n\t * @category Math\n\t * @param {number} number The number to round.\n\t * @param {number} [precision=0] The precision to round to.\n\t * @returns {number} Returns the rounded number.\n\t * @example\n\t *\n\t * _.round(4.006);\n\t * // => 4\n\t *\n\t * _.round(4.006, 2);\n\t * // => 4.01\n\t *\n\t * _.round(4060, -2);\n\t * // => 4100\n\t */\n\tvar round = createRound('round');\n\n\t/**\n\t * A specialized version of `_.forEach` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction arrayEach(array, iteratee) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\n\t  while (++index < length) {\n\t    if (iteratee(array[index], index, array) === false) {\n\t      break;\n\t    }\n\t  }\n\t  return array;\n\t}\n\n\t/**\n\t * Copies properties of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy properties from.\n\t * @param {Array} props The property identifiers to copy.\n\t * @param {Object} [object={}] The object to copy properties to.\n\t * @param {Function} [customizer] The function to customize copied values.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction copyObject(source, props, object, customizer) {\n\t  var isNew = !object;\n\t  object || (object = {});\n\n\t  var index = -1,\n\t      length = props.length;\n\n\t  while (++index < length) {\n\t    var key = props[index];\n\n\t    var newValue = customizer\n\t      ? customizer(object[key], source[key], key, object, source)\n\t      : undefined;\n\n\t    if (newValue === undefined) {\n\t      newValue = source[key];\n\t    }\n\t    if (isNew) {\n\t      baseAssignValue(object, key, newValue);\n\t    } else {\n\t      assignValue(object, key, newValue);\n\t    }\n\t  }\n\t  return object;\n\t}\n\n\t/**\n\t * The base implementation of `_.assign` without support for multiple sources\n\t * or `customizer` functions.\n\t *\n\t * @private\n\t * @param {Object} object The destination object.\n\t * @param {Object} source The source object.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseAssign(object, source) {\n\t  return object && copyObject(source, keys(source), object);\n\t}\n\n\t/**\n\t * This function is like\n\t * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t * except that it includes inherited enumerable properties.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction nativeKeysIn(object) {\n\t  var result = [];\n\t  if (object != null) {\n\t    for (var key in Object(object)) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$2 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n\t/**\n\t * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction baseKeysIn(object) {\n\t  if (!isObject$1(object)) {\n\t    return nativeKeysIn(object);\n\t  }\n\t  var isProto = isPrototype(object),\n\t      result = [];\n\n\t  for (var key in object) {\n\t    if (!(key == 'constructor' && (isProto || !hasOwnProperty$2.call(object, key)))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Creates an array of the own and inherited enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.0.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keysIn(new Foo);\n\t * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t */\n\tfunction keysIn(object) {\n\t  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n\t}\n\n\t/**\n\t * The base implementation of `_.assignIn` without support for multiple sources\n\t * or `customizer` functions.\n\t *\n\t * @private\n\t * @param {Object} object The destination object.\n\t * @param {Object} source The source object.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseAssignIn(object, source) {\n\t  return object && copyObject(source, keysIn(source), object);\n\t}\n\n\t/** Detect free variable `exports`. */\n\tvar freeExports =  true && exports && !exports.nodeType && exports;\n\n\t/** Detect free variable `module`. */\n\tvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n\t/** Built-in value references. */\n\tvar Buffer$1 = moduleExports ? root.Buffer : undefined,\n\t    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;\n\n\t/**\n\t * Creates a clone of  `buffer`.\n\t *\n\t * @private\n\t * @param {Buffer} buffer The buffer to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Buffer} Returns the cloned buffer.\n\t */\n\tfunction cloneBuffer(buffer, isDeep) {\n\t  if (isDeep) {\n\t    return buffer.slice();\n\t  }\n\t  var length = buffer.length,\n\t      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n\t  buffer.copy(result);\n\t  return result;\n\t}\n\n\t/**\n\t * Copies the values of `source` to `array`.\n\t *\n\t * @private\n\t * @param {Array} source The array to copy values from.\n\t * @param {Array} [array=[]] The array to copy values to.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction copyArray(source, array) {\n\t  var index = -1,\n\t      length = source.length;\n\n\t  array || (array = Array(length));\n\t  while (++index < length) {\n\t    array[index] = source[index];\n\t  }\n\t  return array;\n\t}\n\n\t/**\n\t * Copies own symbols of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy symbols from.\n\t * @param {Object} [object={}] The object to copy symbols to.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction copySymbols(source, object) {\n\t  return copyObject(source, getSymbols(source), object);\n\t}\n\n\t/** Built-in value references. */\n\tvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n\t/**\n\t * Creates an array of the own and inherited enumerable symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of symbols.\n\t */\n\tvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n\t  var result = [];\n\t  while (object) {\n\t    arrayPush(result, getSymbols(object));\n\t    object = getPrototype(object);\n\t  }\n\t  return result;\n\t};\n\n\t/**\n\t * Copies own and inherited symbols of `source` to `object`.\n\t *\n\t * @private\n\t * @param {Object} source The object to copy symbols from.\n\t * @param {Object} [object={}] The object to copy symbols to.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction copySymbolsIn(source, object) {\n\t  return copyObject(source, getSymbolsIn(source), object);\n\t}\n\n\t/**\n\t * Creates an array of own and inherited enumerable property names and\n\t * symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction getAllKeysIn(object) {\n\t  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n\t}\n\n\t/** Used for built-in method references. */\n\tvar objectProto$1 = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\n\t/**\n\t * Initializes an array clone.\n\t *\n\t * @private\n\t * @param {Array} array The array to clone.\n\t * @returns {Array} Returns the initialized clone.\n\t */\n\tfunction initCloneArray(array) {\n\t  var length = array.length,\n\t      result = new array.constructor(length);\n\n\t  // Add properties assigned by `RegExp#exec`.\n\t  if (length && typeof array[0] == 'string' && hasOwnProperty$1.call(array, 'index')) {\n\t    result.index = array.index;\n\t    result.input = array.input;\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Creates a clone of `arrayBuffer`.\n\t *\n\t * @private\n\t * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n\t * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t */\n\tfunction cloneArrayBuffer(arrayBuffer) {\n\t  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n\t  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));\n\t  return result;\n\t}\n\n\t/**\n\t * Creates a clone of `dataView`.\n\t *\n\t * @private\n\t * @param {Object} dataView The data view to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the cloned data view.\n\t */\n\tfunction cloneDataView(dataView, isDeep) {\n\t  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n\t  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n\t}\n\n\t/** Used to match `RegExp` flags from their coerced string values. */\n\tvar reFlags = /\\w*$/;\n\n\t/**\n\t * Creates a clone of `regexp`.\n\t *\n\t * @private\n\t * @param {Object} regexp The regexp to clone.\n\t * @returns {Object} Returns the cloned regexp.\n\t */\n\tfunction cloneRegExp(regexp) {\n\t  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n\t  result.lastIndex = regexp.lastIndex;\n\t  return result;\n\t}\n\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n\t    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n\t/**\n\t * Creates a clone of the `symbol` object.\n\t *\n\t * @private\n\t * @param {Object} symbol The symbol object to clone.\n\t * @returns {Object} Returns the cloned symbol object.\n\t */\n\tfunction cloneSymbol(symbol) {\n\t  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n\t}\n\n\t/**\n\t * Creates a clone of `typedArray`.\n\t *\n\t * @private\n\t * @param {Object} typedArray The typed array to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the cloned typed array.\n\t */\n\tfunction cloneTypedArray(typedArray, isDeep) {\n\t  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n\t  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar boolTag$1 = '[object Boolean]',\n\t    dateTag$1 = '[object Date]',\n\t    mapTag$3 = '[object Map]',\n\t    numberTag$1 = '[object Number]',\n\t    regexpTag$1 = '[object RegExp]',\n\t    setTag$3 = '[object Set]',\n\t    stringTag$1 = '[object String]',\n\t    symbolTag$1 = '[object Symbol]';\n\n\tvar arrayBufferTag$1 = '[object ArrayBuffer]',\n\t    dataViewTag$1 = '[object DataView]',\n\t    float32Tag$1 = '[object Float32Array]',\n\t    float64Tag$1 = '[object Float64Array]',\n\t    int8Tag$1 = '[object Int8Array]',\n\t    int16Tag$1 = '[object Int16Array]',\n\t    int32Tag$1 = '[object Int32Array]',\n\t    uint8Tag$1 = '[object Uint8Array]',\n\t    uint8ClampedTag$1 = '[object Uint8ClampedArray]',\n\t    uint16Tag$1 = '[object Uint16Array]',\n\t    uint32Tag$1 = '[object Uint32Array]';\n\n\t/**\n\t * Initializes an object clone based on its `toStringTag`.\n\t *\n\t * **Note:** This function only supports cloning values with tags of\n\t * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n\t *\n\t * @private\n\t * @param {Object} object The object to clone.\n\t * @param {string} tag The `toStringTag` of the object to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Object} Returns the initialized clone.\n\t */\n\tfunction initCloneByTag(object, tag, isDeep) {\n\t  var Ctor = object.constructor;\n\t  switch (tag) {\n\t    case arrayBufferTag$1:\n\t      return cloneArrayBuffer(object);\n\n\t    case boolTag$1:\n\t    case dateTag$1:\n\t      return new Ctor(+object);\n\n\t    case dataViewTag$1:\n\t      return cloneDataView(object, isDeep);\n\n\t    case float32Tag$1: case float64Tag$1:\n\t    case int8Tag$1: case int16Tag$1: case int32Tag$1:\n\t    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:\n\t      return cloneTypedArray(object, isDeep);\n\n\t    case mapTag$3:\n\t      return new Ctor;\n\n\t    case numberTag$1:\n\t    case stringTag$1:\n\t      return new Ctor(object);\n\n\t    case regexpTag$1:\n\t      return cloneRegExp(object);\n\n\t    case setTag$3:\n\t      return new Ctor;\n\n\t    case symbolTag$1:\n\t      return cloneSymbol(object);\n\t  }\n\t}\n\n\t/** Built-in value references. */\n\tvar objectCreate = Object.create;\n\n\t/**\n\t * The base implementation of `_.create` without support for assigning\n\t * properties to the created object.\n\t *\n\t * @private\n\t * @param {Object} proto The object to inherit from.\n\t * @returns {Object} Returns the new object.\n\t */\n\tvar baseCreate = (function() {\n\t  function object() {}\n\t  return function(proto) {\n\t    if (!isObject$1(proto)) {\n\t      return {};\n\t    }\n\t    if (objectCreate) {\n\t      return objectCreate(proto);\n\t    }\n\t    object.prototype = proto;\n\t    var result = new object;\n\t    object.prototype = undefined;\n\t    return result;\n\t  };\n\t}());\n\n\t/**\n\t * Initializes an object clone.\n\t *\n\t * @private\n\t * @param {Object} object The object to clone.\n\t * @returns {Object} Returns the initialized clone.\n\t */\n\tfunction initCloneObject(object) {\n\t  return (typeof object.constructor == 'function' && !isPrototype(object))\n\t    ? baseCreate(getPrototype(object))\n\t    : {};\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar mapTag$2 = '[object Map]';\n\n\t/**\n\t * The base implementation of `_.isMap` without Node.js optimizations.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n\t */\n\tfunction baseIsMap(value) {\n\t  return isObjectLike(value) && getTag$1(value) == mapTag$2;\n\t}\n\n\t/* Node.js helper references. */\n\tvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n\t/**\n\t * Checks if `value` is classified as a `Map` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n\t * @example\n\t *\n\t * _.isMap(new Map);\n\t * // => true\n\t *\n\t * _.isMap(new WeakMap);\n\t * // => false\n\t */\n\tvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n\t/** `Object#toString` result references. */\n\tvar setTag$2 = '[object Set]';\n\n\t/**\n\t * The base implementation of `_.isSet` without Node.js optimizations.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n\t */\n\tfunction baseIsSet(value) {\n\t  return isObjectLike(value) && getTag$1(value) == setTag$2;\n\t}\n\n\t/* Node.js helper references. */\n\tvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n\t/**\n\t * Checks if `value` is classified as a `Set` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n\t * @example\n\t *\n\t * _.isSet(new Set);\n\t * // => true\n\t *\n\t * _.isSet(new WeakSet);\n\t * // => false\n\t */\n\tvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n\t/** Used to compose bitmasks for cloning. */\n\tvar CLONE_DEEP_FLAG$1 = 1,\n\t    CLONE_FLAT_FLAG = 2,\n\t    CLONE_SYMBOLS_FLAG$1 = 4;\n\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]',\n\t    arrayTag = '[object Array]',\n\t    boolTag = '[object Boolean]',\n\t    dateTag = '[object Date]',\n\t    errorTag = '[object Error]',\n\t    funcTag = '[object Function]',\n\t    genTag = '[object GeneratorFunction]',\n\t    mapTag$1 = '[object Map]',\n\t    numberTag = '[object Number]',\n\t    objectTag = '[object Object]',\n\t    regexpTag = '[object RegExp]',\n\t    setTag$1 = '[object Set]',\n\t    stringTag = '[object String]',\n\t    symbolTag = '[object Symbol]',\n\t    weakMapTag = '[object WeakMap]';\n\n\tvar arrayBufferTag = '[object ArrayBuffer]',\n\t    dataViewTag = '[object DataView]',\n\t    float32Tag = '[object Float32Array]',\n\t    float64Tag = '[object Float64Array]',\n\t    int8Tag = '[object Int8Array]',\n\t    int16Tag = '[object Int16Array]',\n\t    int32Tag = '[object Int32Array]',\n\t    uint8Tag = '[object Uint8Array]',\n\t    uint8ClampedTag = '[object Uint8ClampedArray]',\n\t    uint16Tag = '[object Uint16Array]',\n\t    uint32Tag = '[object Uint32Array]';\n\n\t/** Used to identify `toStringTag` values supported by `_.clone`. */\n\tvar cloneableTags = {};\n\tcloneableTags[argsTag] = cloneableTags[arrayTag] =\n\tcloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n\tcloneableTags[boolTag] = cloneableTags[dateTag] =\n\tcloneableTags[float32Tag] = cloneableTags[float64Tag] =\n\tcloneableTags[int8Tag] = cloneableTags[int16Tag] =\n\tcloneableTags[int32Tag] = cloneableTags[mapTag$1] =\n\tcloneableTags[numberTag] = cloneableTags[objectTag] =\n\tcloneableTags[regexpTag] = cloneableTags[setTag$1] =\n\tcloneableTags[stringTag] = cloneableTags[symbolTag] =\n\tcloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n\tcloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n\tcloneableTags[errorTag] = cloneableTags[funcTag] =\n\tcloneableTags[weakMapTag] = false;\n\n\t/**\n\t * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n\t * traversed objects.\n\t *\n\t * @private\n\t * @param {*} value The value to clone.\n\t * @param {boolean} bitmask The bitmask flags.\n\t *  1 - Deep clone\n\t *  2 - Flatten inherited properties\n\t *  4 - Clone symbols\n\t * @param {Function} [customizer] The function to customize cloning.\n\t * @param {string} [key] The key of `value`.\n\t * @param {Object} [object] The parent object of `value`.\n\t * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n\t * @returns {*} Returns the cloned value.\n\t */\n\tfunction baseClone(value, bitmask, customizer, key, object, stack) {\n\t  var result,\n\t      isDeep = bitmask & CLONE_DEEP_FLAG$1,\n\t      isFlat = bitmask & CLONE_FLAT_FLAG,\n\t      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;\n\n\t  if (customizer) {\n\t    result = object ? customizer(value, key, object, stack) : customizer(value);\n\t  }\n\t  if (result !== undefined) {\n\t    return result;\n\t  }\n\t  if (!isObject$1(value)) {\n\t    return value;\n\t  }\n\t  var isArr = isArray(value);\n\t  if (isArr) {\n\t    result = initCloneArray(value);\n\t    if (!isDeep) {\n\t      return copyArray(value, result);\n\t    }\n\t  } else {\n\t    var tag = getTag$1(value),\n\t        isFunc = tag == funcTag || tag == genTag;\n\n\t    if (isBuffer(value)) {\n\t      return cloneBuffer(value, isDeep);\n\t    }\n\t    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n\t      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n\t      if (!isDeep) {\n\t        return isFlat\n\t          ? copySymbolsIn(value, baseAssignIn(result, value))\n\t          : copySymbols(value, baseAssign(result, value));\n\t      }\n\t    } else {\n\t      if (!cloneableTags[tag]) {\n\t        return object ? value : {};\n\t      }\n\t      result = initCloneByTag(value, tag, isDeep);\n\t    }\n\t  }\n\t  // Check for circular references and return its corresponding clone.\n\t  stack || (stack = new Stack);\n\t  var stacked = stack.get(value);\n\t  if (stacked) {\n\t    return stacked;\n\t  }\n\t  stack.set(value, result);\n\n\t  if (isSet(value)) {\n\t    value.forEach(function(subValue) {\n\t      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n\t    });\n\t  } else if (isMap(value)) {\n\t    value.forEach(function(subValue, key) {\n\t      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n\t    });\n\t  }\n\n\t  var keysFunc = isFull\n\t    ? (isFlat ? getAllKeysIn : getAllKeys)\n\t    : (isFlat ? keysIn : keys);\n\n\t  var props = isArr ? undefined : keysFunc(value);\n\t  arrayEach(props || value, function(subValue, key) {\n\t    if (props) {\n\t      key = subValue;\n\t      subValue = value[key];\n\t    }\n\t    // Recursively populate clone (susceptible to call stack limits).\n\t    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n\t  });\n\t  return result;\n\t}\n\n\t/** Used to compose bitmasks for cloning. */\n\tvar CLONE_DEEP_FLAG = 1,\n\t    CLONE_SYMBOLS_FLAG = 4;\n\n\t/**\n\t * This method is like `_.clone` except that it recursively clones `value`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 1.0.0\n\t * @category Lang\n\t * @param {*} value The value to recursively clone.\n\t * @returns {*} Returns the deep cloned value.\n\t * @see _.clone\n\t * @example\n\t *\n\t * var objects = [{ 'a': 1 }, { 'b': 2 }];\n\t *\n\t * var deep = _.cloneDeep(objects);\n\t * console.log(deep[0] === objects[0]);\n\t * // => false\n\t */\n\tfunction cloneDeep(value) {\n\t  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n\t}\n\n\t/**\n\t * Performs a deep comparison between two values to determine if they are\n\t * equivalent.\n\t *\n\t * **Note:** This method supports comparing arrays, array buffers, booleans,\n\t * date objects, error objects, maps, numbers, `Object` objects, regexes,\n\t * sets, strings, symbols, and typed arrays. `Object` objects are compared\n\t * by their own, not inherited, enumerable properties. Functions and DOM\n\t * nodes are compared by strict equality, i.e. `===`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t * var other = { 'a': 1 };\n\t *\n\t * _.isEqual(object, other);\n\t * // => true\n\t *\n\t * object === other;\n\t * // => false\n\t */\n\tfunction isEqual(value, other) {\n\t  return baseIsEqual(value, other);\n\t}\n\n\tvar isMergeableObject = function isMergeableObject(value) {\n\t\treturn isNonNullObject(value)\n\t\t\t&& !isSpecial(value)\n\t};\n\n\tfunction isNonNullObject(value) {\n\t\treturn !!value && typeof value === 'object'\n\t}\n\n\tfunction isSpecial(value) {\n\t\tvar stringValue = Object.prototype.toString.call(value);\n\n\t\treturn stringValue === '[object RegExp]'\n\t\t\t|| stringValue === '[object Date]'\n\t\t\t|| isReactElement(value)\n\t}\n\n\t// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\tvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n\tvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n\tfunction isReactElement(value) {\n\t\treturn value.$$typeof === REACT_ELEMENT_TYPE\n\t}\n\n\tfunction emptyTarget(val) {\n\t\treturn Array.isArray(val) ? [] : {}\n\t}\n\n\tfunction cloneUnlessOtherwiseSpecified(value, options) {\n\t\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t\t: value\n\t}\n\n\tfunction defaultArrayMerge(target, source, options) {\n\t\treturn target.concat(source).map(function(element) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t\t})\n\t}\n\n\tfunction getMergeFunction(key, options) {\n\t\tif (!options.customMerge) {\n\t\t\treturn deepmerge\n\t\t}\n\t\tvar customMerge = options.customMerge(key);\n\t\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n\t}\n\n\tfunction getEnumerableOwnPropertySymbols(target) {\n\t\treturn Object.getOwnPropertySymbols\n\t\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t\t})\n\t\t\t: []\n\t}\n\n\tfunction getKeys(target) {\n\t\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n\t}\n\n\tfunction propertyIsOnObject(object, property) {\n\t\ttry {\n\t\t\treturn property in object\n\t\t} catch(_) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Protects from prototype poisoning and unexpected merging up the prototype chain.\n\tfunction propertyIsUnsafe(target, key) {\n\t\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n\t}\n\n\tfunction mergeObject(target, source, options) {\n\t\tvar destination = {};\n\t\tif (options.isMergeableObject(target)) {\n\t\t\tgetKeys(target).forEach(function(key) {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t\t});\n\t\t}\n\t\tgetKeys(source).forEach(function(key) {\n\t\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t\t} else {\n\t\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t\t}\n\t\t});\n\t\treturn destination\n\t}\n\n\tfunction deepmerge(target, source, options) {\n\t\toptions = options || {};\n\t\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t\t// implementations can use it. The caller may not replace it.\n\t\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\t\tvar sourceIsArray = Array.isArray(source);\n\t\tvar targetIsArray = Array.isArray(target);\n\t\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\t\tif (!sourceAndTargetTypesMatch) {\n\t\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t\t} else if (sourceIsArray) {\n\t\t\treturn options.arrayMerge(target, source, options)\n\t\t} else {\n\t\t\treturn mergeObject(target, source, options)\n\t\t}\n\t}\n\n\tdeepmerge.all = function deepmergeAll(array, options) {\n\t\tif (!Array.isArray(array)) {\n\t\t\tthrow new Error('first argument should be an array')\n\t\t}\n\n\t\treturn array.reduce(function(prev, next) {\n\t\t\treturn deepmerge(prev, next, options)\n\t\t}, {})\n\t};\n\n\tvar deepmerge_1 = deepmerge;\n\n\tvar cjs = deepmerge_1;\n\n\tfunction t(t){return 65<=t&&t<=90}function n(t){return 97<=t&&t<=122}function r(t){return 48<=t&&t<=57}function o(t){return t-32}function e(t){return t+32}function u(u){const c=u.charCodeAt(0);if(r(c)||45===c||isNaN(c))return u;let i=t(c);const f=i?[e(c)]:[c],s=u.length;for(let t=1;t<s;t++){let r=u.charCodeAt(t);if(95===r||32===r||45===r){if(i=!0,r=u.charCodeAt(++t),isNaN(r))return u;n(r)?f.push(o(r)):f.push(r);}else f.push(r);}return i?String.fromCharCode.apply(void 0,f):u}function c(r,o){const u=r.charCodeAt(0);if(!n(u)||isNaN(u))return r;let c=!1;const i=[u];let f=95;o&&o.charCodeAt(0)&&(f=o.charCodeAt(0));const s=r.length;for(let n=1;n<s;n++){const o=r.charCodeAt(n);t(o)?(c=!0,i.push(f),i.push(e(o))):i.push(o);}return c?String.fromCharCode.apply(void 0,i):r}function s(t){return Boolean(t)&&\"object\"==typeof t&&!(t instanceof Function)&&!(t instanceof Date)}function a(t,n,r){if(Array.isArray(t))return function(t,n,r){const o=new Array(t.length);let e=0;for(const u of t)o[e++]=s(u)?a(u,n,r):u;return o}(t,n,r);if(void 0!==t.prototype)return t;const o={};for(const e in t){const u=t[e];o[n(e,r)]=s(u)?a(u,n,r):u;}return o}function l(t){return s(t)?a(t,u):t}function d(t,n){return s(t)?a(t,c,n):t}\n\n\tlet options$2 = {};\n\tfunction merge(x, y, opt = {}) {\n\t  if (!y || typeof y !== \"object\") {\n\t    return x;\n\t  }\n\t  if (!x || typeof x !== \"object\") {\n\t    return x;\n\t  }\n\t  function arrayMerge(target, source, options2) {\n\t    const destination = target.slice();\n\t    source.forEach((item, index) => {\n\t      if (typeof destination[index] === \"undefined\") {\n\t        destination[index] = options2.cloneUnlessOtherwiseSpecified(\n\t          item,\n\t          options2\n\t        );\n\t      } else if (options2.isMergeableObject(item)) {\n\t        destination[index] = merge(target[index], item, options2);\n\t      } else if (target.indexOf(item) === -1) {\n\t        destination.push(item);\n\t      }\n\t    });\n\t    return destination;\n\t  }\n\t  return cjs(x, y, {\n\t    arrayMerge\n\t  });\n\t}\n\tfunction setOptions(optns) {\n\t  options$2 = optns;\n\t}\n\tfunction getOptions() {\n\t  return options$2;\n\t}\n\tfunction isObject(val) {\n\t  return val && typeof val === \"object\" && !(val instanceof Array);\n\t}\n\tfunction camelCase(str) {\n\t  return u(str);\n\t}\n\tfunction snakeCase(str) {\n\t  return c(str, \"_\");\n\t}\n\tfunction toCamel(obj) {\n\t  if (!obj)\n\t    return obj;\n\t  const objCopy = JSON.parse(JSON.stringify(obj));\n\t  return l(objCopy);\n\t}\n\tfunction toCamelPath(str) {\n\t  if (typeof str === \"string\") {\n\t    return str.split(\".\").map(u).join(\".\");\n\t  }\n\t  return str;\n\t}\n\tfunction toSnake(obj) {\n\t  if (!obj)\n\t    return obj;\n\t  const objCopy = JSON.parse(JSON.stringify(obj));\n\t  return d(objCopy, \"_\");\n\t}\n\tfunction trimBoth(str) {\n\t  return trimStart(trimEnd(str));\n\t}\n\tfunction trimStart(str) {\n\t  return typeof str === \"string\" ? str.replace(/^[/]+/, \"\") : \"\";\n\t}\n\tfunction trimEnd(str) {\n\t  return typeof str === \"string\" ? str.replace(/[/]+$/, \"\") : \"\";\n\t}\n\tfunction stringifyQuery(str) {\n\t  return lib.stringify(str);\n\t}\n\tfunction map$1(arr, cb) {\n\t  return arr instanceof Array ? arr.map(cb) : [];\n\t}\n\tfunction reduce$1(arr, cb, init) {\n\t  return arr instanceof Array ? arr.reduce(cb, init) : init;\n\t}\n\tfunction isServer() {\n\t  return !(typeof window !== \"undefined\" && window && window.document);\n\t}\n\tfunction isFunction(func) {\n\t  return typeof func === \"function\";\n\t}\n\tfunction defaultMethods(request, uri, methods) {\n\t  return {\n\t    list: methods.indexOf(\"list\") >= 0 ? function(query) {\n\t      return request(\"get\", uri, void 0, query);\n\t    } : void 0,\n\t    get: methods.indexOf(\"get\") >= 0 ? function(id, query) {\n\t      return request(\"get\", uri, id, query);\n\t    } : void 0\n\t  };\n\t}\n\tasync function vaultRequest(method, url, data, opt = void 0) {\n\t  const vaultUrl = options$2.vaultUrl;\n\t  const timeout = options$2.timeout;\n\t  const requestId = vaultRequestId();\n\t  const callback = `swell_vault_response_${requestId}`;\n\t  data = {\n\t    $jsonp: {\n\t      method,\n\t      callback\n\t    },\n\t    $data: data,\n\t    $key: options$2.key\n\t  };\n\t  return new Promise((resolve, reject) => {\n\t    const script = document.createElement(\"script\");\n\t    script.type = \"text/javascript\";\n\t    script.src = `${trimEnd(vaultUrl)}/${trimStart(url)}?${serializeData(\n      data\n    )}`;\n\t    const errorTimeout = setTimeout(() => {\n\t      window[callback]({\n\t        $error: `Request timed out after ${timeout / 1e3} seconds`,\n\t        $status: 500\n\t      });\n\t    }, timeout);\n\t    window[callback] = (result) => {\n\t      clearTimeout(errorTimeout);\n\t      if (result && result.$error) {\n\t        const err = new Error(result.$error);\n\t        err.code = \"request_error\";\n\t        err.status = result.$status;\n\t        reject(err);\n\t      } else if (!result || result.$status >= 300) {\n\t        const err = new Error(\n\t          \"A connection error occurred while making the request\"\n\t        );\n\t        err.code = \"connection_error\";\n\t        err.status = result.$status;\n\t        reject(err);\n\t      } else {\n\t        resolve(options$2.useCamelCase ? toCamel(result.$data) : result.$data);\n\t      }\n\t      delete window[callback];\n\t      script.parentNode.removeChild(script);\n\t    };\n\t    document.getElementsByTagName(\"head\")[0].appendChild(script);\n\t  });\n\t}\n\tfunction vaultRequestId() {\n\t  window.__swell_vault_request_id = window.__swell_vault_request_id || 0;\n\t  window.__swell_vault_request_id++;\n\t  return window.__swell_vault_request_id;\n\t}\n\tfunction serializeData(data) {\n\t  const s = [];\n\t  const add = function(key2, value) {\n\t    if (typeof value === \"function\") {\n\t      value = value();\n\t    } else if (value == null) {\n\t      value = \"\";\n\t    }\n\t    s[s.length] = encodeURIComponent(key2) + \"=\" + encodeURIComponent(value);\n\t  };\n\t  for (const key2 in data) {\n\t    buildParams(key2, data[key2], add);\n\t  }\n\t  return s.join(\"&\").replace(\" \", \"+\");\n\t}\n\tconst rbracket = /\\[\\]$/;\n\tfunction buildParams(key, obj, add) {\n\t  let name;\n\t  if (obj instanceof Array) {\n\t    for (let i = 0; i < obj.length; i++) {\n\t      if (rbracket.test(key)) {\n\t        add(key, v);\n\t      } else {\n\t        buildParams(\n\t          key + \"[\" + (typeof v === \"object\" && v != null ? i : \"\") + \"]\",\n\t          v,\n\t          add\n\t        );\n\t      }\n\t    }\n\t  } else if (obj && typeof obj === \"object\") {\n\t    for (name in obj) {\n\t      buildParams(key + \"[\" + name + \"]\", obj[name], add);\n\t    }\n\t  } else {\n\t    add(key, obj);\n\t  }\n\t}\n\tfunction base64Encode(string) {\n\t  if (typeof btoa !== \"undefined\") {\n\t    return btoa(string);\n\t  }\n\t  return Buffer.from(string).toString(\"base64\");\n\t}\n\tfunction getLocationParams(location) {\n\t  const url = location.search;\n\t  const query = url.substr(1);\n\t  const result = {};\n\t  query.split(\"&\").forEach(function(part) {\n\t    const item = part.split(\"=\");\n\t    result[item[0]] = decodeURIComponent(item[1]);\n\t  });\n\t  return result;\n\t}\n\tfunction removeUrlParams() {\n\t  const url = window.location.origin + window.location.pathname;\n\t  window.history.pushState({ path: url }, \"\", url);\n\t}\n\n\tvar utils = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tdefaultMethods: defaultMethods,\n\t\tset: set,\n\t\tget: get,\n\t\tuniq: uniq,\n\t\tfind: find,\n\t\tround: round,\n\t\tfindIndex: findIndex,\n\t\tcamelCase: camelCase,\n\t\tcloneDeep: cloneDeep,\n\t\tmerge: merge,\n\t\tsetOptions: setOptions,\n\t\tgetOptions: getOptions,\n\t\ttoCamel: toCamel,\n\t\ttoCamelPath: toCamelPath,\n\t\ttoSnake: toSnake,\n\t\ttrimBoth: trimBoth,\n\t\ttrimStart: trimStart,\n\t\ttrimEnd: trimEnd,\n\t\tstringifyQuery: stringifyQuery,\n\t\tisServer: isServer,\n\t\tisFunction: isFunction,\n\t\tisObject: isObject,\n\t\tisEqual: isEqual,\n\t\tsnakeCase: snakeCase,\n\t\tmap: map$1,\n\t\treduce: reduce$1,\n\t\tbase64Encode: base64Encode,\n\t\tvaultRequest: vaultRequest,\n\t\tgetLocationParams: getLocationParams,\n\t\tremoveUrlParams: removeUrlParams\n\t});\n\n\tconst cardApi = {\n\t  async createToken(data) {\n\t    let error = null;\n\t    let code = null;\n\t    let param = null;\n\t    if (!data) {\n\t      error = \"Card details are missing in `swell.card.createToken(card)`\";\n\t      param = \"\";\n\t    }\n\t    const card = toSnake(data);\n\t    if (!card.nonce) {\n\t      if (!this.validateNumber(card.number)) {\n\t        error = \"Card number appears to be invalid\";\n\t        code = \"invalid_card_number\";\n\t        param = \"number\";\n\t      }\n\t      if (card.exp) {\n\t        const exp = this.expiry(card.exp);\n\t        card.exp_month = exp.month;\n\t        card.exp_year = exp.year;\n\t      }\n\t      if (!this.validateExpiry(card.exp_month, card.exp_year)) {\n\t        error = \"Card expiry appears to be invalid\";\n\t        code = \"invalid_card_expiry\";\n\t        param = \"exp_month\";\n\t      }\n\t      if (!this.validateCVC(card.cvc)) {\n\t        error = \"Card CVC code appears to be invalid\";\n\t        code = \"invalid_card_cvc\";\n\t        param = \"exp_cvc\";\n\t      }\n\t    }\n\t    if (error) {\n\t      const err = new Error(error);\n\t      err.code = code || \"invalid_card\";\n\t      err.status = 402;\n\t      err.param = param;\n\t      throw err;\n\t    }\n\t    const result = await vaultRequest(\"post\", \"/tokens\", card);\n\t    if (result.errors) {\n\t      const param2 = Object.keys(result.errors)[0];\n\t      const err = new Error(result.errors[param2].message || \"Unknown error\");\n\t      err.code = \"vault_error\";\n\t      err.status = 402;\n\t      err.param = param2;\n\t      throw err;\n\t    }\n\t    return result;\n\t  },\n\t  expiry(value) {\n\t    if (value && value.month && value.year) {\n\t      return value;\n\t    }\n\t    const parts = new String(value).split(/[\\s\\/\\-]+/, 2);\n\t    const month = parts[0];\n\t    let year = parts[1];\n\t    if (year && year.length === 2 && /^\\d+$/.test(year)) {\n\t      const prefix = new Date().getFullYear().toString().substring(0, 2);\n\t      year = prefix + year;\n\t    }\n\t    return {\n\t      month: ~~month,\n\t      year: ~~year\n\t    };\n\t  },\n\t  types() {\n\t    let e, t, n, r;\n\t    t = {};\n\t    for (e = n = 40; n <= 49; e = ++n)\n\t      t[e] = \"Visa\";\n\t    for (e = r = 50; r <= 59; e = ++r)\n\t      t[e] = \"MasterCard\";\n\t    return t[34] = t[37] = \"American Express\", t[60] = t[62] = t[64] = t[65] = \"Discover\", t[35] = \"JCB\", t[30] = t[36] = t[38] = t[39] = \"Diners Club\", t;\n\t  },\n\t  type(num) {\n\t    return this.types()[num.slice(0, 2)] || \"Unknown\";\n\t  },\n\t  luhnCheck(num) {\n\t    let t, n, r, i, s, o;\n\t    r = true, i = 0, n = (num + \"\").split(\"\").reverse();\n\t    for (s = 0, o = n.length; s < o; s++) {\n\t      t = n[s], t = parseInt(t, 10);\n\t      if (r = !r)\n\t        t *= 2;\n\t      t > 9 && (t -= 9), i += t;\n\t    }\n\t    return i % 10 === 0;\n\t  },\n\t  validateNumber(num) {\n\t    return num = (num + \"\").replace(/\\s+|-/g, \"\"), num.length >= 10 && num.length <= 16 && this.luhnCheck(num);\n\t  },\n\t  validateExpiry(month, year) {\n\t    let r, i;\n\t    return month = String(month).trim(), year = String(year).trim(), /^\\d+$/.test(month) ? /^\\d+$/.test(year) ? parseInt(month, 10) <= 12 ? (i = new Date(year, month), r = new Date(), i.setMonth(i.getMonth() - 1), i.setMonth(i.getMonth() + 1, 1), i > r) : false : false : false;\n\t  },\n\t  validateCVC(val) {\n\t    return val = String(val).trim(), /^\\d+$/.test(val) && val.length >= 3 && val.length <= 4;\n\t  }\n\t};\n\n\tvar __defProp$9 = Object.defineProperty;\n\tvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$9 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$9.call(b, prop))\n\t      __defNormalProp$9(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$9)\n\t    for (var prop of __getOwnPropSymbols$9(b)) {\n\t      if (__propIsEnum$9.call(b, prop))\n\t        __defNormalProp$9(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tconst COOKIE_MAX_AGE = 604800;\n\tfunction getCookie(name) {\n\t  if (isServer()) {\n\t    return void 0;\n\t  }\n\t  const matches = document.cookie.match(\n\t    new RegExp(\n\t      \"(?:^|; )\" + name.replace(/([.$?*|{}()[]\\\\\\/\\+^])/g, \"\\\\$1\") + \"=([^;]*)\"\n\t    )\n\t  );\n\t  return matches ? decodeURIComponent(matches[1]) : void 0;\n\t}\n\tfunction setCookie(name, value, options = {}) {\n\t  if (isServer()) {\n\t    return;\n\t  }\n\t  options = __spreadValues$9({\n\t    path: \"/\",\n\t    \"max-age\": COOKIE_MAX_AGE,\n\t    samesite: \"lax\"\n\t  }, options);\n\t  if (options.expires && options.expires.toUTCString) {\n\t    options.expires = options.expires.toUTCString();\n\t  }\n\t  let updatedCookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\t  for (const optionKey in options) {\n\t    updatedCookie += \"; \" + optionKey;\n\t    const optionValue = options[optionKey];\n\t    if (optionValue !== true) {\n\t      updatedCookie += \"=\" + optionValue;\n\t    }\n\t  }\n\t  document.cookie = updatedCookie;\n\t}\n\n\tvar __defProp$8 = Object.defineProperty;\n\tvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$8 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$8.call(b, prop))\n\t      __defNormalProp$8(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$8)\n\t    for (var prop of __getOwnPropSymbols$8(b)) {\n\t      if (__propIsEnum$8.call(b, prop))\n\t        __defNormalProp$8(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tconst RECORD_TIMEOUT = 5e3;\n\tlet VALUES = {};\n\tconst cacheApi = {\n\t  options: {\n\t    enabled: true,\n\t    debug: false\n\t  },\n\t  debug(...args) {\n\t    if (this.options.debug) {\n\t      console.log(...args);\n\t    }\n\t  },\n\t  values({ model, id }, setValues = void 0) {\n\t    this.debug(\"cache.values\", ...arguments);\n\t    if (setValues !== void 0) {\n\t      for (let key in setValues) {\n\t        set(VALUES, `${model}.${id}.${key}`, setValues[key]);\n\t      }\n\t      return;\n\t    }\n\t    return get(VALUES, `${model}.${id}`, {});\n\t  },\n\t  preset(details) {\n\t    this.debug(\"cache.preset\", ...arguments);\n\t    const { presets = [] } = this.values(details);\n\t    presets.push(details);\n\t    this.values(details, { presets });\n\t  },\n\t  set(details) {\n\t    this.debug(\"cache.set\", ...arguments);\n\t    let { model, id, path, value } = details;\n\t    let { data = {}, record, presets } = this.values(details);\n\t    if (id === null) {\n\t      return;\n\t    }\n\t    if (record === void 0) {\n\t      return this.preset(details);\n\t    }\n\t    data = merge(record || {}, data);\n\t    const { useCamelCase } = getOptions();\n\t    if (useCamelCase && value && typeof value === \"object\") {\n\t      value = toCamel(value);\n\t    }\n\t    if (path || value instanceof Array) {\n\t      let upData = __spreadValues$8({}, data || {});\n\t      let upPath = useCamelCase ? toCamelPath(path) : path;\n\t      set(upData, upPath || \"\", value);\n\t      data = upData;\n\t    } else if (value && typeof value === \"object\") {\n\t      data = data || {};\n\t      data = merge(data, value);\n\t    } else {\n\t      data = value;\n\t    }\n\t    this.values(details, { data });\n\t    try {\n\t      const cache = VALUES[model][id];\n\t      if (cache !== void 0) {\n\t        if (cache.data !== void 0) {\n\t          cache.data = JSON.parse(JSON.stringify(cache.data));\n\t        }\n\t        if (cache.record !== void 0) {\n\t          cache.record = JSON.parse(JSON.stringify(cache.record));\n\t        }\n\t      }\n\t    } catch (err) {\n\t    }\n\t  },\n\t  get(model, id) {\n\t    this.debug(\"cache.get\", ...arguments);\n\t    const { data, recordTimer } = this.values({ model, id });\n\t    this.debug(\"cache.get:data+recordTimer\", ...arguments);\n\t    if (recordTimer) {\n\t      return data;\n\t    }\n\t  },\n\t  setRecord(record, details) {\n\t    this.debug(\"cache.setRecord\", ...arguments);\n\t    let { recordTimer, presets } = this.values(details);\n\t    if (recordTimer) {\n\t      clearTimeout(recordTimer);\n\t    }\n\t    recordTimer = setTimeout(() => {\n\t      this.values(details, { record: void 0, recordTimer: void 0 });\n\t    }, RECORD_TIMEOUT);\n\t    this.values(details, {\n\t      record: record !== void 0 ? record : null,\n\t      recordTimer\n\t    });\n\t    if (presets) {\n\t      for (let preset of presets) {\n\t        this.set(preset);\n\t      }\n\t      this.values(details, { presets: void 0 });\n\t    }\n\t    const result = this.get(details.model, details.id);\n\t    return result !== void 0 ? result : record;\n\t  },\n\t  async getFetch(model, id, fetch) {\n\t    if (this.options.enabled) {\n\t      this.debug(\"cache.getFetch\", ...arguments);\n\t      const value = this.get(model, id);\n\t      if (value !== void 0) {\n\t        return value;\n\t      }\n\t    }\n\t    const record = await fetch();\n\t    return this.setRecord(record, { model, id });\n\t  },\n\t  clear(model = void 0, id = void 0) {\n\t    this.debug(\"cache.clear\", ...arguments);\n\t    if (model) {\n\t      if (id) {\n\t        set(VALUES, `${model}.${id}`, void 0);\n\t      } else {\n\t        set(VALUES, model, void 0);\n\t      }\n\t    } else {\n\t      VALUES = {};\n\t    }\n\t  }\n\t};\n\n\tfunction methods$a(request) {\n\t  const { get, list } = defaultMethods(request, \"/attributes\", [\"list\", \"get\"]);\n\t  return {\n\t    get: (id, ...args) => {\n\t      return cacheApi.getFetch(\"attributes\", id, () => get(id, ...args));\n\t    },\n\t    list\n\t  };\n\t}\n\n\tvar __defProp$7 = Object.defineProperty;\n\tvar __defProps$4 = Object.defineProperties;\n\tvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\n\tvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$7 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$7.call(b, prop))\n\t      __defNormalProp$7(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$7)\n\t    for (var prop of __getOwnPropSymbols$7(b)) {\n\t      if (__propIsEnum$7.call(b, prop))\n\t        __defNormalProp$7(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\n\tlet OPTIONS;\n\tfunction methods$9(request, opt) {\n\t  OPTIONS = opt;\n\t  const { get: get2, list } = defaultMethods(request, \"/products\", [\"list\", \"get\"]);\n\t  return {\n\t    get: (id, ...args) => {\n\t      return cacheApi.getFetch(\"products\", id, () => get2(id, ...args));\n\t    },\n\t    list,\n\t    variation: calculateVariation,\n\t    categories: getCategories,\n\t    attributes: getAttributes,\n\t    priceRange: getPriceRange,\n\t    filters: getFilters,\n\t    filterableAttributeFilters: (products, options) => getFilterableAttributeFilters(request, products, options)\n\t  };\n\t}\n\tfunction getProductOptionIndex(product, filter = void 0) {\n\t  if (!product.options) {\n\t    return {};\n\t  }\n\t  const productOptions = filter ? product.options.filter(filter) : product.options;\n\t  return reduce$1(\n\t    productOptions,\n\t    (acc, op) => {\n\t      const values = reduce$1(\n\t        op.values,\n\t        (acc2, val) => __spreadProps$4(__spreadValues$7({}, acc2), {\n\t          [val.id]: __spreadProps$4(__spreadValues$7({}, val), { id: val.id }),\n\t          [val.name]: __spreadProps$4(__spreadValues$7({}, val), { id: val.id })\n\t        }),\n\t        {}\n\t      );\n\t      return __spreadProps$4(__spreadValues$7({}, acc), {\n\t        [op.id]: __spreadProps$4(__spreadValues$7({}, op), { values }),\n\t        [op.name]: __spreadProps$4(__spreadValues$7({}, op), { values })\n\t      });\n\t    },\n\t    {}\n\t  );\n\t}\n\tfunction cleanProductOptions(options) {\n\t  let result = options || [];\n\t  if (options && typeof options === \"object\" && !(options instanceof Array)) {\n\t    result = [];\n\t    for (const key in options) {\n\t      result.push({\n\t        id: key,\n\t        value: options[key]\n\t      });\n\t    }\n\t  }\n\t  if (result instanceof Array) {\n\t    return result.map((op) => ({\n\t      id: op.id || op.name,\n\t      value: op.value\n\t    }));\n\t  }\n\t  return result;\n\t}\n\tfunction findVariantWithOptionValueIds(product, ids) {\n\t  if (ids.length > 0) {\n\t    const variants = product.variants && product.variants.results;\n\t    if (variants.length > 0) {\n\t      for (const variant of variants) {\n\t        const variantObj = toSnake(variant);\n\t        const matched = isEqual(variantObj.option_value_ids.sort(), ids.sort());\n\t        if (matched) {\n\t          return variant;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return null;\n\t}\n\tfunction calculateVariation(input, options, purchaseOption) {\n\t  const product = OPTIONS.useCamelCase ? toSnake(input) : input;\n\t  const purchaseOp = findPurchaseOption(product, purchaseOption);\n\t  const variation = __spreadProps$4(__spreadValues$7({}, product), {\n\t    price: purchaseOp.price || 0,\n\t    sale_price: purchaseOp.sale_price,\n\t    orig_price: purchaseOp.orig_price,\n\t    stock_status: product.stock_status\n\t  });\n\t  let optionPrice = 0;\n\t  const variantOptionValueIds = [];\n\t  const cleanOptions = cleanProductOptions(options);\n\t  const index = getProductOptionIndex(product);\n\t  for (const option of cleanOptions) {\n\t    if (index[option.id] && index[option.id].values[option.value]) {\n\t      if (index[option.id].variant) {\n\t        variantOptionValueIds.push(index[option.id].values[option.value].id);\n\t      } else {\n\t        optionPrice += index[option.id].values[option.value].price || 0;\n\t      }\n\t    }\n\t  }\n\t  if (variantOptionValueIds.length > 0) {\n\t    const variant = findVariantWithOptionValueIds(\n\t      product,\n\t      variantOptionValueIds\n\t    );\n\t    if (variant) {\n\t      let variantPurchaseOp = purchaseOp;\n\t      try {\n\t        variantPurchaseOp = findPurchaseOption(variant, purchaseOption);\n\t      } catch (err) {\n\t      }\n\t      variation.variant_id = variant.id;\n\t      variation.price = variantPurchaseOp.price || 0;\n\t      variation.sale_price = variantPurchaseOp.sale_price || purchaseOp.sale_price;\n\t      variation.orig_price = variantPurchaseOp.orig_price || purchaseOp.orig_price;\n\t      variation.stock_status = variant.stock_status;\n\t      variation.stock_level = variant.stock_level || 0;\n\t      variation.images = (variant.images && variant.images.length ? variant.images : product.images) || [];\n\t    }\n\t  }\n\t  if (optionPrice > 0) {\n\t    variation.price += optionPrice;\n\t    if (variation.sale_price) {\n\t      variation.sale_price += optionPrice;\n\t    }\n\t    if (variation.orig_price) {\n\t      variation.orig_price += optionPrice;\n\t    }\n\t  }\n\t  if (variation.sale_price === void 0) {\n\t    delete variation.sale_price;\n\t  }\n\t  if (variation.orig_price === void 0) {\n\t    delete variation.orig_price;\n\t  }\n\t  return OPTIONS.useCamelCase ? toCamel(variation) : variation;\n\t}\n\tfunction findPurchaseOption(product, purchaseOption) {\n\t  const plan = get(purchaseOption, \"plan_id\", get(purchaseOption, \"plan\"));\n\t  const type = get(\n\t    purchaseOption,\n\t    \"type\",\n\t    typeof purchaseOption === \"string\" ? purchaseOption : plan !== void 0 ? \"subscription\" : \"standard\"\n\t  );\n\t  let option = get(product, `purchase_options.${type}`);\n\t  if (!option && type !== \"standard\") {\n\t    throw new Error(\n\t      `Product purchase option '${type}' not found or not active`\n\t    );\n\t  }\n\t  if (option) {\n\t    if (option.plans) {\n\t      if (plan !== void 0) {\n\t        option = find(option.plans, { id: plan });\n\t        if (!option) {\n\t          throw new Error(\n\t            `Subscription purchase plan '${plan}' not found or not active`\n\t          );\n\t        }\n\t      } else {\n\t        option = option.plans[0];\n\t      }\n\t    }\n\t    return __spreadProps$4(__spreadValues$7({}, option), {\n\t      price: typeof option.price === \"number\" ? option.price : product.price,\n\t      sale_price: typeof option.sale_price === \"number\" ? option.sale_price : product.sale_price,\n\t      orig_price: typeof option.orig_price === \"number\" ? option.orig_price : product.orig_price\n\t    });\n\t  }\n\t  return {\n\t    type: \"standard\",\n\t    price: product.price,\n\t    sale_price: product.sale_price,\n\t    orig_price: product.orig_price\n\t  };\n\t}\n\tasync function getFilterableAttributeFilters(request, products, options) {\n\t  const { results: filterableAttributes } = await methods$a(\n\t    request).list({\n\t    filterable: true\n\t  });\n\t  return getFilters(products, __spreadProps$4(__spreadValues$7({}, options), { filterableAttributes }));\n\t}\n\tfunction getFilters(products, options = {}) {\n\t  let attributes = (options.attributes || options.attributes === void 0) && getAttributes(products);\n\t  if (options.filterableAttributes) {\n\t    attributes = attributes.filter(\n\t      (productAttr) => options.filterableAttributes.find(\n\t        (filterableAttr) => productAttr.id === filterableAttr.id\n\t      )\n\t    );\n\t  }\n\t  const categories = (options.categories || options.categories === void 0) && getCategories(products);\n\t  const priceRange = (options.price || options.price === void 0) && getPriceRange(products);\n\t  let filters = [];\n\t  if (priceRange) {\n\t    filters.push({\n\t      id: \"price\",\n\t      label: \"Price\",\n\t      type: \"range\",\n\t      options: [\n\t        {\n\t          value: priceRange.min,\n\t          label: priceRange.min\n\t        },\n\t        {\n\t          value: priceRange.max,\n\t          label: priceRange.max\n\t        }\n\t      ],\n\t      interval: priceRange.interval\n\t    });\n\t  }\n\t  if (categories && categories.length > 0) {\n\t    filters.push({\n\t      id: \"category\",\n\t      label: \"Category\",\n\t      type: \"select\",\n\t      options: categories.map((category) => ({\n\t        value: category.slug,\n\t        label: category.name\n\t      }))\n\t    });\n\t  }\n\t  if (attributes && attributes.length > 0) {\n\t    filters = [\n\t      ...filters,\n\t      ...reduce$1(\n\t        attributes,\n\t        (acc, attr) => [\n\t          ...acc,\n\t          ...attr.id !== \"category\" && attr.id !== \"price\" && attr.values instanceof Array && attr.values.length > 0 ? [\n\t            {\n\t              id: attr.id,\n\t              label: attr.name,\n\t              type: \"select\",\n\t              options: attr.values.map((value) => ({\n\t                value,\n\t                label: value\n\t              }))\n\t            }\n\t          ] : []\n\t        ],\n\t        []\n\t      )\n\t    ];\n\t  }\n\t  return filters;\n\t}\n\tfunction getCategories(products) {\n\t  const categories = [];\n\t  const collection = products && products.results || (products.id ? [products] : products);\n\t  if (collection instanceof Array) {\n\t    for (let product of collection) {\n\t      if (product.categories) {\n\t        for (let category of product.categories) {\n\t          if (!category)\n\t            continue;\n\t          let ex = find(categories, { id: category.id });\n\t          if (!ex) {\n\t            categories.push(category);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return categories;\n\t}\n\tfunction getAttributes(products) {\n\t  const attributes = [];\n\t  const collection = products && products.results || (products.id ? [products] : products);\n\t  if (collection instanceof Array) {\n\t    for (let product of collection) {\n\t      if (product.attributes) {\n\t        for (let id in product.attributes) {\n\t          if (!product.attributes[id])\n\t            continue;\n\t          const value = product.attributes[id].value;\n\t          let attr = find(attributes, { id: snakeCase(id) });\n\t          if (attr) {\n\t            attr.values = uniq([\n\t              ...attr.values,\n\t              ...value instanceof Array ? value : [value]\n\t            ]);\n\t          } else {\n\t            attributes.push(__spreadProps$4(__spreadValues$7({}, product.attributes[id]), {\n\t              value: void 0,\n\t              values: [...value instanceof Array ? value : [value]]\n\t            }));\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return attributes;\n\t}\n\tfunction getPriceRange(products) {\n\t  let min;\n\t  let max;\n\t  let interval;\n\t  const collection = products && products.results || (products.id ? [products] : products);\n\t  if (collection instanceof Array) {\n\t    for (let product of collection) {\n\t      if (max === void 0 || product.price > max) {\n\t        max = Math.ceil(product.price);\n\t      }\n\t      if (min === void 0 || product.price < min) {\n\t        min = Math.floor(product.price);\n\t      }\n\t    }\n\t  }\n\t  if (min === max) {\n\t    return null;\n\t  }\n\t  interval = Math.ceil((max - min) / 10) || 1;\n\t  if (interval > 1e3) {\n\t    interval = 1e3;\n\t  } else if (interval > 100) {\n\t    interval = 100;\n\t  } else if (interval > 10) {\n\t    interval = 10;\n\t  }\n\t  if (max % interval > 0) {\n\t    max = interval + max - max % interval;\n\t  }\n\t  if (min % interval > 0) {\n\t    min = min - min % interval;\n\t  }\n\t  while ((max - min) / interval % 1 > 0) {\n\t    max++;\n\t  }\n\t  return {\n\t    min,\n\t    max,\n\t    interval\n\t  };\n\t}\n\n\tvar __defProp$6 = Object.defineProperty;\n\tvar __defProps$3 = Object.defineProperties;\n\tvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\n\tvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$6 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$6.call(b, prop))\n\t      __defNormalProp$6(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$6)\n\t    for (var prop of __getOwnPropSymbols$6(b)) {\n\t      if (__propIsEnum$6.call(b, prop))\n\t        __defNormalProp$6(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\n\tfunction methods$8(request, options) {\n\t  return {\n\t    state: null,\n\t    order: null,\n\t    settings: null,\n\t    requested: false,\n\t    pendingRequests: [],\n\t    cacheClear: null,\n\t    async requestStateChange(method, url, id, data) {\n\t      return this.requestStateSync(async () => {\n\t        const result = await request(method, url, id, data);\n\t        if (result && result.errors) {\n\t          return result;\n\t        }\n\t        this.state = result;\n\t        return result;\n\t      });\n\t    },\n\t    async requestStateSync(handler) {\n\t      if (this.state) {\n\t        return await handler();\n\t      } else if (this.requested) {\n\t        return new Promise((resolve) => {\n\t          this.pendingRequests.push({ handler, resolve });\n\t        });\n\t      }\n\t      this.requested = true;\n\t      const result = await handler();\n\t      this.requested = false;\n\t      while (this.pendingRequests.length > 0) {\n\t        const { handler: handler2, resolve } = this.pendingRequests.shift();\n\t        resolve(handler2());\n\t      }\n\t      return result;\n\t    },\n\t    get() {\n\t      let data;\n\t      if (this.cacheClear) {\n\t        this.cacheClear = null;\n\t        data = { $cache: false };\n\t      }\n\t      return this.requestStateChange(\"get\", \"/cart\", void 0, data);\n\t    },\n\t    clearCache() {\n\t      this.cacheClear = true;\n\t    },\n\t    getItemData(item, data = {}) {\n\t      let result = cloneDeep(item);\n\t      if (typeof item === \"string\") {\n\t        result = __spreadProps$3(__spreadValues$6({}, data || {}), {\n\t          product_id: item\n\t        });\n\t      }\n\t      if (result && result.options) {\n\t        result.options = cleanProductOptions(result.options);\n\t      }\n\t      return result;\n\t    },\n\t    addItem(item, data) {\n\t      return this.requestStateChange(\n\t        \"post\",\n\t        \"/cart/items\",\n\t        this.getItemData(item, data)\n\t      );\n\t    },\n\t    updateItem(id, item) {\n\t      return this.requestStateChange(\n\t        \"put\",\n\t        `/cart/items/${id}`,\n\t        this.getItemData(item)\n\t      );\n\t    },\n\t    setItems(input) {\n\t      let items = input;\n\t      if (items && items.map) {\n\t        items = items.map(this.getItemData);\n\t      }\n\t      return this.requestStateChange(\"put\", \"/cart/items\", items);\n\t    },\n\t    removeItem(id) {\n\t      return this.requestStateChange(\"delete\", `/cart/items/${id}`);\n\t    },\n\t    recover(checkoutId) {\n\t      return this.requestStateChange(\"put\", `/cart/recover/${checkoutId}`);\n\t    },\n\t    update(input) {\n\t      let data = input;\n\t      if (data.items && data.items.map) {\n\t        data = __spreadProps$3(__spreadValues$6({}, data), {\n\t          items: data.items.map(this.getItemData)\n\t        });\n\t      }\n\t      return this.requestStateChange(\"put\", `/cart`, data);\n\t    },\n\t    applyCoupon(code) {\n\t      return this.requestStateChange(\"put\", \"/cart/coupon\", { code });\n\t    },\n\t    removeCoupon() {\n\t      return this.requestStateChange(\"delete\", \"/cart/coupon\");\n\t    },\n\t    applyGiftcard(code) {\n\t      return this.requestStateChange(\"post\", \"/cart/giftcards\", { code });\n\t    },\n\t    removeGiftcard(id) {\n\t      return this.requestStateChange(\"delete\", `/cart/giftcards/${id}`);\n\t    },\n\t    async getShippingRates() {\n\t      await this.requestStateChange(\"get\", \"/cart/shipment-rating\");\n\t      return this.state[options.useCamelCase ? \"shipmentRating\" : \"shipment_rating\"];\n\t    },\n\t    async submitOrder() {\n\t      const result = await request(\"post\", \"/cart/order\");\n\t      if (result.errors) {\n\t        return result;\n\t      }\n\t      this.state = null;\n\t      this.order = result;\n\t      return result;\n\t    },\n\t    async getOrder(checkoutId = void 0) {\n\t      let result;\n\t      if (checkoutId) {\n\t        result = await request(\"get\", `/cart/order`, {\n\t          checkout_id: checkoutId\n\t        });\n\t      } else {\n\t        result = await request(\"get\", `/cart/order`);\n\t      }\n\t      this.order = result;\n\t      return result;\n\t    },\n\t    async getSettings() {\n\t      this.settings = await request(\"get\", \"/cart/settings\");\n\t      return this.settings;\n\t    }\n\t  };\n\t}\n\n\tfunction methods$7(request) {\n\t  return {\n\t    state: null,\n\t    async requestStateChange(method, url, id, data) {\n\t      const result = await request(method, url, id, data);\n\t      if (result && result.errors) {\n\t        return result;\n\t      }\n\t      return this.state = result;\n\t    },\n\t    get(query) {\n\t      return this.requestStateChange(\"get\", \"/account\", query);\n\t    },\n\t    create(data) {\n\t      return this.requestStateChange(\"post\", \"/account\", data);\n\t    },\n\t    update(data) {\n\t      return this.requestStateChange(\"put\", \"/account\", data);\n\t    },\n\t    login(email, password) {\n\t      if (password && password.password_token) {\n\t        return this.requestStateChange(\"post\", \"/account/login\", {\n\t          email,\n\t          password_token: password.password_token\n\t        });\n\t      }\n\t      return this.requestStateChange(\"post\", \"/account/login\", {\n\t        email,\n\t        password\n\t      });\n\t    },\n\t    logout() {\n\t      this.state = null;\n\t      return request(\"post\", \"/account/logout\");\n\t    },\n\t    recover(data) {\n\t      return request(\"post\", \"/account/recover\", data);\n\t    },\n\t    listAddresses(query) {\n\t      return request(\"get\", \"/account/addresses\", query);\n\t    },\n\t    createAddress(data) {\n\t      return request(\"post\", \"/account/addresses\", data);\n\t    },\n\t    updateAddress(id, data) {\n\t      return request(\"put\", `/account/addresses/${id}`, data);\n\t    },\n\t    deleteAddress(id) {\n\t      return request(\"delete\", `/account/addresses/${id}`);\n\t    },\n\t    listCards(query) {\n\t      return request(\"get\", \"/account/cards\", query);\n\t    },\n\t    createCard(data) {\n\t      return request(\"post\", \"/account/cards\", data);\n\t    },\n\t    updateCard(id, data) {\n\t      return request(\"put\", `/account/cards/${id}`, data);\n\t    },\n\t    deleteCard(id) {\n\t      return request(\"delete\", `/account/cards/${id}`);\n\t    },\n\t    listOrders(query) {\n\t      return request(\"get\", `/account/orders`, query);\n\t    },\n\t    getOrder(id) {\n\t      return request(\"get\", `/account/orders/${id}`);\n\t    },\n\t    getAddresses(query) {\n\t      return request(\"get\", \"/account/addresses\", query);\n\t    },\n\t    getCards(query) {\n\t      return request(\"get\", \"/account/cards\", query);\n\t    },\n\t    getOrders(query) {\n\t      return request(\"get\", `/account/orders`, query);\n\t    }\n\t  };\n\t}\n\n\tfunction methods$6(request) {\n\t  const { get, list } = defaultMethods(request, \"/categories\", [\"list\", \"get\"]);\n\t  return {\n\t    get: (id, ...args) => {\n\t      return cacheApi.getFetch(\"categories\", id, () => get(id, ...args));\n\t    },\n\t    list\n\t  };\n\t}\n\n\tfunction methods$5(request) {\n\t  const { get, list } = defaultMethods(request, \"/subscriptions\", [\n\t    \"list\",\n\t    \"get\"\n\t  ]);\n\t  return {\n\t    get: (id, ...args) => {\n\t      return cacheApi.getFetch(\"subscriptions\", id, () => get(id, ...args));\n\t    },\n\t    list,\n\t    getCleanData(data) {\n\t      if (data && data.options) {\n\t        data.options = cleanProductOptions(data.options);\n\t      }\n\t      if (data.items && data.items.map) {\n\t        data.items = data.items.map((item) => {\n\t          if (item.options) {\n\t            item.options = cleanProductOptions(item.options);\n\t          }\n\t          return item;\n\t        });\n\t      }\n\t      return data;\n\t    },\n\t    create(data) {\n\t      return request(\"post\", \"/subscriptions\", this.getCleanData(data));\n\t    },\n\t    update(id, data) {\n\t      return request(\"put\", `/subscriptions/${id}`, this.getCleanData(data));\n\t    },\n\t    addItem(id, item) {\n\t      return request(\n\t        \"post\",\n\t        `/subscriptions/${id}/items`,\n\t        this.getCleanData(item)\n\t      );\n\t    },\n\t    setItems(id, items) {\n\t      if (items && items.map) {\n\t        items = items.map(this.getCleanData);\n\t      }\n\t      return request(\"put\", `/subscriptions/${id}/items`, items);\n\t    },\n\t    updateItem(id, itemId, item) {\n\t      return request(\n\t        \"put\",\n\t        `/subscriptions/${id}/items/${itemId}`,\n\t        this.getCleanData(item)\n\t      );\n\t    },\n\t    removeItem(id, itemId) {\n\t      return request(\"delete\", `/subscriptions/${id}/items/${itemId}`);\n\t    }\n\t  };\n\t}\n\n\tvar __defProp$5 = Object.defineProperty;\n\tvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$5 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$5.call(b, prop))\n\t      __defNormalProp$5(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$5)\n\t    for (var prop of __getOwnPropSymbols$5(b)) {\n\t      if (__propIsEnum$5.call(b, prop))\n\t        __defNormalProp$5(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tfunction methods$4(request, opt) {\n\t  return {\n\t    get: (type, id, query) => {\n\t      return cacheApi.getFetch(\n\t        `content_${type}`,\n\t        id,\n\t        () => request(\"get\", `/content/${type}`, id, __spreadValues$5({\n\t          $preview: opt.previewContent\n\t        }, query || {}))\n\t      );\n\t    },\n\t    list: (type, query) => request(\"get\", `/content/${type}`, void 0, query)\n\t  };\n\t}\n\n\tvar __defProp$4 = Object.defineProperty;\n\tvar __defProps$2 = Object.defineProperties;\n\tvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\n\tvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$4 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$4.call(b, prop))\n\t      __defNormalProp$4(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$4)\n\t    for (var prop of __getOwnPropSymbols$4(b)) {\n\t      if (__propIsEnum$4.call(b, prop))\n\t        __defNormalProp$4(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\n\tfunction methods$3(request, opt) {\n\t  return {\n\t    state: null,\n\t    menuState: null,\n\t    paymentState: null,\n\t    subscriptionState: null,\n\t    sessionState: null,\n\t    localizedState: {},\n\t    refresh() {\n\t      this.state = null;\n\t      this.menuState = null;\n\t      this.paymentState = null;\n\t      this.subscriptionState = null;\n\t      this.sessionState = null;\n\t      this.localizedState = {};\n\t      return this.get();\n\t    },\n\t    getState(uri, stateName, { id = void 0, def = void 0, refresh = false } = {}) {\n\t      if (!this[stateName] || refresh) {\n\t        this[stateName] = request(\"get\", uri);\n\t      }\n\t      if (this[stateName] && typeof this[stateName].then === \"function\") {\n\t        return this[stateName].then((state) => {\n\t          this[stateName] = state;\n\t          return this.getLocalizedState(stateName, id, def);\n\t        });\n\t      }\n\t      return this.getLocalizedState(stateName, id, def);\n\t    },\n\t    getLocalizedState(stateName, id, def) {\n\t      const locale = this.getCurrentLocale();\n\t      const ls = this.localizedState;\n\t      if (ls.code !== locale) {\n\t        ls.code = locale;\n\t        delete ls[locale];\n\t      }\n\t      if (!ls[locale]) {\n\t        ls[locale] = {};\n\t      }\n\t      if (!ls[locale][stateName]) {\n\t        ls[locale][stateName] = this.decodeLocale(this[stateName]);\n\t      }\n\t      return id ? get(ls[locale][stateName], id, def) : ls[locale][stateName];\n\t    },\n\t    findState(uri, stateName, { where = void 0, def = void 0 } = {}) {\n\t      const state = this.getState(uri, stateName);\n\t      if (state && typeof state.then === \"function\") {\n\t        return state.then((state2) => find(state2, where) || def);\n\t      }\n\t      return find(state, where) || def;\n\t    },\n\t    get(id = void 0, def = void 0) {\n\t      return this.getState(\"/settings\", \"state\", { id, def });\n\t    },\n\t    getCurrentLocale() {\n\t      return opt.api.locale.selected();\n\t    },\n\t    getStoreLocale() {\n\t      return get(this.state, \"store.locale\");\n\t    },\n\t    getStoreLocales() {\n\t      return get(this.state, \"store.locales\");\n\t    },\n\t    set({ model, path, value }) {\n\t      const locale = this.getCurrentLocale();\n\t      const stateName = model ? `${model.replace(/s$/, \"\")}State` : \"state\";\n\t      const { useCamelCase } = opt;\n\t      let mergeData = {};\n\t      if (path)\n\t        set(mergeData, path, value);\n\t      else\n\t        mergeData = value;\n\t      if (useCamelCase) {\n\t        mergeData = toCamel(mergeData);\n\t      }\n\t      this[stateName] = merge(this[stateName] || {}, mergeData);\n\t      if (this.localizedState[locale]) {\n\t        this.localizedState[locale][stateName] = this.decodeLocale(\n\t          this[stateName]\n\t        );\n\t      }\n\t    },\n\t    menus(id = void 0, def = void 0) {\n\t      return this.findState(\"/settings/menus\", \"menuState\", {\n\t        where: { id },\n\t        def\n\t      });\n\t    },\n\t    payments(id = void 0, def = void 0) {\n\t      return this.getState(\"/settings/payments\", \"paymentState\", { id, def });\n\t    },\n\t    subscriptions(id = void 0, def = void 0) {\n\t      return this.getState(\"/settings/subscriptions\", \"subscriptionState\", {\n\t        id,\n\t        def\n\t      });\n\t    },\n\t    session(id = void 0, def = void 0) {\n\t      return this.getState(\"/session\", \"sessionState\", { id, def });\n\t    },\n\t    decodeLocale(values) {\n\t      const locale = this.getCurrentLocale();\n\t      if (!values || typeof values !== \"object\") {\n\t        return values;\n\t      }\n\t      let configs = this.getStoreLocales();\n\t      if (configs) {\n\t        configs = configs.reduce(\n\t          (acc, config) => __spreadProps$2(__spreadValues$4({}, acc), {\n\t            [config.code]: config\n\t          }),\n\t          {}\n\t        );\n\t      } else {\n\t        configs = {};\n\t      }\n\t      return decodeLocaleObjects(cloneDeep(values), locale, configs, opt);\n\t    },\n\t    async load() {\n\t      try {\n\t        const { settings, menus, payments, subscriptions, session } = await request(\"get\", \"/settings/all\");\n\t        this.localizedState = {};\n\t        this.set({\n\t          value: settings\n\t        });\n\t        this.set({\n\t          model: \"menus\",\n\t          value: menus\n\t        });\n\t        this.set({\n\t          model: \"payments\",\n\t          value: payments\n\t        });\n\t        this.set({\n\t          model: \"subscriptions\",\n\t          value: subscriptions\n\t        });\n\t        this.set({\n\t          model: \"session\",\n\t          value: session\n\t        });\n\t      } catch (err) {\n\t        console.error(`Swell: unable to loading settings (${err})`);\n\t      }\n\t    }\n\t  };\n\t}\n\tfunction decodeLocaleObjects(values, locale, configs, opt) {\n\t  if (isObject(values)) {\n\t    const keys = Object.keys(values);\n\t    for (let key of keys) {\n\t      if (key === \"$locale\") {\n\t        decodeLocaleValue(locale, values, key, configs, opt);\n\t        delete values.$locale;\n\t      }\n\t      if (values[key] !== void 0) {\n\t        values[key] = decodeLocaleObjects(values[key], locale, configs, opt);\n\t      }\n\t    }\n\t  } else if (values instanceof Array) {\n\t    for (var i = 0; i < values.length; i++) {\n\t      values[i] = decodeLocaleObjects(values[i], locale, configs, opt);\n\t    }\n\t  }\n\t  return values;\n\t}\n\tfunction decodeLocaleValue(locale, values, key, configs, opt) {\n\t  if (!locale || !isObject(values[key])) {\n\t    return;\n\t  }\n\t  let returnLocaleKey;\n\t  let returnLocaleConfig;\n\t  const localeKeys = Object.keys(values[key]);\n\t  for (let localeKey of localeKeys) {\n\t    const shortKey = localeKey.replace(/\\-.+$/, \"\");\n\t    const transformedLocale = opt.useCamelCase ? camelCase(locale) : locale;\n\t    if (localeKey === locale || localeKey === transformedLocale || shortKey === transformedLocale) {\n\t      returnLocaleKey = locale;\n\t      returnLocaleConfig = configs[locale];\n\t    }\n\t  }\n\t  if (!returnLocaleKey && isObject(configs)) {\n\t    const localeKeys2 = Object.keys(configs);\n\t    for (let localeKey of localeKeys2) {\n\t      const shortKey = localeKey.replace(/\\-.+$/, \"\");\n\t      if (localeKey === locale || shortKey === locale) {\n\t        returnLocaleKey = localeKey;\n\t        returnLocaleConfig = configs[localeKey];\n\t      }\n\t    }\n\t  }\n\t  let fallbackKeys;\n\t  let fallbackValues = {};\n\t  if (returnLocaleConfig) {\n\t    let fallbackKey = returnLocaleConfig.fallback;\n\t    const origFallbackKey = fallbackKey;\n\t    while (fallbackKey) {\n\t      fallbackKeys = fallbackKeys || [];\n\t      fallbackKeys.push(fallbackKey);\n\t      fallbackValues = __spreadValues$4(__spreadValues$4({}, values[key][fallbackKey] || {}), fallbackValues);\n\t      fallbackKey = configs[fallbackKey] && configs[fallbackKey].fallback;\n\t      if (origFallbackKey === fallbackKey) {\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  let localeValues = __spreadValues$4(__spreadValues$4({}, fallbackValues), values[key][returnLocaleKey] || {});\n\t  const valueKeys = Object.keys(localeValues);\n\t  for (let valueKey of valueKeys) {\n\t    const hasValue = localeValues[valueKey] !== null && localeValues[valueKey] !== \"\";\n\t    let shouldFallback = fallbackKeys && !hasValue;\n\t    if (shouldFallback) {\n\t      for (let fallbackKey of fallbackKeys) {\n\t        shouldFallback = !values[key][fallbackKey] || values[key][fallbackKey][valueKey] === null || values[key][fallbackKey][valueKey] === \"\";\n\t        if (shouldFallback) {\n\t          if (fallbackKey === \"none\") {\n\t            values[valueKey] = null;\n\t            break;\n\t          }\n\t          continue;\n\t        } else {\n\t          values[valueKey] = values[key][fallbackKey][valueKey];\n\t          break;\n\t        }\n\t      }\n\t    } else {\n\t      if (hasValue) {\n\t        values[valueKey] = localeValues[valueKey];\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Converts `string`, as a whole, to lower case just like\n\t * [String#toLowerCase](https://mdn.io/toLowerCase).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category String\n\t * @param {string} [string=''] The string to convert.\n\t * @returns {string} Returns the lower cased string.\n\t * @example\n\t *\n\t * _.toLower('--Foo-Bar--');\n\t * // => '--foo-bar--'\n\t *\n\t * _.toLower('fooBar');\n\t * // => 'foobar'\n\t *\n\t * _.toLower('__FOO_BAR__');\n\t * // => '__foo_bar__'\n\t */\n\tfunction toLower(value) {\n\t  return toString(value).toLowerCase();\n\t}\n\n\t/**\n\t * A specialized version of `_.reduce` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @param {*} [accumulator] The initial value.\n\t * @param {boolean} [initAccum] Specify using the first element of `array` as\n\t *  the initial value.\n\t * @returns {*} Returns the accumulated value.\n\t */\n\tfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\n\t  if (initAccum && length) {\n\t    accumulator = array[++index];\n\t  }\n\t  while (++index < length) {\n\t    accumulator = iteratee(accumulator, array[index], index, array);\n\t  }\n\t  return accumulator;\n\t}\n\n\t/**\n\t * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n\t *\n\t * @private\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Function} Returns the new base function.\n\t */\n\tfunction createBaseFor(fromRight) {\n\t  return function(object, iteratee, keysFunc) {\n\t    var index = -1,\n\t        iterable = Object(object),\n\t        props = keysFunc(object),\n\t        length = props.length;\n\n\t    while (length--) {\n\t      var key = props[fromRight ? length : ++index];\n\t      if (iteratee(iterable[key], key, iterable) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return object;\n\t  };\n\t}\n\n\t/**\n\t * The base implementation of `baseForOwn` which iterates over `object`\n\t * properties returned by `keysFunc` and invokes `iteratee` for each property.\n\t * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @param {Function} keysFunc The function to get the keys of `object`.\n\t * @returns {Object} Returns `object`.\n\t */\n\tvar baseFor = createBaseFor();\n\n\t/**\n\t * The base implementation of `_.forOwn` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseForOwn(object, iteratee) {\n\t  return object && baseFor(object, iteratee, keys);\n\t}\n\n\t/**\n\t * Creates a `baseEach` or `baseEachRight` function.\n\t *\n\t * @private\n\t * @param {Function} eachFunc The function to iterate over a collection.\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Function} Returns the new base function.\n\t */\n\tfunction createBaseEach(eachFunc, fromRight) {\n\t  return function(collection, iteratee) {\n\t    if (collection == null) {\n\t      return collection;\n\t    }\n\t    if (!isArrayLike(collection)) {\n\t      return eachFunc(collection, iteratee);\n\t    }\n\t    var length = collection.length,\n\t        index = fromRight ? length : -1,\n\t        iterable = Object(collection);\n\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      if (iteratee(iterable[index], index, iterable) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return collection;\n\t  };\n\t}\n\n\t/**\n\t * The base implementation of `_.forEach` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array|Object} Returns `collection`.\n\t */\n\tvar baseEach = createBaseEach(baseForOwn);\n\n\t/**\n\t * The base implementation of `_.reduce` and `_.reduceRight`, without support\n\t * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n\t *\n\t * @private\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @param {*} accumulator The initial value.\n\t * @param {boolean} initAccum Specify using the first or last element of\n\t *  `collection` as the initial value.\n\t * @param {Function} eachFunc The function to iterate over `collection`.\n\t * @returns {*} Returns the accumulated value.\n\t */\n\tfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n\t  eachFunc(collection, function(value, index, collection) {\n\t    accumulator = initAccum\n\t      ? (initAccum = false, value)\n\t      : iteratee(accumulator, value, index, collection);\n\t  });\n\t  return accumulator;\n\t}\n\n\t/**\n\t * Reduces `collection` to a value which is the accumulated result of running\n\t * each element in `collection` thru `iteratee`, where each successive\n\t * invocation is supplied the return value of the previous. If `accumulator`\n\t * is not given, the first element of `collection` is used as the initial\n\t * value. The iteratee is invoked with four arguments:\n\t * (accumulator, value, index|key, collection).\n\t *\n\t * Many lodash methods are guarded to work as iteratees for methods like\n\t * `_.reduce`, `_.reduceRight`, and `_.transform`.\n\t *\n\t * The guarded methods are:\n\t * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n\t * and `sortBy`\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Collection\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t * @param {*} [accumulator] The initial value.\n\t * @returns {*} Returns the accumulated value.\n\t * @see _.reduceRight\n\t * @example\n\t *\n\t * _.reduce([1, 2], function(sum, n) {\n\t *   return sum + n;\n\t * }, 0);\n\t * // => 3\n\t *\n\t * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n\t *   (result[value] || (result[value] = [])).push(key);\n\t *   return result;\n\t * }, {});\n\t * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n\t */\n\tfunction reduce(collection, iteratee, accumulator) {\n\t  var func = isArray(collection) ? arrayReduce : baseReduce,\n\t      initAccum = arguments.length < 3;\n\n\t  return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach);\n\t}\n\n\t/** `Object#toString` result references. */\n\tvar mapTag = '[object Map]',\n\t    setTag = '[object Set]';\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\t/**\n\t * Checks if `value` is an empty object, collection, map, or set.\n\t *\n\t * Objects are considered empty if they have no own enumerable string keyed\n\t * properties.\n\t *\n\t * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n\t * jQuery-like collections are considered empty if they have a `length` of `0`.\n\t * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n\t * @example\n\t *\n\t * _.isEmpty(null);\n\t * // => true\n\t *\n\t * _.isEmpty(true);\n\t * // => true\n\t *\n\t * _.isEmpty(1);\n\t * // => true\n\t *\n\t * _.isEmpty([1, 2, 3]);\n\t * // => false\n\t *\n\t * _.isEmpty({ 'a': 1 });\n\t * // => false\n\t */\n\tfunction isEmpty(value) {\n\t  if (value == null) {\n\t    return true;\n\t  }\n\t  if (isArrayLike(value) &&\n\t      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n\t        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n\t    return !value.length;\n\t  }\n\t  var tag = getTag$1(value);\n\t  if (tag == mapTag || tag == setTag) {\n\t    return !value.size;\n\t  }\n\t  if (isPrototype(value)) {\n\t    return !baseKeys(value).length;\n\t  }\n\t  for (var key in value) {\n\t    if (hasOwnProperty.call(value, key)) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\t/**\n\t * The base implementation of `_.map` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the new mapped array.\n\t */\n\tfunction baseMap(collection, iteratee) {\n\t  var index = -1,\n\t      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n\t  baseEach(collection, function(value, key, collection) {\n\t    result[++index] = iteratee(value, key, collection);\n\t  });\n\t  return result;\n\t}\n\n\t/**\n\t * Creates an array of values by running each element in `collection` thru\n\t * `iteratee`. The iteratee is invoked with three arguments:\n\t * (value, index|key, collection).\n\t *\n\t * Many lodash methods are guarded to work as iteratees for methods like\n\t * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\t *\n\t * The guarded methods are:\n\t * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n\t * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n\t * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n\t * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Collection\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t * @returns {Array} Returns the new mapped array.\n\t * @example\n\t *\n\t * function square(n) {\n\t *   return n * n;\n\t * }\n\t *\n\t * _.map([4, 8], square);\n\t * // => [16, 64]\n\t *\n\t * _.map({ 'a': 4, 'b': 8 }, square);\n\t * // => [16, 64] (iteration order is not guaranteed)\n\t *\n\t * var users = [\n\t *   { 'user': 'barney' },\n\t *   { 'user': 'fred' }\n\t * ];\n\t *\n\t * // The `_.property` iteratee shorthand.\n\t * _.map(users, 'user');\n\t * // => ['barney', 'fred']\n\t */\n\tfunction map(collection, iteratee) {\n\t  var func = isArray(collection) ? arrayMap : baseMap;\n\t  return func(collection, baseIteratee(iteratee));\n\t}\n\n\tvar __defProp$3 = Object.defineProperty;\n\tvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$3 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$3.call(b, prop))\n\t      __defNormalProp$3(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$3)\n\t    for (var prop of __getOwnPropSymbols$3(b)) {\n\t      if (__propIsEnum$3.call(b, prop))\n\t        __defNormalProp$3(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tconst addressFieldsMap$1 = {\n\t  city: \"city\",\n\t  country: \"country\",\n\t  line1: \"address1\",\n\t  line2: \"address2\",\n\t  postal_code: \"zip\",\n\t  state: \"state\"\n\t};\n\tconst billingFieldsMap = {\n\t  name: \"name\",\n\t  phone: \"phone\"\n\t};\n\tfunction mapValues(fieldsMap, data) {\n\t  const result = {};\n\t  for (const [destinationKey, sourceKey] of Object.entries(fieldsMap)) {\n\t    const value = data[sourceKey];\n\t    if (value) {\n\t      result[destinationKey] = value;\n\t    }\n\t  }\n\t  return result;\n\t}\n\tfunction getBillingDetails(cart) {\n\t  const details = __spreadValues$3({}, mapValues(billingFieldsMap, cart.billing));\n\t  if (cart.account && cart.account.email) {\n\t    details.email = cart.account.email;\n\t  }\n\t  const address = mapValues(addressFieldsMap$1, cart.billing);\n\t  if (!isEmpty(address)) {\n\t    details.address = address;\n\t  }\n\t  return details;\n\t}\n\tfunction getKlarnaItems(cart) {\n\t  const currency = toLower(get(cart, \"currency\", \"eur\"));\n\t  const items = map(cart.items, (item) => ({\n\t    type: \"sku\",\n\t    description: item.product.name,\n\t    quantity: item.quantity,\n\t    currency,\n\t    amount: Math.round(toNumber(item.price_total - item.discount_total) * 100)\n\t  }));\n\t  const tax = get(cart, \"tax_included_total\");\n\t  if (tax) {\n\t    items.push({\n\t      type: \"tax\",\n\t      description: \"Taxes\",\n\t      currency,\n\t      amount: Math.round(toNumber(tax) * 100)\n\t    });\n\t  }\n\t  const shipping = get(cart, \"shipping\", {});\n\t  const shippingTotal = get(cart, \"shipment_total\", {});\n\t  if (shipping.price) {\n\t    items.push({\n\t      type: \"shipping\",\n\t      description: shipping.service_name,\n\t      currency,\n\t      amount: Math.round(toNumber(shippingTotal) * 100)\n\t    });\n\t  }\n\t  return items;\n\t}\n\tfunction setKlarnaBillingShipping(source, data) {\n\t  const shippingNameFieldsMap = {\n\t    shipping_first_name: \"first_name\",\n\t    shipping_last_name: \"last_name\"\n\t  };\n\t  const shippingFieldsMap = {\n\t    phone: \"phone\"\n\t  };\n\t  const billingNameFieldsMap = {\n\t    first_name: \"first_name\",\n\t    last_name: \"last_name\"\n\t  };\n\t  const billingFieldsMap2 = {\n\t    email: \"email\"\n\t  };\n\t  const fillValues = (fieldsMap, data2) => reduce(\n\t    fieldsMap,\n\t    (acc, srcKey, destKey) => {\n\t      const value = data2[srcKey];\n\t      if (value) {\n\t        acc[destKey] = value;\n\t      }\n\t      return acc;\n\t    },\n\t    {}\n\t  );\n\t  source.klarna = __spreadValues$3(__spreadValues$3({}, source.klarna), fillValues(shippingNameFieldsMap, data.shipping));\n\t  const shipping = fillValues(shippingFieldsMap, data.shipping);\n\t  const shippingAddress = fillValues(addressFieldsMap$1, data.shipping);\n\t  if (shipping || shippingAddress) {\n\t    source.source_order.shipping = __spreadValues$3(__spreadValues$3({}, shipping ? shipping : {}), shippingAddress ? { address: shippingAddress } : {});\n\t  }\n\t  source.klarna = __spreadValues$3(__spreadValues$3({}, source.klarna), fillValues(\n\t    billingNameFieldsMap,\n\t    data.billing || get(data, \"account.billing\") || data.shipping\n\t  ));\n\t  const billing = fillValues(billingFieldsMap2, data.account);\n\t  const billingAddress = fillValues(\n\t    addressFieldsMap$1,\n\t    data.billing || get(data, \"account.billing\") || data.shipping\n\t  );\n\t  if (billing || billingAddress) {\n\t    source.owner = __spreadValues$3(__spreadValues$3({}, billing ? billing : {}), billingAddress ? { address: billingAddress } : {});\n\t  }\n\t}\n\tfunction setBancontactOwner(source, data) {\n\t  const fillValues = (fieldsMap, data2) => reduce(\n\t    fieldsMap,\n\t    (acc, srcKey, destKey) => {\n\t      const value = data2[srcKey];\n\t      if (value) {\n\t        acc[destKey] = value;\n\t      }\n\t      return acc;\n\t    },\n\t    {}\n\t  );\n\t  const { account = {}, billing, shipping } = data;\n\t  const billingData = __spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3({}, account.shipping), account.billing), shipping), billing);\n\t  const billingAddress = fillValues(addressFieldsMap$1, billingData);\n\t  source.owner = __spreadValues$3(__spreadValues$3({\n\t    email: account.email,\n\t    name: billingData.name || account.name\n\t  }, billingData.phone ? { phone: billingData.phone } : account.phone ? { phone: account.phone } : {}), !isEmpty(billingAddress) ? { address: billingAddress } : {});\n\t}\n\tasync function createPaymentMethod(stripe, cardElement, authorize, cart) {\n\t  const billingDetails = getBillingDetails(cart);\n\t  const { paymentMethod, error: paymentMethodError } = await stripe.createPaymentMethod(__spreadValues$3({\n\t    type: \"card\",\n\t    card: cardElement\n\t  }, !isEmpty(billingDetails) ? { billing_details: billingDetails } : {}));\n\t  if (paymentMethodError) {\n\t    return { error: paymentMethodError };\n\t  }\n\t  const customer = cart.account && cart.account.stripe_customer;\n\t  const authorization = await authorize({\n\t    gateway: \"stripe\",\n\t    params: __spreadValues$3({\n\t      usage: \"off_session\",\n\t      payment_method: paymentMethod.id\n\t    }, customer ? { customer } : {})\n\t  });\n\t  if (!authorization) {\n\t    return;\n\t  }\n\t  const { error: setupIntentError } = await stripe.confirmCardSetup(\n\t    authorization.client_secret\n\t  );\n\t  return setupIntentError ? { error: setupIntentError } : authorization.card;\n\t}\n\tasync function createIDealPaymentMethod(stripe, element, cart) {\n\t  const billingDetails = getBillingDetails(cart);\n\t  return await stripe.createPaymentMethod(__spreadValues$3({\n\t    type: \"ideal\",\n\t    ideal: element\n\t  }, billingDetails ? { billing_details: billingDetails } : {}));\n\t}\n\tasync function createKlarnaSource(stripe, cart) {\n\t  const sourceObject = {\n\t    type: \"klarna\",\n\t    flow: \"redirect\",\n\t    amount: Math.round(get(cart, \"grand_total\", 0) * 100),\n\t    currency: toLower(get(cart, \"currency\", \"eur\")),\n\t    klarna: {\n\t      product: \"payment\",\n\t      purchase_country: get(cart, \"settings.country\", \"DE\")\n\t    },\n\t    source_order: {\n\t      items: getKlarnaItems(cart)\n\t    },\n\t    redirect: {\n\t      return_url: window.location.href\n\t    }\n\t  };\n\t  setKlarnaBillingShipping(sourceObject, cart);\n\t  return await stripe.createSource(sourceObject);\n\t}\n\tasync function createBancontactSource(stripe, cart) {\n\t  const sourceObject = {\n\t    type: \"bancontact\",\n\t    amount: Math.round(get(cart, \"grand_total\", 0) * 100),\n\t    currency: toLower(get(cart, \"currency\", \"eur\")),\n\t    redirect: {\n\t      return_url: window.location.href\n\t    }\n\t  };\n\t  setBancontactOwner(sourceObject, cart);\n\t  return await stripe.createSource(sourceObject);\n\t}\n\tfunction stripeAmountByCurrency(currency, amount) {\n\t  const zeroDecimalCurrencies = [\n\t    \"BIF\",\n\t    \"DJF\",\n\t    \"JPY\",\n\t    \"KRW\",\n\t    \"PYG\",\n\t    \"VND\",\n\t    \"XAF\",\n\t    \"XPF\",\n\t    \"CLP\",\n\t    \"GNF\",\n\t    \"KMF\",\n\t    \"MGA\",\n\t    \"RWF\",\n\t    \"VUV\",\n\t    \"XOF\"\n\t  ];\n\t  if (zeroDecimalCurrencies.includes(currency.toUpperCase())) {\n\t    return amount;\n\t  } else {\n\t    return Math.round(amount * 100);\n\t  }\n\t}\n\n\tfunction generateOrderId() {\n\t  return Math.random().toString(36).substr(2, 9);\n\t}\n\tasync function createQuickpayCard(authorize) {\n\t  const returnUrl = window.location.origin + window.location.pathname;\n\t  const authorization = await authorize({\n\t    gateway: \"quickpay\",\n\t    params: {\n\t      action: \"create\",\n\t      continueurl: `${returnUrl}?gateway=quickpay&redirect_status=succeeded`,\n\t      cancelurl: `${returnUrl}?gateway=quickpay&redirect_status=canceled`\n\t    }\n\t  });\n\t  if (authorization && authorization.url) {\n\t    window.location.replace(authorization.url);\n\t  }\n\t}\n\tasync function getQuickpayCardDetais(id, authorize) {\n\t  return await authorize({\n\t    gateway: \"quickpay\",\n\t    params: { action: \"get\", id }\n\t  });\n\t}\n\tasync function createQuickpayPayment(cart, createIntent) {\n\t  return await createIntent({\n\t    gateway: \"quickpay\",\n\t    intent: {\n\t      currency: get(cart, \"currency\", \"USD\"),\n\t      order_id: generateOrderId()\n\t    }\n\t  });\n\t}\n\n\tasync function createPaysafecardPayment(cart, createIntent) {\n\t  const returnUrl = window.location.origin + window.location.pathname;\n\t  const url = `${returnUrl}?gateway=paysafecard`;\n\t  return await createIntent({\n\t    gateway: \"paysafecard\",\n\t    intent: {\n\t      type: \"PAYSAFECARD\",\n\t      amount: cart.grand_total,\n\t      redirect: {\n\t        success_url: url,\n\t        failure_url: url\n\t      },\n\t      notification_url: url,\n\t      customer: {\n\t        id: get(cart, \"account.id\")\n\t      },\n\t      currency: get(cart, \"currency\", \"USD\")\n\t    }\n\t  });\n\t}\n\n\tvar __defProp$2 = Object.defineProperty;\n\tvar __defProps$1 = Object.defineProperties;\n\tvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\n\tvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$2 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$2.call(b, prop))\n\t      __defNormalProp$2(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$2)\n\t    for (var prop of __getOwnPropSymbols$2(b)) {\n\t      if (__propIsEnum$2.call(b, prop))\n\t        __defNormalProp$2(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\n\tconst addressFieldsMap = {\n\t  given_name: \"first_name\",\n\t  family_name: \"last_name\",\n\t  city: \"city\",\n\t  country: \"country\",\n\t  phone: \"phone\",\n\t  postal_code: \"zip\",\n\t  street_address: \"address1\",\n\t  street_address2: \"address2\",\n\t  region: \"state\"\n\t};\n\tconst mapFields = (fieldsMap, data) => reduce(\n\t  fieldsMap,\n\t  (acc, srcKey, destKey) => {\n\t    const value = data[srcKey];\n\t    if (value) {\n\t      acc[destKey] = value;\n\t    }\n\t    return acc;\n\t  },\n\t  {}\n\t);\n\tconst mapAddressFields = (cart, addressField) => __spreadProps$1(__spreadValues$2({}, mapFields(addressFieldsMap, cart[addressField])), {\n\t  email: get(cart, \"account.email\")\n\t});\n\tfunction getOrderLines(cart) {\n\t  const items = map(cart.items, (item) => ({\n\t    type: \"physical\",\n\t    name: get(item, \"product.name\"),\n\t    reference: get(item, \"product.sku\") || get(item, \"product.slug\"),\n\t    quantity: item.quantity,\n\t    unit_price: Math.round(toNumber(item.price - item.discount_each) * 100),\n\t    total_amount: Math.round(\n\t      toNumber(item.price_total - item.discount_total) * 100\n\t    ),\n\t    tax_rate: 0,\n\t    total_tax_amount: 0\n\t  }));\n\t  const tax = get(cart, \"tax_included_total\");\n\t  const taxAmount = toNumber(tax) * 100;\n\t  if (tax) {\n\t    items.push({\n\t      type: \"sales_tax\",\n\t      name: \"Taxes\",\n\t      quantity: 1,\n\t      unit_price: taxAmount,\n\t      total_amount: taxAmount,\n\t      tax_rate: 0,\n\t      total_tax_amount: 0\n\t    });\n\t  }\n\t  const shipping = get(cart, \"shipping\", {});\n\t  const shippingTotal = get(cart, \"shipment_total\", {});\n\t  const shippingAmount = toNumber(shippingTotal) * 100;\n\t  if (shipping.price) {\n\t    items.push({\n\t      type: \"shipping_fee\",\n\t      name: shipping.service_name,\n\t      quantity: 1,\n\t      unit_price: shippingAmount,\n\t      total_amount: shippingAmount,\n\t      tax_rate: 0,\n\t      total_tax_amount: 0\n\t    });\n\t  }\n\t  return items;\n\t}\n\tasync function createKlarnaSession(cart, createIntent) {\n\t  const returnUrl = `${window.location.origin}${window.location.pathname}?gateway=klarna_direct&sid={{session_id}}`;\n\t  const successUrl = `${returnUrl}&authorization_token={{authorization_token}}`;\n\t  return createIntent({\n\t    gateway: \"klarna\",\n\t    intent: {\n\t      locale: cart.display_locale || get(cart, \"settings.locale\") || \"en-US\",\n\t      purchase_country: get(cart, \"billing.country\") || get(cart, \"shipping.country\"),\n\t      purchase_currency: cart.currency,\n\t      billing_address: mapAddressFields(cart, \"billing\"),\n\t      shipping_address: mapAddressFields(cart, \"shipping\"),\n\t      order_amount: Math.round(get(cart, \"grand_total\", 0) * 100),\n\t      order_lines: JSON.stringify(getOrderLines(cart)),\n\t      merchant_urls: {\n\t        success: successUrl,\n\t        back: returnUrl,\n\t        cancel: returnUrl,\n\t        error: returnUrl,\n\t        failure: returnUrl\n\t      }\n\t    }\n\t  });\n\t}\n\n\tvar __defProp$1 = Object.defineProperty;\n\tvar __defProps = Object.defineProperties;\n\tvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\n\tvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues$1 = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp$1.call(b, prop))\n\t      __defNormalProp$1(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols$1)\n\t    for (var prop of __getOwnPropSymbols$1(b)) {\n\t      if (__propIsEnum$1.call(b, prop))\n\t        __defNormalProp$1(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\tconst LOADING_SCRIPTS = {};\n\tconst CARD_ELEMENTS = {};\n\tconst API = {};\n\tlet options$1 = null;\n\tfunction methods$2(request, opts) {\n\t  options$1 = opts || options$1;\n\t  return {\n\t    params: null,\n\t    methodSettings: null,\n\t    get(id) {\n\t      return request(\"get\", \"/payments\", id);\n\t    },\n\t    async methods() {\n\t      if (this.methodSettings) {\n\t        return this.methodSettings;\n\t      }\n\t      const result = await request(\"get\", \"/payment/methods\");\n\t      return this.methodSettings = result;\n\t    },\n\t    async createElements(elementParams) {\n\t      this.params = elementParams || {};\n\t      const cart = toSnake(await methods$8(request, options$1).get());\n\t      if (!cart) {\n\t        throw new Error(\"Cart not found\");\n\t      }\n\t      const payMethods = toSnake(\n\t        await methods$3(request, options$1).payments()\n\t      );\n\t      if (payMethods.error) {\n\t        throw new Error(payMethods.error);\n\t      }\n\t      await render(request, cart, payMethods, this.params);\n\t    },\n\t    async tokenize(params) {\n\t      const cart = toSnake(await methods$8(request, options$1).get());\n\t      if (!cart) {\n\t        throw new Error(\"Cart not found\");\n\t      }\n\t      const payMethods = toSnake(\n\t        await methods$3(request, options$1).payments()\n\t      );\n\t      if (payMethods.error) {\n\t        throw new Error(payMethods.error);\n\t      }\n\t      return await paymentTokenize(\n\t        request,\n\t        params || this.params,\n\t        payMethods,\n\t        cart\n\t      );\n\t    },\n\t    async handleRedirect(params) {\n\t      const cart = toSnake(await methods$8(request, options$1).get());\n\t      if (!cart) {\n\t        throw new Error(\"Cart not found\");\n\t      }\n\t      return await handleRedirect(request, params || this.params, cart);\n\t    },\n\t    async authenticate(id) {\n\t      const payment = await this.get(id);\n\t      if (!payment) {\n\t        throw new Error(\"Payment not found\");\n\t      }\n\t      const payMethods = toSnake(\n\t        await methods$3(request, options$1).payments()\n\t      );\n\t      if (payMethods.error) {\n\t        throw new Error(payMethods.error);\n\t      }\n\t      return await authenticate(request, payment, payMethods);\n\t    },\n\t    async createIntent(data) {\n\t      const intent = await vaultRequest(\"post\", \"/intent\", data);\n\t      if (intent.errors) {\n\t        const param = Object.keys(intent.errors)[0];\n\t        const err = new Error(intent.errors[param].message || \"Unknown error\");\n\t        err.code = \"vault_error\";\n\t        err.status = 402;\n\t        err.param = param;\n\t        throw err;\n\t      }\n\t      return intent;\n\t    },\n\t    async updateIntent(data) {\n\t      const intent = await vaultRequest(\"put\", \"/intent\", data);\n\t      if (intent.errors) {\n\t        const param = Object.keys(intent.errors)[0];\n\t        const err = new Error(intent.errors[param].message || \"Unknown error\");\n\t        err.code = \"vault_error\";\n\t        err.status = 402;\n\t        err.param = param;\n\t        throw err;\n\t      }\n\t      return intent;\n\t    },\n\t    async authorizeGateway(data) {\n\t      const authorization = await vaultRequest(\"post\", \"/authorization\", data);\n\t      if (authorization.errors) {\n\t        const param = Object.keys(authorization.errors)[0];\n\t        const err = new Error(\n\t          authorization.errors[param].message || \"Unknown error\"\n\t        );\n\t        err.code = \"vault_error\";\n\t        err.status = 402;\n\t        err.param = param;\n\t        throw err;\n\t      }\n\t      return authorization;\n\t    }\n\t  };\n\t}\n\tasync function render(request, cart, payMethods, params) {\n\t  if (params.card) {\n\t    if (!payMethods.card) {\n\t      console.error(\n\t        `Payment element error: credit card payments are disabled. See Payment settings in the Swell dashboard for details.`\n\t      );\n\t    } else if (payMethods.card.gateway === \"braintree\") {\n\t      if (!window.braintree) {\n\t        await loadScript(\n\t          \"braintree-web\",\n\t          \"https://js.braintreegateway.com/web/3.57.0/js/client.min.js\"\n\t        );\n\t      }\n\t    } else if (payMethods.card.gateway === \"stripe\") {\n\t      if (!window.Stripe) {\n\t        await loadScript(\"stripe-js\", \"https://js.stripe.com/v3/\");\n\t      }\n\t      await stripeElements(request, payMethods, params);\n\t    }\n\t  }\n\t  if (params.ideal) {\n\t    if (!payMethods.card) {\n\t      console.error(\n\t        `Payment element error: credit card payments are disabled. See Payment settings in the Swell dashboard for details.`\n\t      );\n\t    } else if (!payMethods.ideal) {\n\t      console.error(\n\t        `Payment element error: iDEAL payments are disabled. See Payment settings in the Swell dashboard for details.`\n\t      );\n\t    } else if (payMethods.card.gateway === \"stripe\") {\n\t      if (!window.Stripe) {\n\t        await loadScript(\"stripe-js\", \"https://js.stripe.com/v3/\");\n\t      }\n\t      await stripeElements(request, payMethods, params);\n\t    }\n\t  }\n\t  if (params.paypal) {\n\t    if (!payMethods.paypal) {\n\t      console.error(\n\t        `Payment element error: PayPal payments are disabled. See Payment settings in the Swell dashboard for details.`\n\t      );\n\t    } else if (payMethods.card && payMethods.card.gateway === \"braintree\" && payMethods.paypal.gateway === \"braintree\") {\n\t      if (!window.paypal) {\n\t        await loadScript(\n\t          \"paypal-sdk\",\n\t          `https://www.paypal.com/sdk/js?currency=${cart.currency}&client-id=${payMethods.paypal.client_id}&merchant-id=${payMethods.paypal.merchant_id}&vault=true`\n\t        );\n\t      }\n\t      if (!window.braintree) {\n\t        await loadScript(\n\t          \"braintree-web\",\n\t          \"https://js.braintreegateway.com/web/3.57.0/js/client.min.js\"\n\t        );\n\t      }\n\t      if (window.braintree && !window.braintree.paypalCheckout) {\n\t        await loadScript(\n\t          \"braintree-web-paypal-checkout\",\n\t          \"https://js.braintreegateway.com/web/3.57.0/js/paypal-checkout.min.js\"\n\t        );\n\t      }\n\t      await braintreePayPalButton(request, cart, payMethods, params);\n\t    } else {\n\t      if (!window.paypal) {\n\t        await loadScript(\n\t          \"paypal-sdk\",\n\t          `https://www.paypal.com/sdk/js?currency=${cart.currency}&client-id=${payMethods.paypal.client_id}&merchant-id=${payMethods.paypal.merchant_id}&intent=authorize&commit=false`\n\t        );\n\t      }\n\t      await payPalButton(request, cart, payMethods, params);\n\t    }\n\t  }\n\t}\n\tconst loadScript = async (id, src) => {\n\t  LOADING_SCRIPTS[id] = LOADING_SCRIPTS[id] || new Promise((resolve) => {\n\t    const script = document.createElement(\"script\");\n\t    script.id = id;\n\t    script.src = src;\n\t    script.async = true;\n\t    script.type = \"text/javascript\";\n\t    script.addEventListener(\n\t      \"load\",\n\t      () => {\n\t        resolve();\n\t        LOADING_SCRIPTS[id] = null;\n\t      },\n\t      {\n\t        once: true\n\t      }\n\t    );\n\t    document.head.appendChild(script);\n\t  });\n\t  return LOADING_SCRIPTS[id];\n\t};\n\tasync function stripeElements(request, payMethods, params) {\n\t  const { publishable_key } = payMethods.card;\n\t  const stripe = window.Stripe(publishable_key);\n\t  const elements = stripe.elements(params.config);\n\t  const createElement = (type) => {\n\t    const elementParams = get(params, `card[${type}]`) || params.card || params.ideal;\n\t    const elementOptions = elementParams.options || {};\n\t    const element = elements.create(type, elementOptions);\n\t    element.mount(elementParams.elementId || `#${type}-element`);\n\t    elementParams.onChange && element.on(\"change\", elementParams.onChange);\n\t    elementParams.onReady && element.on(\"ready\", elementParams.onReady);\n\t    elementParams.onFocus && element.on(\"focus\", elementParams.onFocus);\n\t    elementParams.onBlur && element.on(\"blur\", elementParams.onBlur);\n\t    elementParams.onEscape && element.on(\"escape\", elementParams.onEscape);\n\t    elementParams.onClick && element.on(\"click\", elementParams.onClick);\n\t    if (type === \"card\" || type === \"cardNumber\" || type === \"idealBank\") {\n\t      CARD_ELEMENTS.stripe = element;\n\t    }\n\t  };\n\t  API.stripe = stripe;\n\t  if (params.ideal) {\n\t    createElement(\"idealBank\");\n\t  } else if (params.card.separateElements) {\n\t    createElement(\"cardNumber\");\n\t    createElement(\"cardExpiry\");\n\t    createElement(\"cardCvc\");\n\t  } else {\n\t    createElement(\"card\");\n\t  }\n\t}\n\tasync function shouldUsePayPalEmail(guest, request, options2) {\n\t  if (!guest)\n\t    return false;\n\t  const updatedCart = await methods$8(request, options2).get();\n\t  const currentEmail = get(updatedCart, \"account.email\");\n\t  if (!currentEmail) {\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tasync function payPalButton(request, cart, payMethods, params) {\n\t  const paypal = window.paypal;\n\t  const { paypal: { locale, style, elementId } = {} } = params;\n\t  const { capture_total, currency, guest } = cart;\n\t  const onError = (error) => {\n\t    const errorHandler = get(params, \"paypal.onError\");\n\t    if (isFunction(errorHandler)) {\n\t      return errorHandler(error);\n\t    }\n\t    throw new Error(error.message);\n\t  };\n\t  const onSuccess = () => {\n\t    const successHandler = get(params, \"paypal.onSuccess\");\n\t    return isFunction(successHandler) && successHandler();\n\t  };\n\t  if (!(capture_total > 0)) {\n\t    throw new Error(\n\t      \"Invalid PayPal button amount. Value should be greater than zero.\"\n\t    );\n\t  }\n\t  paypal.Buttons(\n\t    {\n\t      locale: locale || \"en_US\",\n\t      style: style || {\n\t        layout: \"horizontal\",\n\t        height: 45,\n\t        color: \"gold\",\n\t        shape: \"rect\",\n\t        label: \"paypal\",\n\t        tagline: false\n\t      },\n\t      createOrder: (data, actions) => actions.order.create({\n\t        intent: \"AUTHORIZE\",\n\t        purchase_units: [\n\t          {\n\t            amount: {\n\t              value: +capture_total.toFixed(2),\n\t              currency_code: currency\n\t            }\n\t          }\n\t        ]\n\t      }),\n\t      onApprove: (data, actions) => actions.order.get().then(async (order) => {\n\t        const orderId = order.id;\n\t        const payer = order.payer;\n\t        const shipping = get(order, \"purchase_units[0].shipping\");\n\t        const usePayPalEmail = await shouldUsePayPalEmail(\n\t          guest,\n\t          request,\n\t          options$1\n\t        );\n\t        return methods$8(request).update(__spreadProps(__spreadValues$1({}, usePayPalEmail && {\n\t          account: {\n\t            email: payer.email_address\n\t          }\n\t        }), {\n\t          billing: {\n\t            method: \"paypal\",\n\t            paypal: { order_id: orderId }\n\t          },\n\t          shipping: {\n\t            name: shipping.name.full_name,\n\t            address1: shipping.address.address_line_1,\n\t            address2: shipping.address.address_line_2,\n\t            state: shipping.address.admin_area_1,\n\t            city: shipping.address.admin_area_2,\n\t            zip: shipping.address.postal_code,\n\t            country: shipping.address.country_code\n\t          }\n\t        }));\n\t      }).then(onSuccess).catch(onError)\n\t    },\n\t    onError\n\t  ).render(elementId || \"#paypal-button\");\n\t}\n\tasync function braintreePayPalButton(request, cart, payMethods, params) {\n\t  const authorization = await vaultRequest(\"post\", \"/authorization\", {\n\t    gateway: \"braintree\"\n\t  });\n\t  if (authorization.error) {\n\t    throw new Error(authorization.error);\n\t  }\n\t  const braintree = window.braintree;\n\t  const paypal = window.paypal;\n\t  braintree.client.create({\n\t    authorization\n\t  }).then(\n\t    (client) => braintree.paypalCheckout.create({\n\t      client\n\t    })\n\t  ).then((paypalCheckoutInstance) => {\n\t    return paypal.Buttons({\n\t      style: params.paypal.style || {},\n\t      createBillingAgreement: () => paypalCheckoutInstance.createPayment({\n\t        flow: \"vault\",\n\t        currency: cart.currency,\n\t        amount: cart.grand_total\n\t      }),\n\t      onApprove: (data, actions) => paypalCheckoutInstance.tokenizePayment(data).then(\n\t        ({ nonce }) => methods$8(request, options$1).update({\n\t          billing: { paypal: { nonce } }\n\t        })\n\t      ).then(\n\t        () => isFunction(params.paypal.onSuccess) && params.paypal.onSuccess(data, actions)\n\t      ).catch(\n\t        isFunction(params.paypal.onError) ? params.paypal.onError : (err) => console.error(\"PayPal error\", err)\n\t      ),\n\t      onCancel: isFunction(params.paypal.onCancel) ? () => params.paypal.onCancel() : () => console.log(\"PayPal payment cancelled\"),\n\t      onError: isFunction(params.paypal.onError) ? (err) => params.paypal.onError(err) : (err) => console.error(\"PayPal error\", err)\n\t    }).render(params.paypal.elementId || \"#paypal-button\");\n\t  }).catch(\n\t    isFunction(params.paypal.onError) ? params.paypal.onError : (err) => console.error(\"PayPal error\", err)\n\t  );\n\t}\n\tasync function paymentTokenize(request, params, payMethods, cart) {\n\t  const { capture_total, auth_total } = cart;\n\t  const onError = (error) => {\n\t    const errorHandler = get(params, \"card.onError\") || get(params, \"ideal.onError\") || get(params, \"klarna.onError\") || get(params, \"bancontact.onError\") || get(params, \"paysafecard.onError\");\n\t    if (isFunction(errorHandler)) {\n\t      return errorHandler(error);\n\t    }\n\t    throw new Error(error.message);\n\t  };\n\t  const onSuccess = (result) => {\n\t    const successHandler = get(params, \"card.onSuccess\") || get(params, \"ideal.onSuccess\");\n\t    if (isFunction(successHandler)) {\n\t      return successHandler(result);\n\t    }\n\t  };\n\t  if (!params) {\n\t    return onError({ message: \"Tokenization parameters not passed\" });\n\t  }\n\t  if (params.card && payMethods.card) {\n\t    if (payMethods.card.gateway === \"stripe\" && CARD_ELEMENTS.stripe && API.stripe) {\n\t      const stripe = API.stripe;\n\t      const paymentMethod = await createPaymentMethod(\n\t        stripe,\n\t        CARD_ELEMENTS.stripe,\n\t        methods$2(request).authorizeGateway,\n\t        cart\n\t      ).catch(onError);\n\t      if (!paymentMethod) {\n\t        return;\n\t      } else if (paymentMethod.error) {\n\t        return onError(paymentMethod.error);\n\t      } else if (capture_total < 1) {\n\t        return methods$8(request, options$1).update({\n\t          billing: {\n\t            method: \"card\",\n\t            card: paymentMethod\n\t          }\n\t        }).then(onSuccess).catch(onError);\n\t      }\n\t      const currency = toLower(get(cart, \"currency\", \"usd\"));\n\t      const amount = stripeAmountByCurrency(\n\t        currency,\n\t        capture_total + auth_total\n\t      );\n\t      const stripeCustomer = get(cart, \"account.stripe_customer\");\n\t      const intent = toSnake(\n\t        await methods$2(request).createIntent({\n\t          gateway: \"stripe\",\n\t          intent: __spreadValues$1({\n\t            payment_method: paymentMethod.token,\n\t            amount,\n\t            currency,\n\t            capture_method: \"manual\",\n\t            off_session: true,\n\t            confirm: true\n\t          }, stripeCustomer ? { customer: stripeCustomer } : {})\n\t        }).catch(onError)\n\t      );\n\t      if (intent && intent.status === \"requires_confirmation\") {\n\t        const { paymentIntent, error } = await stripe.confirmCardPayment(\n\t          intent.client_secret\n\t        );\n\t        return error ? onError(error) : await methods$8(request, options$1).update({\n\t          billing: {\n\t            method: \"card\",\n\t            card: paymentMethod,\n\t            intent: {\n\t              stripe: __spreadValues$1({\n\t                id: paymentIntent.id\n\t              }, !!auth_total && {\n\t                auth_amount: auth_total\n\t              })\n\t            }\n\t          }\n\t        }).then(onSuccess).catch(onError);\n\t      }\n\t    } else if (payMethods.card.gateway === \"quickpay\") {\n\t      const intent = await createQuickpayPayment(\n\t        cart,\n\t        methods$2(request).createIntent\n\t      ).catch(onError);\n\t      if (!intent) {\n\t        return;\n\t      } else if (intent.error) {\n\t        return onError(intent.error);\n\t      }\n\t      await methods$8(request, options$1).update({\n\t        billing: {\n\t          method: \"card\",\n\t          intent: {\n\t            quickpay: {\n\t              id: intent\n\t            }\n\t          }\n\t        }\n\t      });\n\t      createQuickpayCard(methods$2(request).authorizeGateway).catch(onError);\n\t    }\n\t  } else if (params.ideal && payMethods.ideal) {\n\t    if (payMethods.card && payMethods.card.gateway === \"stripe\" && CARD_ELEMENTS.stripe && API.stripe) {\n\t      const { error, paymentMethod } = await createIDealPaymentMethod(\n\t        API.stripe,\n\t        CARD_ELEMENTS.stripe,\n\t        cart\n\t      );\n\t      if (error) {\n\t        return onError(error);\n\t      }\n\t      const currency = toLower(get(cart, \"currency\", \"eur\"));\n\t      const amount = stripeAmountByCurrency(currency, capture_total);\n\t      const intent = toSnake(\n\t        await methods$2(request).createIntent({\n\t          gateway: \"stripe\",\n\t          intent: {\n\t            payment_method: paymentMethod.id,\n\t            amount,\n\t            currency,\n\t            payment_method_types: \"ideal\",\n\t            confirmation_method: \"manual\",\n\t            confirm: true,\n\t            return_url: window.location.href\n\t          }\n\t        }).catch(onError)\n\t      );\n\t      if (intent) {\n\t        await methods$8(request, options$1).update({\n\t          billing: {\n\t            method: \"ideal\",\n\t            ideal: {\n\t              token: paymentMethod.id\n\t            },\n\t            intent: { stripe: { id: intent.id } }\n\t          }\n\t        }).catch(onError);\n\t        return (intent.status === \"requires_action\" || intent.status === \"requires_source_action\") && await API.stripe.handleCardAction(intent.client_secret);\n\t      }\n\t    }\n\t  } else if (params.klarna && payMethods.klarna) {\n\t    if (payMethods.klarna.gateway === \"klarna\") {\n\t      const session = await createKlarnaSession(\n\t        cart,\n\t        methods$2(request).createIntent\n\t      ).catch(onError);\n\t      return session && window.location.replace(session.redirect_url);\n\t    } else if (payMethods.card && payMethods.card.gateway === \"stripe\") {\n\t      if (!window.Stripe) {\n\t        await loadScript(\"stripe-js\", \"https://js.stripe.com/v3/\");\n\t      }\n\t      const { publishable_key } = payMethods.card;\n\t      const stripe = window.Stripe(publishable_key);\n\t      const settings = toSnake(await methods$3(request, options$1).get());\n\t      const { error, source } = await createKlarnaSource(stripe, __spreadProps(__spreadValues$1({}, cart), {\n\t        settings: settings.store\n\t      }));\n\t      return error ? onError(error) : methods$8(request, options$1).update({\n\t        billing: {\n\t          method: \"klarna\"\n\t        }\n\t      }).then(() => window.location.replace(source.redirect.url)).catch(onError);\n\t    }\n\t  } else if (params.bancontact && payMethods.bancontact) {\n\t    if (payMethods.card && payMethods.card.gateway === \"stripe\") {\n\t      if (!window.Stripe) {\n\t        await loadScript(\"stripe-js\", \"https://js.stripe.com/v3/\");\n\t      }\n\t      const { publishable_key } = payMethods.card;\n\t      const stripe = window.Stripe(publishable_key);\n\t      const { error, source } = await createBancontactSource(stripe, cart);\n\t      return error ? onError(error) : methods$8(request, options$1).update({\n\t        billing: {\n\t          method: \"bancontact\"\n\t        }\n\t      }).then(() => window.location.replace(source.redirect.url)).catch(onError);\n\t    }\n\t  } else if (params.paysafecard && payMethods.paysafecard) {\n\t    const intent = await createPaysafecardPayment(\n\t      cart,\n\t      methods$2(request).createIntent\n\t    ).catch(onError);\n\t    if (!intent) {\n\t      return;\n\t    }\n\t    await methods$8(request, options$1).update({\n\t      billing: {\n\t        method: \"paysafecard\",\n\t        intent: {\n\t          paysafecard: {\n\t            id: intent.id\n\t          }\n\t        }\n\t      }\n\t    });\n\t    return window.location.replace(intent.redirect.auth_url);\n\t  }\n\t}\n\tasync function handleRedirect(request, params, cart) {\n\t  const onError = (error) => {\n\t    const errorHandler = get(params, \"card.onError\") || get(params, \"paysafecard.onError\") || get(params, \"klarna.onError\");\n\t    if (isFunction(errorHandler)) {\n\t      return errorHandler(error);\n\t    }\n\t    throw new Error(error.message);\n\t  };\n\t  const onSuccess = (result2) => {\n\t    const successHandler = get(params, \"card.onSuccess\") || get(params, \"paysafecard.onSuccess\") || get(params, \"klarna.onSuccess\");\n\t    if (isFunction(successHandler)) {\n\t      return successHandler(result2);\n\t    }\n\t  };\n\t  const queryParams = getLocationParams(window.location);\n\t  removeUrlParams();\n\t  const { gateway } = queryParams;\n\t  let result;\n\t  if (gateway === \"quickpay\") {\n\t    result = await handleQuickpayRedirectAction(\n\t      request,\n\t      cart,\n\t      params,\n\t      queryParams\n\t    );\n\t  } else if (gateway === \"paysafecard\") {\n\t    result = await handlePaysafecardRedirectAction(\n\t      request,\n\t      cart);\n\t  } else if (gateway === \"klarna_direct\") {\n\t    result = await handleDirectKlarnaRedirectAction(\n\t      request,\n\t      cart,\n\t      params,\n\t      queryParams\n\t    );\n\t  }\n\t  if (!result) {\n\t    return;\n\t  } else if (result.error) {\n\t    return onError(result.error);\n\t  } else {\n\t    return onSuccess(result);\n\t  }\n\t}\n\tasync function handleQuickpayRedirectAction(request, cart, params, queryParams) {\n\t  const { redirect_status: status, card_id: id } = queryParams;\n\t  switch (status) {\n\t    case \"succeeded\":\n\t      const card = await getQuickpayCardDetais(\n\t        id,\n\t        methods$2(request).authorizeGateway\n\t      );\n\t      if (!card) {\n\t        return;\n\t      } else if (card.error) {\n\t        return card;\n\t      } else {\n\t        await methods$8(request, options$1).update({\n\t          billing: {\n\t            method: \"card\",\n\t            card\n\t          }\n\t        });\n\t        return { success: true };\n\t      }\n\t    case \"canceled\":\n\t      return {\n\t        error: {\n\t          message: \"We are unable to authenticate your payment method. Please choose a different payment method and try again.\"\n\t        }\n\t      };\n\t    default:\n\t      return { error: { message: `Unknown redirect status: ${status}.` } };\n\t  }\n\t}\n\tasync function handlePaysafecardRedirectAction(request, cart) {\n\t  const paymentId = get(cart, \"billing.intent.paysafecard.id\");\n\t  if (!paymentId) {\n\t    return {\n\t      error: {\n\t        message: \"Paysafecard payment ID not defined.\"\n\t      }\n\t    };\n\t  }\n\t  const intent = await methods$2(request).updateIntent({\n\t    gateway: \"paysafecard\",\n\t    intent: { payment_id: paymentId }\n\t  });\n\t  if (!intent) {\n\t    return;\n\t  }\n\t  switch (intent.status) {\n\t    case \"AUTHORIZED\":\n\t      return { success: true };\n\t    case \"CANCELED_CUSTOMER\":\n\t      return {\n\t        error: {\n\t          message: \"We are unable to authenticate your payment method. Please choose a different payment method and try again.\"\n\t        }\n\t      };\n\t    default:\n\t      return {\n\t        error: { message: `Unknown redirect status: ${intent.status}.` }\n\t      };\n\t  }\n\t}\n\tasync function handleDirectKlarnaRedirectAction(request, cart, params, queryParams) {\n\t  const { authorization_token } = queryParams;\n\t  if (!authorization_token) {\n\t    return {\n\t      error: {\n\t        message: \"We are unable to authenticate your payment method. Please choose a different payment method and try again.\"\n\t      }\n\t    };\n\t  }\n\t  await methods$8(request, options$1).update({\n\t    billing: {\n\t      method: \"klarna\",\n\t      klarna: {\n\t        token: authorization_token\n\t      }\n\t    }\n\t  });\n\t  return { success: true };\n\t}\n\tasync function authenticate(request, payment, payMethods) {\n\t  const { method, gateway } = payment;\n\t  if (method === \"card\") {\n\t    const cardMethod = payMethods.card;\n\t    if (!cardMethod) {\n\t      console.error(\n\t        `Authenticate error: credit card payments are disabled. See Payment settings in the Swell dashboard for details.`\n\t      );\n\t    } else if (gateway === \"stripe\" && cardMethod.gateway === \"stripe\") {\n\t      if (!window.Stripe) {\n\t        await loadScript(\"stripe-js\", \"https://js.stripe.com/v3/\");\n\t      }\n\t      return authenticateStripeCard(request, payment, payMethods);\n\t    }\n\t  }\n\t}\n\tasync function authenticateStripeCard(request, payment, payMethods) {\n\t  const { transaction_id: id, card: { token } = {} } = payment;\n\t  const { publishable_key } = payMethods.card;\n\t  const intent = await methods$2(request, options$1).updateIntent({\n\t    gateway: \"stripe\",\n\t    intent: { id, payment_method: token }\n\t  }).catch((error) => ({\n\t    error\n\t  }));\n\t  if (intent.error) {\n\t    return intent;\n\t  }\n\t  const stripe = window.Stripe(publishable_key);\n\t  const actionResult = await stripe.confirmCardPayment(intent.client_secret);\n\t  return actionResult.error ? {\n\t    error: {\n\t      message: actionResult.error.message,\n\t      code: actionResult.error.code\n\t    }\n\t  } : { status: actionResult.status };\n\t}\n\n\tfunction methods$1(request, opt) {\n\t  return {\n\t    code: null,\n\t    state: null,\n\t    list() {\n\t      return opt.api.settings.get(\"store.locales\", []);\n\t    },\n\t    async select(locale) {\n\t      this.set(locale);\n\t      setCookie(\"swell-locale\", locale);\n\t      opt.api.settings.locale = locale;\n\t      return await request(\"put\", \"/session\", { locale });\n\t    },\n\t    selected() {\n\t      if (this.code) {\n\t        return this.code;\n\t      }\n\t      const storeLocale = opt.api.settings.getStoreLocale();\n\t      const cookieLocale = getCookie(\"swell-locale\");\n\t      opt.api.settings.locale = cookieLocale || storeLocale;\n\t      return cookieLocale || storeLocale;\n\t    },\n\t    get() {\n\t      if (!this.code) {\n\t        this.code = this.selected();\n\t      }\n\t      if (!this.state) {\n\t        this.state = this.set(this.code);\n\t      }\n\t      return this.state;\n\t    },\n\t    set(code) {\n\t      this.code = code;\n\t      this.state = find(this.list(), { code }) || {};\n\t      return this.state;\n\t    }\n\t  };\n\t}\n\n\tconst FORMATTERS = {};\n\tfunction methods(request, opt) {\n\t  return {\n\t    code: null,\n\t    state: null,\n\t    locale: null,\n\t    list() {\n\t      return opt.api.settings.get(\"store.currencies\", []);\n\t    },\n\t    async select(currency) {\n\t      this.set(currency);\n\t      return request(\"put\", \"/session\", { currency });\n\t    },\n\t    selected() {\n\t      if (!this.code) {\n\t        this.set(\n\t          getCookie(\"swell-currency\") || opt.api.settings.get(\"store.currency\")\n\t        );\n\t      }\n\t      return this.code;\n\t    },\n\t    get() {\n\t      if (!this.code) {\n\t        this.code = this.selected();\n\t      }\n\t      if (!this.state) {\n\t        this.state = this.set(this.code);\n\t      }\n\t      return this.state;\n\t    },\n\t    set(code = \"USD\") {\n\t      this.code = code;\n\t      this.state = find(this.list(), { code }) || { code };\n\t      this.locale = String(\n\t        opt.api.settings.get(\n\t          \"store.locale\",\n\t          typeof navigator === \"object\" ? navigator.language : \"en-US\"\n\t        )\n\t      );\n\t      setCookie(\"swell-currency\", code);\n\t      return this.state;\n\t    },\n\t    format(amount, params = {}) {\n\t      let state = this.get();\n\t      if (params.code && params.code !== state.code) {\n\t        const list = this.list();\n\t        state = find(list, { code: params.code }) || { code: params.code };\n\t      }\n\t      const { code = \"USD\", type, decimals, rate } = state;\n\t      const formatCode = params.code || code;\n\t      const formatRate = params.rate || rate;\n\t      const formatLocale = params.locale || this.locale;\n\t      const formatDecimals = typeof params.decimals === \"number\" ? params.decimals : decimals;\n\t      const { convert = true } = params;\n\t      let formatAmount = amount;\n\t      if (convert && (type === \"display\" || params.rate) && typeof formatAmount === \"number\" && typeof formatRate === \"number\") {\n\t        formatAmount = this.applyRounding(amount * formatRate, state);\n\t      }\n\t      const formatter = this.formatter({\n\t        code: formatCode,\n\t        locale: formatLocale,\n\t        decimals: formatDecimals\n\t      });\n\t      try {\n\t        if (typeof formatAmount === \"number\") {\n\t          return formatter.format(formatAmount);\n\t        } else {\n\t          const symbol = get(formatter.formatToParts(0), \"0.value\", \"$\");\n\t          return symbol !== formatCode ? symbol : \"\";\n\t        }\n\t      } catch (err) {\n\t        console.warn(err);\n\t      }\n\t      return String(amount);\n\t    },\n\t    formatter({ code, locale, decimals }) {\n\t      locale = String(locale || \"\").replace(\"_\", \"-\");\n\t      const key = [code, locale, decimals].join(\"|\");\n\t      if (FORMATTERS[key]) {\n\t        return FORMATTERS[key];\n\t      }\n\t      const formatLocales = [];\n\t      if (locale) {\n\t        formatLocales.push(locale);\n\t      }\n\t      formatLocales.push(\"en-US\");\n\t      const formatDecimals = typeof decimals === \"number\" ? decimals : void 0;\n\t      const props = {\n\t        style: \"currency\",\n\t        currency: code,\n\t        currencyDisplay: \"symbol\",\n\t        minimumFractionDigits: formatDecimals,\n\t        maximumFractionDigits: formatDecimals\n\t      };\n\t      try {\n\t        try {\n\t          FORMATTERS[key] = new Intl.NumberFormat(formatLocales, props);\n\t        } catch (err) {\n\t          if (err.message.indexOf(\"Invalid language tag\") >= 0) {\n\t            FORMATTERS[key] = new Intl.NumberFormat(\"en-US\", props);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        console.warn(err);\n\t      }\n\t      return FORMATTERS[key];\n\t    },\n\t    applyRounding(value, config) {\n\t      if (!config || !config.round) {\n\t        return value;\n\t      }\n\t      const scale = config.decimals;\n\t      const fraction = config.round_interval === \"fraction\" ? config.round_fraction || 0 : 0;\n\t      let roundValue = ~~value;\n\t      let decimalValue = this.round(value, scale);\n\t      if (decimalValue === fraction) {\n\t        return roundValue + decimalValue;\n\t      }\n\t      const diff = this.round(decimalValue - fraction, 1);\n\t      const direction = config.round === \"nearest\" ? diff > 0 ? diff >= 0.5 ? \"up\" : \"down\" : diff <= -0.5 ? \"down\" : \"up\" : config.round;\n\t      switch (direction) {\n\t        case \"down\":\n\t          roundValue = roundValue + fraction - (decimalValue > fraction ? 0 : 1);\n\t          break;\n\t        case \"up\":\n\t        default:\n\t          roundValue = roundValue + fraction + (decimalValue > fraction ? 1 : 0);\n\t          break;\n\t      }\n\t      return this.round(roundValue, scale);\n\t    },\n\t    round\n\t  };\n\t}\n\n\tvar __defProp = Object.defineProperty;\n\tvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\n\tvar __hasOwnProp = Object.prototype.hasOwnProperty;\n\tvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\tvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n\tvar __spreadValues = (a, b) => {\n\t  for (var prop in b || (b = {}))\n\t    if (__hasOwnProp.call(b, prop))\n\t      __defNormalProp(a, prop, b[prop]);\n\t  if (__getOwnPropSymbols)\n\t    for (var prop of __getOwnPropSymbols(b)) {\n\t      if (__propIsEnum.call(b, prop))\n\t        __defNormalProp(a, prop, b[prop]);\n\t    }\n\t  return a;\n\t};\n\tconst options = {\n\t  store: null,\n\t  key: null,\n\t  url: null,\n\t  useCamelCase: null,\n\t  previewContent: null\n\t};\n\tconst api = {\n\t  version: \"3.18.2\",\n\t  options,\n\t  request,\n\t  init(store, key, opt = {}) {\n\t    options.key = key;\n\t    options.store = store;\n\t    options.url = opt.url ? trimEnd(opt.url) : `https://${store}.swell.store`;\n\t    options.vaultUrl = opt.vaultUrl ? trimEnd(opt.vaultUrl) : `https://vault.schema.io`;\n\t    options.timeout = opt.timeout && parseInt(opt.timeout, 10) || 2e4;\n\t    options.useCamelCase = opt.useCamelCase || false;\n\t    options.previewContent = opt.previewContent || false;\n\t    options.session = opt.session;\n\t    options.locale = opt.locale;\n\t    options.currency = opt.currency;\n\t    options.api = api;\n\t    setOptions(options);\n\t  },\n\t  auth(...args) {\n\t    return this.init(...args);\n\t  },\n\t  get(url, query) {\n\t    return request(\"get\", url, query);\n\t  },\n\t  put(url, data) {\n\t    return request(\"put\", url, data);\n\t  },\n\t  post(url, data) {\n\t    return request(\"post\", url, data);\n\t  },\n\t  delete(url, data) {\n\t    return request(\"delete\", url, data);\n\t  },\n\t  cache: cacheApi,\n\t  card: cardApi,\n\t  cart: methods$8(request, options),\n\t  account: methods$7(request),\n\t  products: methods$9(request, options),\n\t  categories: methods$6(request),\n\t  attributes: methods$a(request),\n\t  subscriptions: methods$5(request),\n\t  content: methods$4(request, options),\n\t  settings: methods$3(request, options),\n\t  payment: methods$2(request, options),\n\t  locale: methods$1(request, options),\n\t  currency: methods(request, options),\n\t  utils\n\t};\n\tasync function request(method, url, id = void 0, data = void 0, opt = void 0) {\n\t  const allOptions = __spreadValues(__spreadValues({}, options), opt);\n\t  const session = allOptions.session || getCookie(\"swell-session\");\n\t  const locale2 = allOptions.locale || getCookie(\"swell-locale\");\n\t  const currency2 = allOptions.currency || getCookie(\"swell-currency\");\n\t  const baseUrl = `${allOptions.url}${allOptions.base || \"\"}/api`;\n\t  const reqMethod = String(method).toLowerCase();\n\t  let reqUrl = url;\n\t  let reqData = id;\n\t  if (data !== void 0 || typeof id === \"string\") {\n\t    reqUrl = [trimEnd(url), trimStart(id)].join(\"/\");\n\t    reqData = data;\n\t  }\n\t  reqUrl = allOptions.fullUrl || `${baseUrl}/${trimBoth(reqUrl)}`;\n\t  reqData = allOptions.useCamelCase ? toSnake(reqData) : reqData;\n\t  let reqBody;\n\t  if (reqMethod === \"get\") {\n\t    let exQuery;\n\t    [reqUrl, exQuery] = reqUrl.split(\"?\");\n\t    const fullQuery = [exQuery, stringifyQuery(reqData)].join(\"&\").replace(/^&/, \"\");\n\t    reqUrl = `${reqUrl}${fullQuery ? `?${fullQuery}` : \"\"}`;\n\t  } else {\n\t    reqBody = JSON.stringify(reqData);\n\t  }\n\t  const reqHeaders = {\n\t    Accept: \"application/json\",\n\t    \"Content-Type\": \"application/json\",\n\t    Authorization: `Basic ${base64Encode(String(allOptions.key))}`\n\t  };\n\t  if (session) {\n\t    reqHeaders[\"X-Session\"] = session;\n\t  }\n\t  if (locale2) {\n\t    reqHeaders[\"X-Locale\"] = locale2;\n\t  }\n\t  if (currency2) {\n\t    reqHeaders[\"X-Currency\"] = currency2;\n\t  }\n\t  const response = await fetch(reqUrl, {\n\t    method: reqMethod,\n\t    headers: reqHeaders,\n\t    body: reqBody,\n\t    credentials: \"include\",\n\t    mode: \"cors\"\n\t  });\n\t  const responseSession = response.headers.get(\"X-Session\");\n\t  if (typeof responseSession === \"string\" && session !== responseSession) {\n\t    setCookie(\"swell-session\", responseSession);\n\t  }\n\t  const result = await response.json();\n\t  if (result && result.error) {\n\t    const err = new Error(result.error.message);\n\t    err.status = response.status;\n\t    err.code = result.error.code;\n\t    err.param = result.error.param;\n\t    throw err;\n\t  } else if (!response.ok) {\n\t    const err = new Error(\n\t      \"A connection error occurred while making the request\"\n\t    );\n\t    err.code = \"connection_error\";\n\t    throw err;\n\t  }\n\t  return options.useCamelCase ? toCamel(result) : result;\n\t}\n\n\treturn api;\n\n}));\n//# sourceMappingURL=swell.umd.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3dlbGwtanMvZGlzdC9zd2VsbC51bWQubWluLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsQ0FDb0c7QUFDckcsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDLG1FQUFtRTtBQUNuRSxzRUFBc0U7O0FBRXRFO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esd0NBQXdDOztBQUV4Qyw0REFBNEQ7QUFDNUQsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQyw0RUFBNEU7O0FBRTVFLDBHQUEwRzs7QUFFMUc7QUFDQSw4Q0FBOEM7O0FBRTlDLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUMsc0NBQXNDO0FBQ3RDLCtDQUErQztBQUMvQywyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7O0FBRUEsZ0ZBQWdGLHNDQUFzQzs7QUFFdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBOEM7QUFDakYsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxJQUFJO0FBQ0osaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSx3REFBd0QsdUJBQXVCOztBQUUvRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELElBQUk7QUFDSixpREFBaUQ7QUFDakQsSUFBSTtBQUNKLHVEQUF1RDtBQUN2RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVMsVUFBVTtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFNLG1CQUFtQixxQkFBTTtBQUN2RDtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVzs7QUFFckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsV0FBVzs7QUFFckI7QUFDQTtBQUNBLFVBQVUsVUFBVTs7QUFFcEI7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxLQUFLOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxVQUFVO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsS0FBMEI7O0FBRS9DO0FBQ0EscUNBQXFDLFFBQWE7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixLQUEwQjs7QUFFL0M7QUFDQSxxQ0FBcUMsUUFBYTs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixZQUFZLFNBQVM7QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixZQUFZLEdBQUc7QUFDZixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLFlBQVksVUFBVTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLEdBQUc7QUFDZixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCLFlBQVksVUFBVTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0IsUUFBUSxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLEdBQUc7QUFDZixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU8sVUFBVTtBQUN6QixRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUF5QixVQUFVLHVCQUF1QixxQkFBcUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw2REFBNkQ7QUFDaEo7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtB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Q0EscUNBQXFDLFFBQVEsR0FBRyxpQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sRUFBRSxnQkFBZ0IsVUFBVSxPQUFPO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd2VsbC1qcy9kaXN0L3N3ZWxsLnVtZC5taW4uanM/M2YxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5zd2VsbCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cblx0ZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pIHtcblx0ICB2YXIgZiA9IG4uZGVmYXVsdDtcblx0XHRpZiAodHlwZW9mIGYgPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgYSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRhLnByb3RvdHlwZSA9IGYucHJvdG90eXBlO1xuXHQgIH0gZWxzZSBhID0ge307XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG5cdFx0T2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIGspO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ba107XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiBhO1xuXHR9XG5cblx0LyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5cdHZhciBzaGFtcyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdFx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHR2YXIgb2JqID0ge307XG5cdFx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHRcdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0XHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdFx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0XHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgc3ltVmFsID0gNDI7XG5cdFx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdFx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdFx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0XHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0dmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG5cdHZhciBoYXNTeW1ib2xTaGFtID0gc2hhbXM7XG5cblx0dmFyIGhhc1N5bWJvbHMkMSA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdFx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xuXHR9O1xuXG5cdC8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxuXHR2YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0dmFyIHRvU3RyJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5cdHZhciBpbXBsZW1lbnRhdGlvbiQxID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG5cdCAgICB2YXIgdGFyZ2V0ID0gdGhpcztcblx0ICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyJDEuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG5cdCAgICB9XG5cdCAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHQgICAgdmFyIGJvdW5kO1xuXHQgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG5cdCAgICAgICAgICAgICAgICB0aGlzLFxuXHQgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuXHQgICAgICAgICAgICAgICAgdGhhdCxcblx0ICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXHQgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG5cdCAgICB9XG5cblx0ICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuXHQgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcblx0ICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuXHQgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG5cdCAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG5cdCAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJvdW5kO1xuXHR9O1xuXG5cdHZhciBpbXBsZW1lbnRhdGlvbiA9IGltcGxlbWVudGF0aW9uJDE7XG5cblx0dmFyIGZ1bmN0aW9uQmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuXG5cdHZhciBiaW5kJDEgPSBmdW5jdGlvbkJpbmQ7XG5cblx0dmFyIHNyYyA9IGJpbmQkMS5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG5cdHZhciB1bmRlZmluZWQkMTtcblxuXHR2YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG5cdHZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcblx0dmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9O1xuXG5cdHZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cdGlmICgkZ09QRCkge1xuXHRcdHRyeSB7XG5cdFx0XHQkZ09QRCh7fSwgJycpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdH1cblx0fVxuXG5cdHZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvciQxKCk7XG5cdH07XG5cdHZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdFx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSgpKVxuXHRcdDogdGhyb3dUeXBlRXJyb3I7XG5cblx0dmFyIGhhc1N5bWJvbHMgPSBoYXNTeW1ib2xzJDEoKTtcblxuXHR2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cblx0dmFyIG5lZWRzRXZhbCA9IHt9O1xuXG5cdHZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxuXHR2YXIgSU5UUklOU0lDUyA9IHtcblx0XHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHRcdCclQXJyYXklJzogQXJyYXksXG5cdFx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBBcnJheUJ1ZmZlcixcblx0XHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQkMSxcblx0XHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQkMSxcblx0XHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHRcdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHRcdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdFx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0XHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBBdG9taWNzLFxuXHRcdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBCaWdJbnQsXG5cdFx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdFx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBEYXRhVmlldyxcblx0XHQnJURhdGUlJzogRGF0ZSxcblx0XHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdFx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHRcdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0XHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdFx0JyVFcnJvciUnOiBFcnJvcixcblx0XHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdFx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHRcdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBGbG9hdDMyQXJyYXksXG5cdFx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IEZsb2F0NjRBcnJheSxcblx0XHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHRcdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHRcdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHRcdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBJbnQ4QXJyYXksXG5cdFx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCQxIDogSW50MTZBcnJheSxcblx0XHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBJbnQzMkFycmF5LFxuXHRcdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdFx0JyVpc05hTiUnOiBpc05hTixcblx0XHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCQxLFxuXHRcdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkJDEsXG5cdFx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IE1hcCxcblx0XHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkJDEgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0XHQnJU1hdGglJzogTWF0aCxcblx0XHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdFx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHRcdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHRcdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdFx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCQxIDogUHJvbWlzZSxcblx0XHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IFByb3h5LFxuXHRcdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHRcdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdFx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCQxIDogUmVmbGVjdCxcblx0XHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdFx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IFNldCxcblx0XHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkJDEgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0XHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHRcdCclU3RyaW5nJSc6IFN0cmluZyxcblx0XHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkJDEsXG5cdFx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCQxLFxuXHRcdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHRcdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdFx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdFx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvciQxLFxuXHRcdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IFVpbnQ4QXJyYXksXG5cdFx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBVaW50OENsYW1wZWRBcnJheSxcblx0XHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IFVpbnQxNkFycmF5LFxuXHRcdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCQxIDogVWludDMyQXJyYXksXG5cdFx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0XHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkJDEgOiBXZWFrTWFwLFxuXHRcdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQkMSA6IFdlYWtSZWYsXG5cdFx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCQxIDogV2Vha1NldFxuXHR9O1xuXG5cdHZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHRcdHZhciB2YWx1ZTtcblx0XHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdFx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdFx0aWYgKGZuKSB7XG5cdFx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRcdGlmIChnZW4pIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0dmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHRcdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0XHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdFx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHRcdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0XHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdFx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0XHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHRcdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHRcdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0XHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHRcdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0XHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHRcdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0XHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0XHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0XHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0XHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdFx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0XHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0XHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0XHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHRcdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdFx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdFx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0XHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0XHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0XHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0XHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHRcdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHRcdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdFx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0XHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0XHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0XHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHRcdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdFx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHRcdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHRcdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHRcdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0XHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0XHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0XHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdFx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0XHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0XHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHRcdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0XHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdFx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHRcdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0XHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHRcdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cblx0fTtcblxuXHR2YXIgYmluZCA9IGZ1bmN0aW9uQmluZDtcblx0dmFyIGhhc093biQxID0gc3JjO1xuXHR2YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcblx0dmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG5cdHZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuXHR2YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xuXG5cdC8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cblx0dmFyIHJlUHJvcE5hbWUkMSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xuXHR2YXIgcmVFc2NhcGVDaGFyJDEgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG5cdHZhciBzdHJpbmdUb1BhdGgkMSA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0XHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0XHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdFx0fVxuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUkMSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIkMSwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblx0LyogZW5kIGFkYXB0YXRpb24gKi9cblxuXHR2YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdFx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHRcdHZhciBhbGlhcztcblx0XHRpZiAoaGFzT3duJDEoTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHRcdH1cblxuXHRcdGlmIChoYXNPd24kMShJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvciQxKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xuXHR9O1xuXG5cdHZhciBnZXRJbnRyaW5zaWMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IkMSgnaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0XHR9XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IkMSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aCQxKG5hbWUpO1xuXHRcdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdFx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdFx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdFx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHRcdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHRcdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0XHRpZiAoYWxpYXMpIHtcblx0XHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRcdGlmIChcblx0XHRcdFx0KFxuXHRcdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHRcdClcblx0XHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHRcdCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRcdGlmIChoYXNPd24kMShJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvciQxKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQkMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpc093biA9IGhhc093biQxKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHR2YXIgY2FsbEJpbmQkMSA9IHtleHBvcnRzOiB7fX07XG5cblx0KGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuXHRcdHZhciBiaW5kID0gZnVuY3Rpb25CaW5kO1xuXHRcdHZhciBHZXRJbnRyaW5zaWMgPSBnZXRJbnRyaW5zaWM7XG5cblx0XHR2YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xuXHRcdHZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xuXHRcdHZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cblx0XHR2YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuXHRcdHZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG5cdFx0dmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxuXHRcdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdFx0XHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRcdFx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKGZ1bmMsICdsZW5ndGgnKTtcblx0XHRcdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHRcdFx0JGRlZmluZVByb3BlcnR5KFxuXHRcdFx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHRcdFx0eyB2YWx1ZTogMSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSB9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZ1bmM7XG5cdFx0fTtcblxuXHRcdHZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdFx0XHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcblx0XHR9XG5cdH0gKGNhbGxCaW5kJDEpKTtcblxuXHR2YXIgR2V0SW50cmluc2ljJDEgPSBnZXRJbnRyaW5zaWM7XG5cblx0dmFyIGNhbGxCaW5kID0gY2FsbEJpbmQkMS5leHBvcnRzO1xuXG5cdHZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYyQxKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cblx0dmFyIGNhbGxCb3VuZCQxID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRcdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMkMShuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdFx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdFx0fVxuXHRcdHJldHVybiBpbnRyaW5zaWM7XG5cdH07XG5cblx0dmFyIGdsb2JhbCQxID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxuXHQgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG5cdCAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcblxuXHR2YXIgbG9va3VwID0gW107XG5cdHZhciByZXZMb29rdXAgPSBbXTtcblx0dmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcblx0dmFyIGluaXRlZCA9IGZhbHNlO1xuXHRmdW5jdGlvbiBpbml0ICgpIHtcblx0ICBpbml0ZWQgPSB0cnVlO1xuXHQgIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXHQgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuXHQgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuXHQgIH1cblxuXHQgIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2Mjtcblx0ICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG5cdH1cblxuXHRmdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG5cdCAgaWYgKCFpbml0ZWQpIHtcblx0ICAgIGluaXQoKTtcblx0ICB9XG5cdCAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG5cdCAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cblx0ICBpZiAobGVuICUgNCA+IDApIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdCAgfVxuXG5cdCAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0ICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdCAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG5cdCAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdCAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHQgIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cblx0ICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0ICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTtcblxuXHQgIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0ICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG5cblx0ICB2YXIgTCA9IDA7XG5cblx0ICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdCAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG5cdCAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRjtcblx0ICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG5cdCAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG5cdCAgfVxuXG5cdCAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHQgICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG5cdCAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG5cdCAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0ICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcblx0ICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG5cdCAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0ICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuXHQgIHZhciB0bXA7XG5cdCAgdmFyIG91dHB1dCA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG5cdCAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuXHQgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuXHQgIH1cblx0ICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuXHQgIGlmICghaW5pdGVkKSB7XG5cdCAgICBpbml0KCk7XG5cdCAgfVxuXHQgIHZhciB0bXA7XG5cdCAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcblx0ICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdCAgdmFyIG91dHB1dCA9ICcnO1xuXHQgIHZhciBwYXJ0cyA9IFtdO1xuXHQgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuXHQgIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0ICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG5cdCAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKTtcblx0ICB9XG5cblx0ICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdCAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcblx0ICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuXHQgICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG5cdCAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTtcblx0ICAgIG91dHB1dCArPSAnPT0nO1xuXHQgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuXHQgICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTtcblx0ICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXTtcblx0ICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuXHQgICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07XG5cdCAgICBvdXRwdXQgKz0gJz0nO1xuXHQgIH1cblxuXHQgIHBhcnRzLnB1c2gob3V0cHV0KTtcblxuXHQgIHJldHVybiBwYXJ0cy5qb2luKCcnKVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuXHQgIHZhciBlLCBtO1xuXHQgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuXHQgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuXHQgIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcblx0ICB2YXIgbkJpdHMgPSAtNztcblx0ICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwO1xuXHQgIHZhciBkID0gaXNMRSA/IC0xIDogMTtcblx0ICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuXHQgIGkgKz0gZDtcblxuXHQgIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuXHQgIHMgPj49ICgtbkJpdHMpO1xuXHQgIG5CaXRzICs9IGVMZW47XG5cdCAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuXHQgIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuXHQgIGUgPj49ICgtbkJpdHMpO1xuXHQgIG5CaXRzICs9IG1MZW47XG5cdCAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuXHQgIGlmIChlID09PSAwKSB7XG5cdCAgICBlID0gMSAtIGVCaWFzO1xuXHQgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuXHQgICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG5cdCAgfSBlbHNlIHtcblx0ICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG5cdCAgICBlID0gZSAtIGVCaWFzO1xuXHQgIH1cblx0ICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGUgKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG5cdCAgdmFyIGUsIG0sIGM7XG5cdCAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG5cdCAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG5cdCAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuXHQgIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCk7XG5cdCAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKTtcblx0ICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG5cdCAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cblx0ICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuXHQgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG5cdCAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG5cdCAgICBlID0gZU1heDtcblx0ICB9IGVsc2Uge1xuXHQgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuXHQgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuXHQgICAgICBlLS07XG5cdCAgICAgIGMgKj0gMjtcblx0ICAgIH1cblx0ICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuXHQgICAgICB2YWx1ZSArPSBydCAvIGM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcblx0ICAgICAgZSsrO1xuXHQgICAgICBjIC89IDI7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuXHQgICAgICBtID0gMDtcblx0ICAgICAgZSA9IGVNYXg7XG5cdCAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG5cdCAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcblx0ICAgICAgZSA9IGUgKyBlQmlhcztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcblx0ICAgICAgZSA9IDA7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuXHQgIGUgPSAoZSA8PCBtTGVuKSB8IG07XG5cdCAgZUxlbiArPSBtTGVuO1xuXHQgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuXHQgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcblx0fVxuXG5cdHZhciB0b1N0cmluZyQxID0ge30udG9TdHJpbmc7XG5cblx0dmFyIGlzQXJyYXkkNiA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuXHQgIHJldHVybiB0b1N0cmluZyQxLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXG5cdC8qIVxuXHQgKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cblx0ICpcblx0ICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG5cdCAqIEBsaWNlbnNlICBNSVRcblx0ICovXG5cblx0dmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblx0LyoqXG5cdCAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG5cdCAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG5cdCAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcblx0ICpcblx0ICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuXHQgKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG5cdCAqXG5cdCAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cblx0ICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG5cdCAqXG5cdCAqIE5vdGU6XG5cdCAqXG5cdCAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG5cdCAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cblx0ICpcblx0ICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG5cdCAqXG5cdCAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG5cdCAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuXHQgKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuXHQgKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cblx0ICovXG5cdEJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwkMS5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcblx0ICA/IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlRcblx0ICA6IHRydWU7XG5cblx0ZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG5cdCAgcmV0dXJuIEJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlRcblx0ICAgID8gMHg3ZmZmZmZmZlxuXHQgICAgOiAweDNmZmZmZmZmXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuXHQgIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG5cdCAgfVxuXHQgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2Vcblx0ICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIkMy5wcm90b3R5cGU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3Ncblx0ICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG5cdCAgICAgIHRoYXQgPSBuZXcgQnVmZmVyJDMobGVuZ3RoKTtcblx0ICAgIH1cblx0ICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGF0XG5cdH1cblxuXHQvKipcblx0ICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG5cdCAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2Zcblx0ICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuXHQgKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuXHQgKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuXHQgKlxuXHQgKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEJ1ZmZlciQzIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuXHQgIGlmICghQnVmZmVyJDMuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIkMykpIHtcblx0ICAgIHJldHVybiBuZXcgQnVmZmVyJDMoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG5cdCAgfVxuXG5cdCAgLy8gQ29tbW9uIGNhc2UuXG5cdCAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG5cdCAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG5cdCAgICAgIClcblx0ICAgIH1cblx0ICAgIHJldHVybiBhbGxvY1Vuc2FmZSQxKHRoaXMsIGFyZylcblx0ICB9XG5cdCAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG5cdH1cblxuXHRCdWZmZXIkMy5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuXHQvLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cblx0QnVmZmVyJDMuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG5cdCAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlciQzLnByb3RvdHlwZTtcblx0ICByZXR1cm4gYXJyXG5cdH07XG5cblx0ZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG5cdH1cblxuXHQvKipcblx0ICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3Jcblx0ICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG5cdCAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcblx0ICogQnVmZmVyLmZyb20oYXJyYXkpXG5cdCAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcblx0ICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG5cdCAqKi9cblx0QnVmZmVyJDMuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcblx0fTtcblxuXHRpZiAoQnVmZmVyJDMuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuXHQgIEJ1ZmZlciQzLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZTtcblx0ICBCdWZmZXIkMy5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuXHR9XG5cblx0ZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuXHQgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuXHQgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG5cdCAgYXNzZXJ0U2l6ZShzaXplKTtcblx0ICBpZiAoc2l6ZSA8PSAwKSB7XG5cdCAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG5cdCAgfVxuXHQgIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG5cdCAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG5cdCAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG5cdCAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuXHQgICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuXHQgICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG5cdCAgfVxuXHQgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG5cdCAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcblx0ICoqL1xuXHRCdWZmZXIkMy5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuXHQgIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcblx0fTtcblxuXHRmdW5jdGlvbiBhbGxvY1Vuc2FmZSQxICh0aGF0LCBzaXplKSB7XG5cdCAgYXNzZXJ0U2l6ZShzaXplKTtcblx0ICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTtcblx0ICBpZiAoIUJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG5cdCAgICAgIHRoYXRbaV0gPSAwO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdGhhdFxuXHR9XG5cblx0LyoqXG5cdCAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG5cdCAqICovXG5cdEJ1ZmZlciQzLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcblx0ICByZXR1cm4gYWxsb2NVbnNhZmUkMShudWxsLCBzaXplKVxuXHR9O1xuXHQvKipcblx0ICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG5cdCAqL1xuXHRCdWZmZXIkMy5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgIHJldHVybiBhbGxvY1Vuc2FmZSQxKG51bGwsIHNpemUpXG5cdH07XG5cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuXHQgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuXHQgICAgZW5jb2RpbmcgPSAndXRmOCc7XG5cdCAgfVxuXG5cdCAgaWYgKCFCdWZmZXIkMy5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuXHQgIH1cblxuXHQgIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcblx0ICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cblx0ICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKTtcblxuXHQgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuXHQgICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG5cdCAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuXHQgICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG5cdCAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGF0XG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuXHQgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG5cdCAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NTtcblx0ICB9XG5cdCAgcmV0dXJuIHRoYXRcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuXHQgIGFycmF5LmJ5dGVMZW5ndGg7IC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuXHQgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcblx0ICB9XG5cblx0ICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG5cdCAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuXHQgIH1cblxuXHQgIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuXHQgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuXHQgIH1cblxuXHQgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2Vcblx0ICAgIHRoYXQgPSBhcnJheTtcblx0ICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyJDMucHJvdG90eXBlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG5cdCAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG5cdCAgfVxuXHQgIHJldHVybiB0aGF0XG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcblx0ICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihvYmopKSB7XG5cdCAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7XG5cdCAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cblx0ICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gdGhhdFxuXHQgICAgfVxuXG5cdCAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pO1xuXHQgICAgcmV0dXJuIHRoYXRcblx0ICB9XG5cblx0ICBpZiAob2JqKSB7XG5cdCAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuXHQgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG5cdCAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcblx0ICAgIH1cblxuXHQgICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5JDYob2JqLmRhdGEpKSB7XG5cdCAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG5cdCAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG5cdCAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG5cdCAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblx0ICB9XG5cdCAgcmV0dXJuIGxlbmd0aCB8IDBcblx0fVxuXHRCdWZmZXIkMy5pc0J1ZmZlciA9IGlzQnVmZmVyJDM7XG5cdGZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIgKGIpIHtcblx0ICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxuXHR9XG5cblx0QnVmZmVyJDMuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcblx0ICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuXHQgIH1cblxuXHQgIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG5cdCAgdmFyIHggPSBhLmxlbmd0aDtcblx0ICB2YXIgeSA9IGIubGVuZ3RoO1xuXG5cdCAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG5cdCAgICAgIHggPSBhW2ldO1xuXHQgICAgICB5ID0gYltpXTtcblx0ICAgICAgYnJlYWtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoeCA8IHkpIHJldHVybiAtMVxuXHQgIGlmICh5IDwgeCkgcmV0dXJuIDFcblx0ICByZXR1cm4gMFxuXHR9O1xuXG5cdEJ1ZmZlciQzLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuXHQgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG5cdCAgICBjYXNlICdoZXgnOlxuXHQgICAgY2FzZSAndXRmOCc6XG5cdCAgICBjYXNlICd1dGYtOCc6XG5cdCAgICBjYXNlICdhc2NpaSc6XG5cdCAgICBjYXNlICdsYXRpbjEnOlxuXHQgICAgY2FzZSAnYmluYXJ5Jzpcblx0ICAgIGNhc2UgJ2Jhc2U2NCc6XG5cdCAgICBjYXNlICd1Y3MyJzpcblx0ICAgIGNhc2UgJ3Vjcy0yJzpcblx0ICAgIGNhc2UgJ3V0ZjE2bGUnOlxuXHQgICAgY2FzZSAndXRmLTE2bGUnOlxuXHQgICAgICByZXR1cm4gdHJ1ZVxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIGZhbHNlXG5cdCAgfVxuXHR9O1xuXG5cdEJ1ZmZlciQzLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG5cdCAgaWYgKCFpc0FycmF5JDYobGlzdCkpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG5cdCAgfVxuXG5cdCAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gQnVmZmVyJDMuYWxsb2MoMClcblx0ICB9XG5cblx0ICB2YXIgaTtcblx0ICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGxlbmd0aCA9IDA7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuXHQgICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGJ1ZmZlciA9IEJ1ZmZlciQzLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG5cdCAgdmFyIHBvcyA9IDA7XG5cdCAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciBidWYgPSBsaXN0W2ldO1xuXHQgICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcblx0ICAgIH1cblx0ICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcblx0ICAgIHBvcyArPSBidWYubGVuZ3RoO1xuXHQgIH1cblx0ICByZXR1cm4gYnVmZmVyXG5cdH07XG5cblx0ZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuXHQgIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcblx0ICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcblx0ICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuXHQgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG5cdCAgfVxuXHQgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHQgICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG5cdCAgfVxuXG5cdCAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG5cdCAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuXHQgIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuXHQgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXHQgIGZvciAoOzspIHtcblx0ICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcblx0ICAgICAgY2FzZSAnYXNjaWknOlxuXHQgICAgICBjYXNlICdsYXRpbjEnOlxuXHQgICAgICBjYXNlICdiaW5hcnknOlxuXHQgICAgICAgIHJldHVybiBsZW5cblx0ICAgICAgY2FzZSAndXRmOCc6XG5cdCAgICAgIGNhc2UgJ3V0Zi04Jzpcblx0ICAgICAgY2FzZSB1bmRlZmluZWQ6XG5cdCAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG5cdCAgICAgIGNhc2UgJ3VjczInOlxuXHQgICAgICBjYXNlICd1Y3MtMic6XG5cdCAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuXHQgICAgICBjYXNlICd1dGYtMTZsZSc6XG5cdCAgICAgICAgcmV0dXJuIGxlbiAqIDJcblx0ICAgICAgY2FzZSAnaGV4Jzpcblx0ICAgICAgICByZXR1cm4gbGVuID4+PiAxXG5cdCAgICAgIGNhc2UgJ2Jhc2U2NCc6XG5cdCAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuXHQgICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRCdWZmZXIkMy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuXHRmdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG5cblx0ICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcblx0ICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG5cdCAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG5cdCAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuXHQgIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG5cdCAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG5cdCAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG5cdCAgICBzdGFydCA9IDA7XG5cdCAgfVxuXHQgIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG5cdCAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cblx0ICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuICcnXG5cdCAgfVxuXG5cdCAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG5cdCAgICBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICB9XG5cblx0ICBpZiAoZW5kIDw9IDApIHtcblx0ICAgIHJldHVybiAnJ1xuXHQgIH1cblxuXHQgIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG5cdCAgZW5kID4+Pj0gMDtcblx0ICBzdGFydCA+Pj49IDA7XG5cblx0ICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG5cdCAgICByZXR1cm4gJydcblx0ICB9XG5cblx0ICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuXHQgIHdoaWxlICh0cnVlKSB7XG5cdCAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG5cdCAgICAgIGNhc2UgJ2hleCc6XG5cdCAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cblx0ICAgICAgY2FzZSAndXRmOCc6XG5cdCAgICAgIGNhc2UgJ3V0Zi04Jzpcblx0ICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cblx0ICAgICAgY2FzZSAnYXNjaWknOlxuXHQgICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cblx0ICAgICAgY2FzZSAnbGF0aW4xJzpcblx0ICAgICAgY2FzZSAnYmluYXJ5Jzpcblx0ICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuXHQgICAgICBjYXNlICdiYXNlNjQnOlxuXHQgICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG5cdCAgICAgIGNhc2UgJ3VjczInOlxuXHQgICAgICBjYXNlICd1Y3MtMic6XG5cdCAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuXHQgICAgICBjYXNlICd1dGYtMTZsZSc6XG5cdCAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG5cdCAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0Ly8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcblx0Ly8gQnVmZmVyIGluc3RhbmNlcy5cblx0QnVmZmVyJDMucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5cblx0ZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuXHQgIHZhciBpID0gYltuXTtcblx0ICBiW25dID0gYlttXTtcblx0ICBiW21dID0gaTtcblx0fVxuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuXHQgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblx0ICBpZiAobGVuICUgMiAhPT0gMCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuXHQgICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG5cdCAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXHQgIGlmIChsZW4gJSA0ICE9PSAwKSB7XG5cdCAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cdCAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTtcblx0ICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIHRoaXNcblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcblx0ICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cdCAgaWYgKGxlbiAlIDggIT09IDApIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcblx0ICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuXHQgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuXHQgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuXHQgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpc1xuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcblx0ICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuXHQgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcblx0ICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG5cdCAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcblx0ICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcblx0ICByZXR1cm4gQnVmZmVyJDMuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG5cdCAgdmFyIHN0ciA9ICcnO1xuXHQgIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcblx0ICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG5cdCAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKTtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICc7XG5cdCAgfVxuXHQgIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuXHQgIGlmICghaW50ZXJuYWxJc0J1ZmZlcih0YXJnZXQpKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcblx0ICB9XG5cblx0ICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgc3RhcnQgPSAwO1xuXHQgIH1cblx0ICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuXHQgIH1cblx0ICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHRoaXNTdGFydCA9IDA7XG5cdCAgfVxuXHQgIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcblx0ICB9XG5cblx0ICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuXHQgIH1cblxuXHQgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcblx0ICAgIHJldHVybiAwXG5cdCAgfVxuXHQgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuXHQgICAgcmV0dXJuIC0xXG5cdCAgfVxuXHQgIGlmIChzdGFydCA+PSBlbmQpIHtcblx0ICAgIHJldHVybiAxXG5cdCAgfVxuXG5cdCAgc3RhcnQgPj4+PSAwO1xuXHQgIGVuZCA+Pj49IDA7XG5cdCAgdGhpc1N0YXJ0ID4+Pj0gMDtcblx0ICB0aGlzRW5kID4+Pj0gMDtcblxuXHQgIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cblx0ICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG5cdCAgdmFyIHkgPSBlbmQgLSBzdGFydDtcblx0ICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cblx0ICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG5cdCAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcblx0ICAgICAgeCA9IHRoaXNDb3B5W2ldO1xuXHQgICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcblx0ICAgICAgYnJlYWtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoeCA8IHkpIHJldHVybiAtMVxuXHQgIGlmICh5IDwgeCkgcmV0dXJuIDFcblx0ICByZXR1cm4gMFxuXHR9O1xuXG5cdC8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcblx0Ly8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cblx0Ly9cblx0Ly8gQXJndW1lbnRzOlxuXHQvLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuXHQvLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuXHQvLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcblx0Ly8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcblx0Ly8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2Zcblx0ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG5cdCAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG5cdCAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG5cdCAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcblx0ICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG5cdCAgICBieXRlT2Zmc2V0ID0gMDtcblx0ICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG5cdCAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZjtcblx0ICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuXHQgICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuXHQgIH1cblx0ICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuXHQgIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuXHQgICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG5cdCAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSk7XG5cdCAgfVxuXG5cdCAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcblx0ICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDtcblx0ICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG5cdCAgICBpZiAoZGlyKSByZXR1cm4gLTFcblx0ICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuXHQgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcblx0ICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwO1xuXHQgICAgZWxzZSByZXR1cm4gLTFcblx0ICB9XG5cblx0ICAvLyBOb3JtYWxpemUgdmFsXG5cdCAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICB2YWwgPSBCdWZmZXIkMy5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuXHQgIH1cblxuXHQgIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG5cdCAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkge1xuXHQgICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuXHQgICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcblx0ICAgICAgcmV0dXJuIC0xXG5cdCAgICB9XG5cdCAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuXHQgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcblx0ICAgIHZhbCA9IHZhbCAmIDB4RkY7IC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cblx0ICAgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG5cdCAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaWYgKGRpcikge1xuXHQgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuXHQgIH1cblxuXHQgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG5cdH1cblxuXHRmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG5cdCAgdmFyIGluZGV4U2l6ZSA9IDE7XG5cdCAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG5cdCAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cblx0ICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuXHQgICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcblx0ICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG5cdCAgICAgICAgcmV0dXJuIC0xXG5cdCAgICAgIH1cblx0ICAgICAgaW5kZXhTaXplID0gMjtcblx0ICAgICAgYXJyTGVuZ3RoIC89IDI7XG5cdCAgICAgIHZhbExlbmd0aCAvPSAyO1xuXHQgICAgICBieXRlT2Zmc2V0IC89IDI7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG5cdCAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG5cdCAgICAgIHJldHVybiBidWZbaV1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGk7XG5cdCAgaWYgKGRpcikge1xuXHQgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcblx0ICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG5cdCAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcblx0ICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuXHQgICAgICAgIGZvdW5kSW5kZXggPSAtMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcblx0ICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciBmb3VuZCA9IHRydWU7XG5cdCAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG5cdCAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiAtMVxuXHR9XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcblx0ICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuXHQgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG5cdCAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuXHQgIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuXHQgIGlmICghbGVuZ3RoKSB7XG5cdCAgICBsZW5ndGggPSByZW1haW5pbmc7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuXHQgICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuXHQgICAgICBsZW5ndGggPSByZW1haW5pbmc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcblx0ICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcblx0ICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuXHQgIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG5cdCAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcblx0ICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuXHQgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuXHQgIH1cblx0ICByZXR1cm4gaVxuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuXHR9XG5cblx0ZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG5cdH1cblxuXHRmdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXHR9XG5cblx0ZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuXHQgIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcblx0fVxuXG5cdGZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcblx0fVxuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuXHQgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG5cdCAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBlbmNvZGluZyA9ICd1dGY4Jztcblx0ICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgb2Zmc2V0ID0gMDtcblx0ICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblx0ICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBlbmNvZGluZyA9IG9mZnNldDtcblx0ICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgb2Zmc2V0ID0gMDtcblx0ICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuXHQgIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuXHQgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0ICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG5cdCAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDA7XG5cdCAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4Jztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuXHQgICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoXG5cdCAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcblx0ICAgIClcblx0ICB9XG5cblx0ICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG5cdCAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG5cdCAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG5cdCAgfVxuXG5cdCAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cblx0ICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblx0ICBmb3IgKDs7KSB7XG5cdCAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG5cdCAgICAgIGNhc2UgJ2hleCc6XG5cdCAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAndXRmOCc6XG5cdCAgICAgIGNhc2UgJ3V0Zi04Jzpcblx0ICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAnYXNjaWknOlxuXHQgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAnbGF0aW4xJzpcblx0ICAgICAgY2FzZSAnYmluYXJ5Jzpcblx0ICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuXHQgICAgICBjYXNlICdiYXNlNjQnOlxuXHQgICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG5cdCAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAndWNzMic6XG5cdCAgICAgIGNhc2UgJ3Vjcy0yJzpcblx0ICAgICAgY2FzZSAndXRmMTZsZSc6XG5cdCAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcblx0ICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcblx0ICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHR5cGU6ICdCdWZmZXInLFxuXHQgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcblx0ICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuXHQgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cdCAgdmFyIHJlcyA9IFtdO1xuXG5cdCAgdmFyIGkgPSBzdGFydDtcblx0ICB3aGlsZSAoaSA8IGVuZCkge1xuXHQgICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcblx0ICAgIHZhciBjb2RlUG9pbnQgPSBudWxsO1xuXHQgICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG5cdCAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuXHQgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcblx0ICAgICAgOiAxO1xuXG5cdCAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG5cdCAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7XG5cblx0ICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG5cdCAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcblx0ICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWtcblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcblx0ICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG5cdCAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcblx0ICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG5cdCAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWtcblx0ICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcblx0ICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG5cdCAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcblx0ICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuXHQgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG5cdCAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWtcblx0ICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcblx0ICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG5cdCAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcblx0ICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG5cdCAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcblx0ICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG5cdCAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcblx0ICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuXHQgICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG5cdCAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcblx0ICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG5cdCAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuXHQgICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuXHQgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0ICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0ICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG5cdCAgICB9XG5cblx0ICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG5cdCAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG5cdH1cblxuXHQvLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcblx0Ly8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuXHQvLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5cdHZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuXHRmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcblx0ICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdCAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuXHQgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG5cdCAgfVxuXG5cdCAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuXHQgIHZhciByZXMgPSAnJztcblx0ICB2YXIgaSA9IDA7XG5cdCAgd2hpbGUgKGkgPCBsZW4pIHtcblx0ICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuXHQgICAgICBTdHJpbmcsXG5cdCAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcblx0ICAgICk7XG5cdCAgfVxuXHQgIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuXHQgIHZhciByZXQgPSAnJztcblx0ICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG5cdCAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcblx0ICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuXHQgIH1cblx0ICByZXR1cm4gcmV0XG5cdH1cblxuXHRmdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIHJldCA9ICcnO1xuXHQgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cblx0ICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuXHQgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJldFxuXHR9XG5cblx0ZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuXHQgIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG5cdCAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcblx0ICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG5cdCAgdmFyIG91dCA9ICcnO1xuXHQgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG5cdCAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIG91dFxuXHR9XG5cblx0ZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcblx0ICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cdCAgdmFyIHJlcyA9ICcnO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc1xuXHR9XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcblx0ICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cdCAgc3RhcnQgPSB+fnN0YXJ0O1xuXHQgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cblx0ICBpZiAoc3RhcnQgPCAwKSB7XG5cdCAgICBzdGFydCArPSBsZW47XG5cdCAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG5cdCAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuXHQgICAgc3RhcnQgPSBsZW47XG5cdCAgfVxuXG5cdCAgaWYgKGVuZCA8IDApIHtcblx0ICAgIGVuZCArPSBsZW47XG5cdCAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcblx0ICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuXHQgICAgZW5kID0gbGVuO1xuXHQgIH1cblxuXHQgIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cblx0ICB2YXIgbmV3QnVmO1xuXHQgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuXHQgICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlciQzLnByb3RvdHlwZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG5cdCAgICBuZXdCdWYgPSBuZXcgQnVmZmVyJDMoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcblx0ICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBuZXdCdWZcblx0fTtcblxuXHQvKlxuXHQgKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cblx0ICovXG5cdGZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG5cdCAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50Jylcblx0ICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG5cdH1cblxuXHRCdWZmZXIkMy5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuXHQgIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG5cdCAgdmFyIG11bCA9IDE7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG5cdCAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkge1xuXHQgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cdCAgfVxuXG5cdCAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcblx0ICB2YXIgbXVsID0gMTtcblx0ICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcblx0ICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHZhbFxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcblx0ICByZXR1cm4gdGhpc1tvZmZzZXRdXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuXHQgIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcblx0ICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cblx0ICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcblx0ICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuXHQgICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcblx0ICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG5cdCAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcblx0ICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuXHQgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuXHQgICAgdGhpc1tvZmZzZXQgKyAzXSlcblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cblx0ICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuXHQgIHZhciBtdWwgPSAxO1xuXHQgIHZhciBpID0gMDtcblx0ICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuXHQgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG5cdCAgfVxuXHQgIG11bCAqPSAweDgwO1xuXG5cdCAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cblx0ICByZXR1cm4gdmFsXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cdCAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG5cdCAgdmFyIGkgPSBieXRlTGVuZ3RoO1xuXHQgIHZhciBtdWwgPSAxO1xuXHQgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG5cdCAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG5cdCAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsO1xuXHQgIH1cblx0ICBtdWwgKj0gMHg4MDtcblxuXHQgIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG5cdCAgcmV0dXJuIHZhbFxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG5cdCAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuXHQgIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG5cdCAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpO1xuXHQgIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuXHQgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTtcblx0ICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuXHQgIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG5cdCAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG5cdCAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuXHQgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuXHQgIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG5cdCAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuXHQgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuXHQgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblx0ICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cdCAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuXHQgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuXHQgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcblx0ICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcblx0ICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG5cdCAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuXHR9XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkge1xuXHQgICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcblx0ICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcblx0ICB9XG5cblx0ICB2YXIgbXVsID0gMTtcblx0ICB2YXIgaSA9IDA7XG5cdCAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuXHQgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG5cdCAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSB7XG5cdCAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuXHQgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuXHQgIH1cblxuXHQgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG5cdCAgdmFyIG11bCA9IDE7XG5cdCAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcblx0ICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcblx0ICB9XG5cblx0ICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuXHQgIGlmICghQnVmZmVyJDMuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcblx0ICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcblx0ICByZXR1cm4gb2Zmc2V0ICsgMVxuXHR9O1xuXG5cdGZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuXHQgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxO1xuXHQgIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcblx0ICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG5cdCAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogODtcblx0ICB9XG5cdH1cblxuXHRCdWZmZXIkMy5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuXHQgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcblx0ICB9XG5cdCAgcmV0dXJuIG9mZnNldCArIDJcblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuXHQgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuXHQgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG5cdCAgfVxuXHQgIHJldHVybiBvZmZzZXQgKyAyXG5cdH07XG5cblx0ZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG5cdCAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuXHQgIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcblx0ICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmY7XG5cdCAgfVxuXHR9XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIHZhbHVlID0gK3ZhbHVlO1xuXHQgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG5cdCAgaWYgKEJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuXHQgICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuXHQgIH1cblx0ICByZXR1cm4gb2Zmc2V0ICsgNFxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuXHQgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuXHQgICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG5cdCAgfVxuXHQgIHJldHVybiBvZmZzZXQgKyA0XG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIHZhbHVlID0gK3ZhbHVlO1xuXHQgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkge1xuXHQgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuXHQgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuXHQgIH1cblxuXHQgIHZhciBpID0gMDtcblx0ICB2YXIgbXVsID0gMTtcblx0ICB2YXIgc3ViID0gMDtcblx0ICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG5cdCAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcblx0ICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG5cdCAgICAgIHN1YiA9IDE7XG5cdCAgICB9XG5cdCAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuXHQgIH1cblxuXHQgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIHZhbHVlID0gK3ZhbHVlO1xuXHQgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkge1xuXHQgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuXHQgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuXHQgIH1cblxuXHQgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG5cdCAgdmFyIG11bCA9IDE7XG5cdCAgdmFyIHN1YiA9IDA7XG5cdCAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcblx0ICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcblx0ICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG5cdCAgICAgIHN1YiA9IDE7XG5cdCAgICB9XG5cdCAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuXHQgIH1cblxuXHQgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcblx0ICBpZiAoIUJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG5cdCAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuXHQgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIHJldHVybiBvZmZzZXQgKyAxXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG5cdCAgaWYgKEJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcblx0ICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuXHQgIH1cblx0ICByZXR1cm4gb2Zmc2V0ICsgMlxuXHR9O1xuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuXHQgIGlmIChCdWZmZXIkMy5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuXHQgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG5cdCAgfVxuXHQgIHJldHVybiBvZmZzZXQgKyAyXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcblx0ICBpZiAoQnVmZmVyJDMuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuXHQgICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG5cdCAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG5cdCAgfVxuXHQgIHJldHVybiBvZmZzZXQgKyA0XG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcblx0ICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG5cdCAgaWYgKEJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcblx0ICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuXHQgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuXHQgICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG5cdCAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcblx0ICB9XG5cdCAgcmV0dXJuIG9mZnNldCArIDRcblx0fTtcblxuXHRmdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuXHQgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcblx0ICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG5cdH1cblxuXHRmdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcblx0ICBpZiAoIW5vQXNzZXJ0KSB7XG5cdCAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcblx0ICB9XG5cdCAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcblx0ICByZXR1cm4gb2Zmc2V0ICsgNFxuXHR9XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcblx0fTtcblxuXHRCdWZmZXIkMy5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcblx0fTtcblxuXHRmdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG5cdCAgaWYgKCFub0Fzc2VydCkge1xuXHQgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCk7XG5cdCAgfVxuXHQgIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG5cdCAgcmV0dXJuIG9mZnNldCArIDhcblx0fVxuXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG5cdH07XG5cblx0QnVmZmVyJDMucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG5cdH07XG5cblx0Ly8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuXHRCdWZmZXIkMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcblx0ICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG5cdCAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuXHQgIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcblx0ICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cblx0ICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcblx0ICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcblx0ICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuXHQgIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcblx0ICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG5cdCAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG5cdCAgfVxuXHQgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcblx0ICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuXHQgIC8vIEFyZSB3ZSBvb2I/XG5cdCAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcblx0ICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0O1xuXHQgIH1cblxuXHQgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcblx0ICB2YXIgaTtcblxuXHQgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuXHQgICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG5cdCAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcblx0ICAgIH1cblx0ICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlciQzLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcblx0ICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG5cdCAgICAgIHRhcmdldCxcblx0ICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuXHQgICAgICB0YXJnZXRTdGFydFxuXHQgICAgKTtcblx0ICB9XG5cblx0ICByZXR1cm4gbGVuXG5cdH07XG5cblx0Ly8gVXNhZ2U6XG5cdC8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuXHQvLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcblx0Ly8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5cdEJ1ZmZlciQzLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuXHQgIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG5cdCAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuXHQgICAgICBlbmNvZGluZyA9IHN0YXJ0O1xuXHQgICAgICBzdGFydCA9IDA7XG5cdCAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuXHQgICAgICBlbmNvZGluZyA9IGVuZDtcblx0ICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuXHQgICAgICBpZiAoY29kZSA8IDI1Nikge1xuXHQgICAgICAgIHZhbCA9IGNvZGU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyJDMuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcblx0ICAgIHZhbCA9IHZhbCAmIDI1NTtcblx0ICB9XG5cblx0ICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cblx0ICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuXHQgIH1cblxuXHQgIGlmIChlbmQgPD0gc3RhcnQpIHtcblx0ICAgIHJldHVybiB0aGlzXG5cdCAgfVxuXG5cdCAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcblx0ICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG5cdCAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cblx0ICB2YXIgaTtcblx0ICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcblx0ICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcblx0ICAgICAgdGhpc1tpXSA9IHZhbDtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGJ5dGVzID0gaW50ZXJuYWxJc0J1ZmZlcih2YWwpXG5cdCAgICAgID8gdmFsXG5cdCAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlciQzKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpO1xuXHQgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG5cdCAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzXG5cdH07XG5cblx0Ly8gSEVMUEVSIEZVTkNUSU9OU1xuXHQvLyA9PT09PT09PT09PT09PT09XG5cblx0dmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5cdGZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcblx0ICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3Rcblx0ICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuXHQgIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcblx0ICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuXHQgIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuXHQgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuXHQgICAgc3RyID0gc3RyICsgJz0nO1xuXHQgIH1cblx0ICByZXR1cm4gc3RyXG5cdH1cblxuXHRmdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcblx0ICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG5cdCAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcblx0fVxuXG5cdGZ1bmN0aW9uIHRvSGV4IChuKSB7XG5cdCAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG5cdCAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuXHQgIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG5cdCAgdmFyIGNvZGVQb2ludDtcblx0ICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0ICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cdCAgdmFyIGJ5dGVzID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuXHQgICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuXHQgICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcblx0ICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcblx0ICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG5cdCAgICAgICAgLy8gbm8gbGVhZCB5ZXRcblx0ICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG5cdCAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG5cdCAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG5cdCAgICAgICAgICBjb250aW51ZVxuXHQgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuXHQgICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuXHQgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuXHQgICAgICAgICAgY29udGludWVcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB2YWxpZCBsZWFkXG5cdCAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuXHQgICAgICAgIGNvbnRpbnVlXG5cdCAgICAgIH1cblxuXHQgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG5cdCAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcblx0ICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG5cdCAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblx0ICAgICAgICBjb250aW51ZVxuXHQgICAgICB9XG5cblx0ICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcblx0ICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcblx0ICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuXHQgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG5cdCAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcblx0ICAgIH1cblxuXHQgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cblx0ICAgIC8vIGVuY29kZSB1dGY4XG5cdCAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuXHQgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcblx0ICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuXHQgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuXHQgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblx0ICAgICAgYnl0ZXMucHVzaChcblx0ICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcblx0ICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuXHQgICAgICApO1xuXHQgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG5cdCAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuXHQgICAgICBieXRlcy5wdXNoKFxuXHQgICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuXHQgICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcblx0ICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuXHQgICAgICApO1xuXHQgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuXHQgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcblx0ICAgICAgYnl0ZXMucHVzaChcblx0ICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG5cdCAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuXHQgICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcblx0ICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuXHQgICAgICApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBieXRlc1xuXHR9XG5cblx0ZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcblx0ICB2YXIgYnl0ZUFycmF5ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcblx0ICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuXHQgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcblx0ICB9XG5cdCAgcmV0dXJuIGJ5dGVBcnJheVxuXHR9XG5cblx0ZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcblx0ICB2YXIgYywgaGksIGxvO1xuXHQgIHZhciBieXRlQXJyYXkgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuXHQgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cblx0ICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcblx0ICAgIGhpID0gYyA+PiA4O1xuXHQgICAgbG8gPSBjICUgMjU2O1xuXHQgICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuXHQgICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBieXRlQXJyYXlcblx0fVxuXG5cblx0ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG5cdCAgcmV0dXJuIHRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG5cdH1cblxuXHRmdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG5cdCAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG5cdCAgfVxuXHQgIHJldHVybiBpXG5cdH1cblxuXHRmdW5jdGlvbiBpc25hbiAodmFsKSB7XG5cdCAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdH1cblxuXG5cdC8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcblx0Ly8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuXHQvLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5cdGZ1bmN0aW9uIGlzQnVmZmVyJDMob2JqKSB7XG5cdCAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpXG5cdH1cblxuXHRmdW5jdGlvbiBpc0Zhc3RCdWZmZXIgKG9iaikge1xuXHQgIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG5cdH1cblxuXHQvLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuXHRmdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuXHQgIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcblx0fVxuXG5cdC8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXHQvLyBiYXNlZCBvZmYgaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS1wcm9jZXNzL2Jsb2IvbWFzdGVyL2Jyb3dzZXIuanNcblxuXHRmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG5cdH1cblx0ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuXHR9XG5cdHZhciBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcblx0dmFyIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5cdGlmICh0eXBlb2YgZ2xvYmFsJDEuc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdH1cblx0aWYgKHR5cGVvZiBnbG9iYWwkMS5jbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG5cdCAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuXHQgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuXHQgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9XG5cdCAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdCAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgICB9IGNhdGNoKGUpe1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG5cdCAgICAgICAgfSBjYXRjaChlKXtcblx0ICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3Jcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXG5cdH1cblx0ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuXHQgICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5cdCAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXHQgICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG5cdCAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcblx0ICAgIH0gY2F0Y2ggKGUpe1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG5cdCAgICAgICAgfSBjYXRjaCAoZSl7XG5cdCAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuXHQgICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXG5cblx0fVxuXHR2YXIgcXVldWUgPSBbXTtcblx0dmFyIGRyYWluaW5nID0gZmFsc2U7XG5cdHZhciBjdXJyZW50UXVldWU7XG5cdHZhciBxdWV1ZUluZGV4ID0gLTE7XG5cblx0ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuXHQgICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgZHJhaW5pbmcgPSBmYWxzZTtcblx0ICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG5cdCAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuXHQgICAgfVxuXHQgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgIGRyYWluUXVldWUoKTtcblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG5cdCAgICBpZiAoZHJhaW5pbmcpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcblx0ICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuXHQgICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgIHdoaWxlKGxlbikge1xuXHQgICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuXHQgICAgICAgIHF1ZXVlID0gW107XG5cdCAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuXHQgICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgIH1cblx0ICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG5cdCAgICBkcmFpbmluZyA9IGZhbHNlO1xuXHQgICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHR9XG5cdGZ1bmN0aW9uIG5leHRUaWNrKGZ1bikge1xuXHQgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcblx0ICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG5cdCAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcblx0ICAgIH1cblx0fVxuXHQvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5cdGZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuXHQgICAgdGhpcy5mdW4gPSBmdW47XG5cdCAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG5cdH1cblx0SXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG5cdH07XG5cdHZhciB0aXRsZSA9ICdicm93c2VyJztcblx0dmFyIHBsYXRmb3JtID0gJ2Jyb3dzZXInO1xuXHR2YXIgYnJvd3NlciA9IHRydWU7XG5cdHZhciBlbnYgPSB7fTtcblx0dmFyIGFyZ3YgPSBbXTtcblx0dmFyIHZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcblx0dmFyIHZlcnNpb25zID0ge307XG5cdHZhciByZWxlYXNlID0ge307XG5cdHZhciBjb25maWcgPSB7fTtcblxuXHRmdW5jdGlvbiBub29wJDEoKSB7fVxuXG5cdHZhciBvbiA9IG5vb3AkMTtcblx0dmFyIGFkZExpc3RlbmVyID0gbm9vcCQxO1xuXHR2YXIgb25jZSA9IG5vb3AkMTtcblx0dmFyIG9mZiA9IG5vb3AkMTtcblx0dmFyIHJlbW92ZUxpc3RlbmVyID0gbm9vcCQxO1xuXHR2YXIgcmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcCQxO1xuXHR2YXIgZW1pdCA9IG5vb3AkMTtcblxuXHRmdW5jdGlvbiBiaW5kaW5nKG5hbWUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGN3ZCAoKSB7IHJldHVybiAnLycgfVxuXHRmdW5jdGlvbiBjaGRpciAoZGlyKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuXHR9ZnVuY3Rpb24gdW1hc2soKSB7IHJldHVybiAwOyB9XG5cblx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3VtYXZpcy9icm93c2VyLXByb2Nlc3MtaHJ0aW1lL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cdHZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbCQxLnBlcmZvcm1hbmNlIHx8IHt9O1xuXHR2YXIgcGVyZm9ybWFuY2VOb3cgPVxuXHQgIHBlcmZvcm1hbmNlLm5vdyAgICAgICAgfHxcblx0ICBwZXJmb3JtYW5jZS5tb3pOb3cgICAgIHx8XG5cdCAgcGVyZm9ybWFuY2UubXNOb3cgICAgICB8fFxuXHQgIHBlcmZvcm1hbmNlLm9Ob3cgICAgICAgfHxcblx0ICBwZXJmb3JtYW5jZS53ZWJraXROb3cgIHx8XG5cdCAgZnVuY3Rpb24oKXsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgfTtcblxuXHQvLyBnZW5lcmF0ZSB0aW1lc3RhbXAgb3IgZGVsdGFcblx0Ly8gc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2hydGltZVxuXHRmdW5jdGlvbiBocnRpbWUocHJldmlvdXNUaW1lc3RhbXApe1xuXHQgIHZhciBjbG9ja3RpbWUgPSBwZXJmb3JtYW5jZU5vdy5jYWxsKHBlcmZvcm1hbmNlKSoxZS0zO1xuXHQgIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpO1xuXHQgIHZhciBuYW5vc2Vjb25kcyA9IE1hdGguZmxvb3IoKGNsb2NrdGltZSUxKSoxZTkpO1xuXHQgIGlmIChwcmV2aW91c1RpbWVzdGFtcCkge1xuXHQgICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXTtcblx0ICAgIG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFsxXTtcblx0ICAgIGlmIChuYW5vc2Vjb25kczwwKSB7XG5cdCAgICAgIHNlY29uZHMtLTtcblx0ICAgICAgbmFub3NlY29uZHMgKz0gMWU5O1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gW3NlY29uZHMsbmFub3NlY29uZHNdXG5cdH1cblxuXHR2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcblx0ZnVuY3Rpb24gdXB0aW1lKCkge1xuXHQgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XG5cdCAgdmFyIGRpZiA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuXHQgIHJldHVybiBkaWYgLyAxMDAwO1xuXHR9XG5cblx0dmFyIGJyb3dzZXIkMSA9IHtcblx0ICBuZXh0VGljazogbmV4dFRpY2ssXG5cdCAgdGl0bGU6IHRpdGxlLFxuXHQgIGJyb3dzZXI6IGJyb3dzZXIsXG5cdCAgZW52OiBlbnYsXG5cdCAgYXJndjogYXJndixcblx0ICB2ZXJzaW9uOiB2ZXJzaW9uLFxuXHQgIHZlcnNpb25zOiB2ZXJzaW9ucyxcblx0ICBvbjogb24sXG5cdCAgYWRkTGlzdGVuZXI6IGFkZExpc3RlbmVyLFxuXHQgIG9uY2U6IG9uY2UsXG5cdCAgb2ZmOiBvZmYsXG5cdCAgcmVtb3ZlTGlzdGVuZXI6IHJlbW92ZUxpc3RlbmVyLFxuXHQgIHJlbW92ZUFsbExpc3RlbmVyczogcmVtb3ZlQWxsTGlzdGVuZXJzLFxuXHQgIGVtaXQ6IGVtaXQsXG5cdCAgYmluZGluZzogYmluZGluZyxcblx0ICBjd2Q6IGN3ZCxcblx0ICBjaGRpcjogY2hkaXIsXG5cdCAgdW1hc2s6IHVtYXNrLFxuXHQgIGhydGltZTogaHJ0aW1lLFxuXHQgIHBsYXRmb3JtOiBwbGF0Zm9ybSxcblx0ICByZWxlYXNlOiByZWxlYXNlLFxuXHQgIGNvbmZpZzogY29uZmlnLFxuXHQgIHVwdGltZTogdXB0aW1lXG5cdH07XG5cblx0dmFyIGluaGVyaXRzO1xuXHRpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpe1xuXHQgIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG5cdCAgICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuXHQgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuXHQgICAgICBjb25zdHJ1Y3Rvcjoge1xuXHQgICAgICAgIHZhbHVlOiBjdG9yLFxuXHQgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXHR9IGVsc2Uge1xuXHQgIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG5cdCAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3Rvcjtcblx0ICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcblx0ICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG5cdCAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG5cdCAgfTtcblx0fVxuXHR2YXIgaW5oZXJpdHMkMSA9IGluaGVyaXRzO1xuXG5cdHZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuXHRmdW5jdGlvbiBmb3JtYXQoZikge1xuXHQgIGlmICghaXNTdHJpbmckMShmKSkge1xuXHQgICAgdmFyIG9iamVjdHMgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0JDEoYXJndW1lbnRzW2ldKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG5cdCAgfVxuXG5cdCAgdmFyIGkgPSAxO1xuXHQgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHQgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcblx0ICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG5cdCAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcblx0ICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG5cdCAgICBzd2l0Y2ggKHgpIHtcblx0ICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG5cdCAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuXHQgICAgICBjYXNlICclaic6XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuXHQgICAgICAgIH0gY2F0Y2ggKF8pIHtcblx0ICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG5cdCAgICAgICAgfVxuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIHJldHVybiB4O1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG5cdCAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCQyKHgpKSB7XG5cdCAgICAgIHN0ciArPSAnICcgKyB4O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QkMSh4KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXG5cdC8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG5cdC8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG5cdC8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5cdGZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbXNnKSB7XG5cdCAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cblx0ICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsJDEucHJvY2VzcykpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIGRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICBpZiAoYnJvd3NlciQxLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcblx0ICAgIHJldHVybiBmbjtcblx0ICB9XG5cblx0ICB2YXIgd2FybmVkID0gZmFsc2U7XG5cdCAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcblx0ICAgIGlmICghd2FybmVkKSB7XG5cdCAgICAgIGlmIChicm93c2VyJDEudGhyb3dEZXByZWNhdGlvbikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHQgICAgICB9IGVsc2UgaWYgKGJyb3dzZXIkMS50cmFjZURlcHJlY2F0aW9uKSB7XG5cdCAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcblx0ICAgICAgfVxuXHQgICAgICB3YXJuZWQgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG5cdH1cblxuXHR2YXIgZGVidWdzID0ge307XG5cdHZhciBkZWJ1Z0Vudmlyb247XG5cdGZ1bmN0aW9uIGRlYnVnbG9nKHNldCkge1xuXHQgIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuXHQgICAgZGVidWdFbnZpcm9uID0gYnJvd3NlciQxLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuXHQgIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuXHQgIGlmICghZGVidWdzW3NldF0pIHtcblx0ICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuXHQgICAgICB2YXIgcGlkID0gMDtcblx0ICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgbXNnID0gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBkZWJ1Z3Nbc2V0XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG5cdCAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuXHQgKi9cblx0LyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuXHRmdW5jdGlvbiBpbnNwZWN0JDEob2JqLCBvcHRzKSB7XG5cdCAgLy8gZGVmYXVsdCBvcHRpb25zXG5cdCAgdmFyIGN0eCA9IHtcblx0ICAgIHNlZW46IFtdLFxuXHQgICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3Jcblx0ICB9O1xuXHQgIC8vIGxlZ2FjeS4uLlxuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuXHQgIGlmIChpc0Jvb2xlYW4kMShvcHRzKSkge1xuXHQgICAgLy8gbGVnYWN5Li4uXG5cdCAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG5cdCAgfSBlbHNlIGlmIChvcHRzKSB7XG5cdCAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG5cdCAgICBfZXh0ZW5kKGN0eCwgb3B0cyk7XG5cdCAgfVxuXHQgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcblx0ICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuXHQgIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuXHQgIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuXHQgIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcblx0ICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuXHQgIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcblx0fVxuXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuXHRpbnNwZWN0JDEuY29sb3JzID0ge1xuXHQgICdib2xkJyA6IFsxLCAyMl0sXG5cdCAgJ2l0YWxpYycgOiBbMywgMjNdLFxuXHQgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcblx0ICAnaW52ZXJzZScgOiBbNywgMjddLFxuXHQgICd3aGl0ZScgOiBbMzcsIDM5XSxcblx0ICAnZ3JleScgOiBbOTAsIDM5XSxcblx0ICAnYmxhY2snIDogWzMwLCAzOV0sXG5cdCAgJ2JsdWUnIDogWzM0LCAzOV0sXG5cdCAgJ2N5YW4nIDogWzM2LCAzOV0sXG5cdCAgJ2dyZWVuJyA6IFszMiwgMzldLFxuXHQgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuXHQgICdyZWQnIDogWzMxLCAzOV0sXG5cdCAgJ3llbGxvdycgOiBbMzMsIDM5XVxuXHR9O1xuXG5cdC8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuXHRpbnNwZWN0JDEuc3R5bGVzID0ge1xuXHQgICdzcGVjaWFsJzogJ2N5YW4nLFxuXHQgICdudW1iZXInOiAneWVsbG93Jyxcblx0ICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuXHQgICd1bmRlZmluZWQnOiAnZ3JleScsXG5cdCAgJ251bGwnOiAnYm9sZCcsXG5cdCAgJ3N0cmluZyc6ICdncmVlbicsXG5cdCAgJ2RhdGUnOiAnbWFnZW50YScsXG5cdCAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcblx0ICAncmVnZXhwJzogJ3JlZCdcblx0fTtcblxuXG5cdGZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcblx0ICB2YXIgc3R5bGUgPSBpbnNwZWN0JDEuc3R5bGVzW3N0eWxlVHlwZV07XG5cblx0ICBpZiAoc3R5bGUpIHtcblx0ICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdCQxLmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuXHQgICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0JDEuY29sb3JzW3N0eWxlXVsxXSArICdtJztcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIHN0cjtcblx0ICB9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXG5cblx0ZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcblx0ICB2YXIgaGFzaCA9IHt9O1xuXG5cdCAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuXHQgICAgaGFzaFt2YWxdID0gdHJ1ZTtcblx0ICB9KTtcblxuXHQgIHJldHVybiBoYXNoO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcblx0ICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG5cdCAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG5cdCAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG5cdCAgICAgIHZhbHVlICYmXG5cdCAgICAgIGlzRnVuY3Rpb24kMih2YWx1ZS5pbnNwZWN0KSAmJlxuXHQgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcblx0ICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gaW5zcGVjdCQxICYmXG5cdCAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuXHQgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG5cdCAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG5cdCAgICBpZiAoIWlzU3RyaW5nJDEocmV0KSkge1xuXHQgICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXQ7XG5cdCAgfVxuXG5cdCAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcblx0ICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuXHQgIGlmIChwcmltaXRpdmUpIHtcblx0ICAgIHJldHVybiBwcmltaXRpdmU7XG5cdCAgfVxuXG5cdCAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuXHQgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXHQgIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG5cdCAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG5cdCAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuXHQgIH1cblxuXHQgIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcblx0ICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuXHQgIGlmIChpc0Vycm9yJDEodmFsdWUpXG5cdCAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuXHQgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcblx0ICB9XG5cblx0ICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG5cdCAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICBpZiAoaXNGdW5jdGlvbiQyKHZhbHVlKSkge1xuXHQgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuXHQgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzUmVnRXhwJDIodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNEYXRlJDEodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0Vycm9yJDEodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuXHQgIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcblx0ICBpZiAoaXNBcnJheSQ1KHZhbHVlKSkge1xuXHQgICAgYXJyYXkgPSB0cnVlO1xuXHQgICAgYnJhY2VzID0gWydbJywgJ10nXTtcblx0ICB9XG5cblx0ICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcblx0ICBpZiAoaXNGdW5jdGlvbiQyKHZhbHVlKSkge1xuXHQgICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcblx0ICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuXHQgIH1cblxuXHQgIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG5cdCAgaWYgKGlzUmVnRXhwJDIodmFsdWUpKSB7XG5cdCAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0ICB9XG5cblx0ICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcblx0ICBpZiAoaXNEYXRlJDEodmFsdWUpKSB7XG5cdCAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdCAgfVxuXG5cdCAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuXHQgIGlmIChpc0Vycm9yJDEodmFsdWUpKSB7XG5cdCAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuXHQgIH1cblxuXHQgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuXHQgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG5cdCAgfVxuXG5cdCAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcblx0ICAgIGlmIChpc1JlZ0V4cCQyKHZhbHVlKSkge1xuXHQgICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cblx0ICB2YXIgb3V0cHV0O1xuXHQgIGlmIChhcnJheSkge1xuXHQgICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBjdHguc2Vlbi5wb3AoKTtcblxuXHQgIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG5cdCAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcblx0ICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXHQgIGlmIChpc1N0cmluZyQxKHZhbHVlKSkge1xuXHQgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuXHQgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXHQgIH1cblx0ICBpZiAoaXNOdW1iZXIkMSh2YWx1ZSkpXG5cdCAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXHQgIGlmIChpc0Jvb2xlYW4kMSh2YWx1ZSkpXG5cdCAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcblx0ICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG5cdCAgaWYgKGlzTnVsbCh2YWx1ZSkpXG5cdCAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuXHQgIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcblx0ICB2YXIgb3V0cHV0ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgIGlmIChoYXNPd25Qcm9wZXJ0eSRkKHZhbHVlLCBTdHJpbmcoaSkpKSB7XG5cdCAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG5cdCAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG91dHB1dC5wdXNoKCcnKTtcblx0ICAgIH1cblx0ICB9XG5cdCAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHQgICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG5cdCAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG5cdCAgICAgICAgICBrZXksIHRydWUpKTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gb3V0cHV0O1xuXHR9XG5cblxuXHRmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG5cdCAgdmFyIG5hbWUsIHN0ciwgZGVzYztcblx0ICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG5cdCAgaWYgKGRlc2MuZ2V0KSB7XG5cdCAgICBpZiAoZGVzYy5zZXQpIHtcblx0ICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoZGVzYy5zZXQpIHtcblx0ICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKCFoYXNPd25Qcm9wZXJ0eSRkKHZpc2libGVLZXlzLCBrZXkpKSB7XG5cdCAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuXHQgIH1cblx0ICBpZiAoIXN0cikge1xuXHQgICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG5cdCAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuXHQgICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcblx0ICAgICAgICBpZiAoYXJyYXkpIHtcblx0ICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuXHQgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcblx0ICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcblx0ICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG5cdCAgICAgIHJldHVybiBzdHI7XG5cdCAgICB9XG5cdCAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuXHQgICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG5cdCAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuXHQgICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuXHQgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcblx0ICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcblx0ICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG5cdCAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG5cdCAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIDtcblx0ICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcblx0ICB9LCAwKTtcblxuXHQgIGlmIChsZW5ndGggPiA2MCkge1xuXHQgICAgcmV0dXJuIGJyYWNlc1swXSArXG5cdCAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG5cdCAgICAgICAgICAgJyAnICtcblx0ICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuXHQgICAgICAgICAgICcgJyArXG5cdCAgICAgICAgICAgYnJhY2VzWzFdO1xuXHQgIH1cblxuXHQgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG5cdH1cblxuXG5cdC8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuXHQvLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblx0ZnVuY3Rpb24gaXNBcnJheSQ1KGFyKSB7XG5cdCAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNCb29sZWFuJDEoYXJnKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcblx0fVxuXG5cdGZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcblx0ICByZXR1cm4gYXJnID09PSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZyA9PSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNOdW1iZXIkMShhcmcpIHtcblx0ICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG5cdH1cblxuXHRmdW5jdGlvbiBpc1N0cmluZyQxKGFyZykge1xuXHQgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcblx0fVxuXG5cdGZ1bmN0aW9uIGlzU3ltYm9sJDIoYXJnKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNSZWdFeHAkMihyZSkge1xuXHQgIHJldHVybiBpc09iamVjdCQyKHJlKSAmJiBvYmplY3RUb1N0cmluZyQyKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cdH1cblxuXHRmdW5jdGlvbiBpc09iamVjdCQyKGFyZykge1xuXHQgIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0RhdGUkMShkKSB7XG5cdCAgcmV0dXJuIGlzT2JqZWN0JDIoZCkgJiYgb2JqZWN0VG9TdHJpbmckMihkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNFcnJvciQxKGUpIHtcblx0ICByZXR1cm4gaXNPYmplY3QkMihlKSAmJlxuXHQgICAgICAob2JqZWN0VG9TdHJpbmckMihlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNGdW5jdGlvbiQyKGFyZykge1xuXHQgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuXHQgICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcblx0ICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0J1ZmZlciQyKG1heWJlQnVmKSB7XG5cdCAgcmV0dXJuIEJ1ZmZlciQzLmlzQnVmZmVyKG1heWJlQnVmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nJDIobykge1xuXHQgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHBhZChuKSB7XG5cdCAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG5cdH1cblxuXG5cdHZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcblx0ICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuXHQvLyAyNiBGZWIgMTY6MTk6MzRcblx0ZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuXHQgIHZhciBkID0gbmV3IERhdGUoKTtcblx0ICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcblx0ICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuXHQgICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcblx0ICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xuXHR9XG5cblxuXHQvLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5cdGZ1bmN0aW9uIGxvZygpIHtcblx0ICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBfZXh0ZW5kKG9yaWdpbiwgYWRkKSB7XG5cdCAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuXHQgIGlmICghYWRkIHx8ICFpc09iamVjdCQyKGFkZCkpIHJldHVybiBvcmlnaW47XG5cblx0ICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG5cdCAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBvcmlnaW47XG5cdH1cblx0ZnVuY3Rpb24gaGFzT3duUHJvcGVydHkkZChvYmosIHByb3ApIHtcblx0ICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5cdH1cblxuXHR2YXIgX3BvbHlmaWxsTm9kZV91dGlsID0ge1xuXHQgIGluaGVyaXRzOiBpbmhlcml0cyQxLFxuXHQgIF9leHRlbmQ6IF9leHRlbmQsXG5cdCAgbG9nOiBsb2csXG5cdCAgaXNCdWZmZXI6IGlzQnVmZmVyJDIsXG5cdCAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuXHQgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24kMixcblx0ICBpc0Vycm9yOiBpc0Vycm9yJDEsXG5cdCAgaXNEYXRlOiBpc0RhdGUkMSxcblx0ICBpc09iamVjdDogaXNPYmplY3QkMixcblx0ICBpc1JlZ0V4cDogaXNSZWdFeHAkMixcblx0ICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG5cdCAgaXNTeW1ib2w6IGlzU3ltYm9sJDIsXG5cdCAgaXNTdHJpbmc6IGlzU3RyaW5nJDEsXG5cdCAgaXNOdW1iZXI6IGlzTnVtYmVyJDEsXG5cdCAgaXNOdWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuXHQgIGlzTnVsbDogaXNOdWxsLFxuXHQgIGlzQm9vbGVhbjogaXNCb29sZWFuJDEsXG5cdCAgaXNBcnJheTogaXNBcnJheSQ1LFxuXHQgIGluc3BlY3Q6IGluc3BlY3QkMSxcblx0ICBkZXByZWNhdGU6IGRlcHJlY2F0ZSxcblx0ICBmb3JtYXQ6IGZvcm1hdCxcblx0ICBkZWJ1Z2xvZzogZGVidWdsb2dcblx0fTtcblxuXHR2YXIgX3BvbHlmaWxsTm9kZV91dGlsJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdGZvcm1hdDogZm9ybWF0LFxuXHRcdGRlcHJlY2F0ZTogZGVwcmVjYXRlLFxuXHRcdGRlYnVnbG9nOiBkZWJ1Z2xvZyxcblx0XHRpbnNwZWN0OiBpbnNwZWN0JDEsXG5cdFx0aXNBcnJheTogaXNBcnJheSQ1LFxuXHRcdGlzQm9vbGVhbjogaXNCb29sZWFuJDEsXG5cdFx0aXNOdWxsOiBpc051bGwsXG5cdFx0aXNOdWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuXHRcdGlzTnVtYmVyOiBpc051bWJlciQxLFxuXHRcdGlzU3RyaW5nOiBpc1N0cmluZyQxLFxuXHRcdGlzU3ltYm9sOiBpc1N5bWJvbCQyLFxuXHRcdGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcblx0XHRpc1JlZ0V4cDogaXNSZWdFeHAkMixcblx0XHRpc09iamVjdDogaXNPYmplY3QkMixcblx0XHRpc0RhdGU6IGlzRGF0ZSQxLFxuXHRcdGlzRXJyb3I6IGlzRXJyb3IkMSxcblx0XHRpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uJDIsXG5cdFx0aXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuXHRcdGlzQnVmZmVyOiBpc0J1ZmZlciQyLFxuXHRcdGxvZzogbG9nLFxuXHRcdGluaGVyaXRzOiBpbmhlcml0cyQxLFxuXHRcdF9leHRlbmQ6IF9leHRlbmQsXG5cdFx0J2RlZmF1bHQnOiBfcG9seWZpbGxOb2RlX3V0aWxcblx0fSk7XG5cblx0dmFyIHJlcXVpcmUkJDAgPSAvKkBfX1BVUkVfXyovZ2V0QXVnbWVudGVkTmFtZXNwYWNlKF9wb2x5ZmlsbE5vZGVfdXRpbCQxKTtcblxuXHR2YXIgdXRpbF9pbnNwZWN0ID0gcmVxdWlyZSQkMC5pbnNwZWN0O1xuXG5cdHZhciBoYXNNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIE1hcC5wcm90b3R5cGU7XG5cdHZhciBtYXBTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzTWFwID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNYXAucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcblx0dmFyIG1hcFNpemUgPSBoYXNNYXAgJiYgbWFwU2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIG1hcFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG5cdHZhciBtYXBGb3JFYWNoID0gaGFzTWFwICYmIE1hcC5wcm90b3R5cGUuZm9yRWFjaDtcblx0dmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgU2V0LnByb3RvdHlwZTtcblx0dmFyIHNldFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNTZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNldC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xuXHR2YXIgc2V0U2l6ZSA9IGhhc1NldCAmJiBzZXRTaXplRGVzY3JpcHRvciAmJiB0eXBlb2Ygc2V0U2l6ZURlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nID8gc2V0U2l6ZURlc2NyaXB0b3IuZ2V0IDogbnVsbDtcblx0dmFyIHNldEZvckVhY2ggPSBoYXNTZXQgJiYgU2V0LnByb3RvdHlwZS5mb3JFYWNoO1xuXHR2YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlO1xuXHR2YXIgd2Vha01hcEhhcyA9IGhhc1dlYWtNYXAgPyBXZWFrTWFwLnByb3RvdHlwZS5oYXMgOiBudWxsO1xuXHR2YXIgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nICYmIFdlYWtTZXQucHJvdG90eXBlO1xuXHR2YXIgd2Vha1NldEhhcyA9IGhhc1dlYWtTZXQgPyBXZWFrU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xuXHR2YXIgaGFzV2Vha1JlZiA9IHR5cGVvZiBXZWFrUmVmID09PSAnZnVuY3Rpb24nICYmIFdlYWtSZWYucHJvdG90eXBlO1xuXHR2YXIgd2Vha1JlZkRlcmVmID0gaGFzV2Vha1JlZiA/IFdlYWtSZWYucHJvdG90eXBlLmRlcmVmIDogbnVsbDtcblx0dmFyIGJvb2xlYW5WYWx1ZU9mID0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZjtcblx0dmFyIG9iamVjdFRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIG1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcblx0dmFyIGJpZ0ludFZhbHVlT2YgPSB0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nID8gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mIDogbnVsbDtcblx0dmFyIGdPUFMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgc3ltVG9TdHJpbmcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID8gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyA6IG51bGw7XG5cdHZhciBoYXNTaGFtbWVkU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ29iamVjdCc7XG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cdHZhciBnUE8gPSAodHlwZW9mIFJlZmxlY3QgPT09ICdmdW5jdGlvbicgPyBSZWZsZWN0LmdldFByb3RvdHlwZU9mIDogT2JqZWN0LmdldFByb3RvdHlwZU9mKSB8fCAoXG5cdCAgICBbXS5fX3Byb3RvX18gPT09IEFycmF5LnByb3RvdHlwZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cdCAgICAgICAgPyBmdW5jdGlvbiAoTykge1xuXHQgICAgICAgICAgICByZXR1cm4gTy5fX3Byb3RvX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblx0ICAgICAgICB9XG5cdCAgICAgICAgOiBudWxsXG5cdCk7XG5cblx0dmFyIGluc3BlY3RDdXN0b20gPSB1dGlsX2luc3BlY3QuY3VzdG9tO1xuXHR2YXIgaW5zcGVjdFN5bWJvbCA9IGluc3BlY3RDdXN0b20gJiYgaXNTeW1ib2wkMShpbnNwZWN0Q3VzdG9tKSA/IGluc3BlY3RDdXN0b20gOiBudWxsO1xuXHR2YXIgdG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogbnVsbDtcblxuXHR2YXIgb2JqZWN0SW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3RfKG9iaiwgb3B0aW9ucywgZGVwdGgsIHNlZW4pIHtcblx0ICAgIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuXHQgICAgaWYgKGhhcyQzKG9wdHMsICdxdW90ZVN0eWxlJykgJiYgKG9wdHMucXVvdGVTdHlsZSAhPT0gJ3NpbmdsZScgJiYgb3B0cy5xdW90ZVN0eWxlICE9PSAnZG91YmxlJykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJxdW90ZVN0eWxlXCIgbXVzdCBiZSBcInNpbmdsZVwiIG9yIFwiZG91YmxlXCInKTtcblx0ICAgIH1cblx0ICAgIGlmIChcblx0ICAgICAgICBoYXMkMyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcblx0ICAgICAgICAgICAgPyBvcHRzLm1heFN0cmluZ0xlbmd0aCA8IDAgJiYgb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IEluZmluaXR5XG5cdCAgICAgICAgICAgIDogb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IG51bGxcblx0ICAgICAgICApXG5cdCAgICApIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJtYXhTdHJpbmdMZW5ndGhcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBJbmZpbml0eSwgb3IgYG51bGxgJyk7XG5cdCAgICB9XG5cdCAgICB2YXIgY3VzdG9tSW5zcGVjdCA9IGhhcyQzKG9wdHMsICdjdXN0b21JbnNwZWN0JykgPyBvcHRzLmN1c3RvbUluc3BlY3QgOiB0cnVlO1xuXHQgICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJjdXN0b21JbnNwZWN0XCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCwgYGZhbHNlYCwgb3IgYFxcJ3N5bWJvbFxcJ2AnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKFxuXHQgICAgICAgIGhhcyQzKG9wdHMsICdpbmRlbnQnKVxuXHQgICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG5cdCAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09ICdcXHQnXG5cdCAgICAgICAgJiYgIShwYXJzZUludChvcHRzLmluZGVudCwgMTApID09PSBvcHRzLmluZGVudCAmJiBvcHRzLmluZGVudCA+IDApXG5cdCAgICApIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuXHQgICAgfVxuXHQgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiAnbnVsbCc7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG5cdCAgICAgICAgcmV0dXJuIG9iaiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKG9iaiwgb3B0cyk7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICBpZiAob2JqID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBJbmZpbml0eSAvIG9iaiA+IDAgPyAnMCcgOiAnLTAnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gU3RyaW5nKG9iaik7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcblx0ICAgICAgICByZXR1cm4gU3RyaW5nKG9iaikgKyAnbic7XG5cdCAgICB9XG5cblx0ICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuXHQgICAgaWYgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVwdGggPSAwOyB9XG5cdCAgICBpZiAoZGVwdGggPj0gbWF4RGVwdGggJiYgbWF4RGVwdGggPiAwICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIGlzQXJyYXkkNChvYmopID8gJ1tBcnJheV0nIDogJ1tPYmplY3RdJztcblx0ICAgIH1cblxuXHQgICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cblx0ICAgIGlmICh0eXBlb2Ygc2VlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBzZWVuID0gW107XG5cdCAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcblx0ICAgICAgICBpZiAoZnJvbSkge1xuXHQgICAgICAgICAgICBzZWVuID0gc2Vlbi5zbGljZSgpO1xuXHQgICAgICAgICAgICBzZWVuLnB1c2goZnJvbSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChub0luZGVudCkge1xuXHQgICAgICAgICAgICB2YXIgbmV3T3B0cyA9IHtcblx0ICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmIChoYXMkMyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG5cdCAgICAgICAgICAgICAgICBuZXdPcHRzLnF1b3RlU3R5bGUgPSBvcHRzLnF1b3RlU3R5bGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG9wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdmFyIG5hbWUgPSBuYW1lT2Yob2JqKTtcblx0ICAgICAgICB2YXIga2V5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcblx0ICAgICAgICByZXR1cm4gJ1tGdW5jdGlvbicgKyAobmFtZSA/ICc6ICcgKyBuYW1lIDogJyAoYW5vbnltb3VzKScpICsgJ10nICsgKGtleXMubGVuZ3RoID4gMCA/ICcgeyAnICsga2V5cy5qb2luKCcsICcpICsgJyB9JyA6ICcnKTtcblx0ICAgIH1cblx0ICAgIGlmIChpc1N5bWJvbCQxKG9iaikpIHtcblx0ICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyBTdHJpbmcob2JqKS5yZXBsYWNlKC9eKFN5bWJvbFxcKC4qXFwpKV9bXildKiQvLCAnJDEnKSA6IHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWhhc1NoYW1tZWRTeW1ib2xzID8gbWFya0JveGVkKHN5bVN0cmluZykgOiBzeW1TdHJpbmc7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNFbGVtZW50KG9iaikpIHtcblx0ICAgICAgICB2YXIgcyA9ICc8JyArIFN0cmluZyhvYmoubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXMgfHwgW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBzICs9ICcgJyArIGF0dHJzW2ldLm5hbWUgKyAnPScgKyB3cmFwUXVvdGVzKHF1b3RlKGF0dHJzW2ldLnZhbHVlKSwgJ2RvdWJsZScsIG9wdHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzICs9ICc+Jztcblx0ICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXMgJiYgb2JqLmNoaWxkTm9kZXMubGVuZ3RoKSB7IHMgKz0gJy4uLic7IH1cblx0ICAgICAgICBzICs9ICc8LycgKyBTdHJpbmcob2JqLm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpICsgJz4nO1xuXHQgICAgICAgIHJldHVybiBzO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzQXJyYXkkNChvYmopKSB7XG5cdCAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cblx0ICAgICAgICB2YXIgeHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG5cdCAgICAgICAgaWYgKGluZGVudCAmJiAhc2luZ2xlTGluZVZhbHVlcyh4cykpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuICdbICcgKyB4cy5qb2luKCcsICcpICsgJyBdJztcblx0ICAgIH1cblx0ICAgIGlmIChpc0Vycm9yKG9iaikpIHtcblx0ICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG5cdCAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJ1snICsgU3RyaW5nKG9iaikgKyAnXSc7IH1cblx0ICAgICAgICByZXR1cm4gJ3sgWycgKyBTdHJpbmcob2JqKSArICddICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBjdXN0b21JbnNwZWN0KSB7XG5cdCAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICByZXR1cm4gb2JqW2luc3BlY3RTeW1ib2xdKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9iai5pbnNwZWN0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGlzTWFwJDEob2JqKSkge1xuXHQgICAgICAgIHZhciBtYXBQYXJ0cyA9IFtdO1xuXHQgICAgICAgIG1hcEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdCAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdNYXAnLCBtYXBTaXplLmNhbGwob2JqKSwgbWFwUGFydHMsIGluZGVudCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNTZXQkMShvYmopKSB7XG5cdCAgICAgICAgdmFyIHNldFBhcnRzID0gW107XG5cdCAgICAgICAgc2V0Rm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHNldFBhcnRzLnB1c2goaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignU2V0Jywgc2V0U2l6ZS5jYWxsKG9iaiksIHNldFBhcnRzLCBpbmRlbnQpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzV2Vha01hcChvYmopKSB7XG5cdCAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcblx0ICAgIH1cblx0ICAgIGlmIChpc1dlYWtTZXQob2JqKSkge1xuXHQgICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrU2V0Jyk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNXZWFrUmVmKG9iaikpIHtcblx0ICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1JlZicpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzTnVtYmVyKG9iaikpIHtcblx0ICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0JpZ0ludChvYmopKSB7XG5cdCAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNCb29sZWFuKG9iaikpIHtcblx0ICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuXHQgICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAkMShvYmopKSB7XG5cdCAgICAgICAgdmFyIHlzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuXHQgICAgICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZ1BPID8gZ1BPKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgOiBvYmogaW5zdGFuY2VvZiBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5cdCAgICAgICAgdmFyIHByb3RvVGFnID0gb2JqIGluc3RhbmNlb2YgT2JqZWN0ID8gJycgOiAnbnVsbCBwcm90b3R5cGUnO1xuXHQgICAgICAgIHZhciBzdHJpbmdUYWcgPSAhaXNQbGFpbk9iamVjdCAmJiB0b1N0cmluZ1RhZyAmJiBPYmplY3Qob2JqKSA9PT0gb2JqICYmIHRvU3RyaW5nVGFnIGluIG9iaiA/IHRvU3RyKG9iaikuc2xpY2UoOCwgLTEpIDogcHJvdG9UYWcgPyAnT2JqZWN0JyA6ICcnO1xuXHQgICAgICAgIHZhciBjb25zdHJ1Y3RvclRhZyA9IGlzUGxhaW5PYmplY3QgfHwgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyA/ICcnIDogb2JqLmNvbnN0cnVjdG9yLm5hbWUgPyBvYmouY29uc3RydWN0b3IubmFtZSArICcgJyA6ICcnO1xuXHQgICAgICAgIHZhciB0YWcgPSBjb25zdHJ1Y3RvclRhZyArIChzdHJpbmdUYWcgfHwgcHJvdG9UYWcgPyAnWycgKyBbXS5jb25jYXQoc3RyaW5nVGFnIHx8IFtdLCBwcm90b1RhZyB8fCBbXSkuam9pbignOiAnKSArICddICcgOiAnJyk7XG5cdCAgICAgICAgaWYgKHlzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdGFnICsgJ3t9JzsgfVxuXHQgICAgICAgIGlmIChpbmRlbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRhZyArICd7JyArIGluZGVudGVkSm9pbih5cywgaW5kZW50KSArICd9Jztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRhZyArICd7ICcgKyB5cy5qb2luKCcsICcpICsgJyB9Jztcblx0ICAgIH1cblx0ICAgIHJldHVybiBTdHJpbmcob2JqKTtcblx0fTtcblxuXHRmdW5jdGlvbiB3cmFwUXVvdGVzKHMsIGRlZmF1bHRTdHlsZSwgb3B0cykge1xuXHQgICAgdmFyIHF1b3RlQ2hhciA9IChvcHRzLnF1b3RlU3R5bGUgfHwgZGVmYXVsdFN0eWxlKSA9PT0gJ2RvdWJsZScgPyAnXCInIDogXCInXCI7XG5cdCAgICByZXR1cm4gcXVvdGVDaGFyICsgcyArIHF1b3RlQ2hhcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHF1b3RlKHMpIHtcblx0ICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNBcnJheSQ0KG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cblx0ZnVuY3Rpb24gaXNEYXRlKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXHRmdW5jdGlvbiBpc1JlZ0V4cCQxKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5cdGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBFcnJvcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXHRmdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXHRmdW5jdGlvbiBpc051bWJlcihvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxuXHRmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBCb29sZWFuXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XG5cblx0Ly8gU3ltYm9sIGFuZCBCaWdJbnQgZG8gaGF2ZSBTeW1ib2wudG9TdHJpbmdUYWcgYnkgc3BlYywgc28gdGhhdCBjYW4ndCBiZSB1c2VkIHRvIGVsaW1pbmF0ZSBmYWxzZSBwb3NpdGl2ZXNcblx0ZnVuY3Rpb24gaXNTeW1ib2wkMShvYmopIHtcblx0ICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuXHQgICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqIGluc3RhbmNlb2YgU3ltYm9sO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzeW1ib2wnKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhc3ltVG9TdHJpbmcpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHN5bVRvU3RyaW5nLmNhbGwob2JqKTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0JpZ0ludChvYmopIHtcblx0ICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFiaWdJbnRWYWx1ZU9mKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICBiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gdGhpczsgfTtcblx0ZnVuY3Rpb24gaGFzJDMob2JqLCBrZXkpIHtcblx0ICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XG5cdH1cblxuXHRmdW5jdGlvbiB0b1N0cihvYmopIHtcblx0ICAgIHJldHVybiBvYmplY3RUb1N0cmluZyQxLmNhbGwob2JqKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5hbWVPZihmKSB7XG5cdCAgICBpZiAoZi5uYW1lKSB7IHJldHVybiBmLm5hbWU7IH1cblx0ICAgIHZhciBtID0gbWF0Y2guY2FsbChmdW5jdGlvblRvU3RyaW5nLmNhbGwoZiksIC9eZnVuY3Rpb25cXHMqKFtcXHckXSspLyk7XG5cdCAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG5cdCAgICBpZiAoeHMuaW5kZXhPZikgeyByZXR1cm4geHMuaW5kZXhPZih4KTsgfVxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHsgcmV0dXJuIGk7IH1cblx0ICAgIH1cblx0ICAgIHJldHVybiAtMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzTWFwJDEoeCkge1xuXHQgICAgaWYgKCFtYXBTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHNldFNpemUuY2FsbCh4KTtcblx0ICAgICAgICB9IGNhdGNoIChzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIE1hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcblx0ICAgIGlmICghd2Vha01hcEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHdlYWtNYXBIYXMuY2FsbCh4LCB3ZWFrTWFwSGFzKTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG5cdCAgICAgICAgfSBjYXRjaCAocykge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXZWFrTWFwOyAvLyBjb3JlLWpzIHdvcmthcm91bmQsIHByZS12Mi41LjBcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBpc1dlYWtSZWYoeCkge1xuXHQgICAgaWYgKCF3ZWFrUmVmRGVyZWYgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICB3ZWFrUmVmRGVyZWYuY2FsbCh4KTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBpc1NldCQxKHgpIHtcblx0ICAgIGlmICghc2V0U2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHNldFNpemUuY2FsbCh4KTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBtYXBTaXplLmNhbGwoeCk7XG5cdCAgICAgICAgfSBjYXRjaCAobSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzV2Vha1NldCh4KSB7XG5cdCAgICBpZiAoIXdlYWtTZXRIYXMgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgdHJ5IHtcblx0ICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgd2Vha01hcEhhcy5jYWxsKHgsIHdlYWtNYXBIYXMpO1xuXHQgICAgICAgIH0gY2F0Y2ggKHMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNFbGVtZW50KHgpIHtcblx0ICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdCAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zcGVjdFN0cmluZyhzdHIsIG9wdHMpIHtcblx0ICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcblx0ICAgICAgICB2YXIgcmVtYWluaW5nID0gc3RyLmxlbmd0aCAtIG9wdHMubWF4U3RyaW5nTGVuZ3RoO1xuXHQgICAgICAgIHZhciB0cmFpbGVyID0gJy4uLiAnICsgcmVtYWluaW5nICsgJyBtb3JlIGNoYXJhY3RlcicgKyAocmVtYWluaW5nID4gMSA/ICdzJyA6ICcnKTtcblx0ICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhzdHIuc2xpY2UoMCwgb3B0cy5tYXhTdHJpbmdMZW5ndGgpLCBvcHRzKSArIHRyYWlsZXI7XG5cdCAgICB9XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuXHQgICAgdmFyIHMgPSBzdHIucmVwbGFjZSgvKFsnXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuXHQgICAgcmV0dXJuIHdyYXBRdW90ZXMocywgJ3NpbmdsZScsIG9wdHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG93Ynl0ZShjKSB7XG5cdCAgICB2YXIgbiA9IGMuY2hhckNvZGVBdCgwKTtcblx0ICAgIHZhciB4ID0ge1xuXHQgICAgICAgIDg6ICdiJyxcblx0ICAgICAgICA5OiAndCcsXG5cdCAgICAgICAgMTA6ICduJyxcblx0ICAgICAgICAxMjogJ2YnLFxuXHQgICAgICAgIDEzOiAncidcblx0ICAgIH1bbl07XG5cdCAgICBpZiAoeCkgeyByZXR1cm4gJ1xcXFwnICsgeDsgfVxuXHQgICAgcmV0dXJuICdcXFxceCcgKyAobiA8IDB4MTAgPyAnMCcgOiAnJykgKyBuLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFya0JveGVkKHN0cikge1xuXHQgICAgcmV0dXJuICdPYmplY3QoJyArIHN0ciArICcpJztcblx0fVxuXG5cdGZ1bmN0aW9uIHdlYWtDb2xsZWN0aW9uT2YodHlwZSkge1xuXHQgICAgcmV0dXJuIHR5cGUgKyAnIHsgPyB9Jztcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbGxlY3Rpb25PZih0eXBlLCBzaXplLCBlbnRyaWVzLCBpbmRlbnQpIHtcblx0ICAgIHZhciBqb2luZWRFbnRyaWVzID0gaW5kZW50ID8gaW5kZW50ZWRKb2luKGVudHJpZXMsIGluZGVudCkgOiBlbnRyaWVzLmpvaW4oJywgJyk7XG5cdCAgICByZXR1cm4gdHlwZSArICcgKCcgKyBzaXplICsgJykgeycgKyBqb2luZWRFbnRyaWVzICsgJ30nO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2luZ2xlTGluZVZhbHVlcyh4cykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChpbmRleE9mKHhzW2ldLCAnXFxuJykgPj0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJbmRlbnQob3B0cywgZGVwdGgpIHtcblx0ICAgIHZhciBiYXNlSW5kZW50O1xuXHQgICAgaWYgKG9wdHMuaW5kZW50ID09PSAnXFx0Jykge1xuXHQgICAgICAgIGJhc2VJbmRlbnQgPSAnXFx0Jztcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuaW5kZW50ID09PSAnbnVtYmVyJyAmJiBvcHRzLmluZGVudCA+IDApIHtcblx0ICAgICAgICBiYXNlSW5kZW50ID0gQXJyYXkob3B0cy5pbmRlbnQgKyAxKS5qb2luKCcgJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBiYXNlOiBiYXNlSW5kZW50LFxuXHQgICAgICAgIHByZXY6IEFycmF5KGRlcHRoICsgMSkuam9pbihiYXNlSW5kZW50KVxuXHQgICAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluZGVudGVkSm9pbih4cywgaW5kZW50KSB7XG5cdCAgICBpZiAoeHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuXHQgICAgdmFyIGxpbmVKb2luZXIgPSAnXFxuJyArIGluZGVudC5wcmV2ICsgaW5kZW50LmJhc2U7XG5cdCAgICByZXR1cm4gbGluZUpvaW5lciArIHhzLmpvaW4oJywnICsgbGluZUpvaW5lcikgKyAnXFxuJyArIGluZGVudC5wcmV2O1xuXHR9XG5cblx0ZnVuY3Rpb24gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpIHtcblx0ICAgIHZhciBpc0FyciA9IGlzQXJyYXkkNChvYmopO1xuXHQgICAgdmFyIHhzID0gW107XG5cdCAgICBpZiAoaXNBcnIpIHtcblx0ICAgICAgICB4cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHhzW2ldID0gaGFzJDMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIHN5bXMgPSB0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJyA/IGdPUFMob2JqKSA6IFtdO1xuXHQgICAgdmFyIHN5bU1hcDtcblx0ICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xuXHQgICAgICAgIHN5bU1hcCA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3ltcy5sZW5ndGg7IGsrKykge1xuXHQgICAgICAgICAgICBzeW1NYXBbJyQnICsgc3ltc1trXV0gPSBzeW1zW2tdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdCAgICAgICAgaWYgKCFoYXMkMyhvYmosIGtleSkpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcblx0ICAgICAgICBpZiAoaXNBcnIgJiYgU3RyaW5nKE51bWJlcihrZXkpKSA9PT0ga2V5ICYmIGtleSA8IG9iai5sZW5ndGgpIHsgY29udGludWU7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcblx0ICAgICAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMgJiYgc3ltTWFwWyckJyArIGtleV0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcblx0ICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBwcmV2ZW50IHNoYW1tZWQgU3ltYm9scywgd2hpY2ggYXJlIHN0b3JlZCBhcyBzdHJpbmdzLCBmcm9tIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBzdHJpbmcga2V5IHNlY3Rpb25cblx0ICAgICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG5cdCAgICAgICAgfSBlbHNlIGlmICgoL1teXFx3JF0vKS50ZXN0KGtleSkpIHtcblx0ICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSwgb2JqKSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB4cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIGdPUFMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN5bXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgaWYgKGlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltc1tqXSkpIHtcblx0ICAgICAgICAgICAgICAgIHhzLnB1c2goJ1snICsgaW5zcGVjdChzeW1zW2pdKSArICddOiAnICsgaW5zcGVjdChvYmpbc3ltc1tqXV0sIG9iaikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHhzO1xuXHR9XG5cblx0dmFyIEdldEludHJpbnNpYyA9IGdldEludHJpbnNpYztcblx0dmFyIGNhbGxCb3VuZCA9IGNhbGxCb3VuZCQxO1xuXHR2YXIgaW5zcGVjdCA9IG9iamVjdEluc3BlY3Q7XG5cblx0dmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XG5cdHZhciAkV2Vha01hcCA9IEdldEludHJpbnNpYygnJVdlYWtNYXAlJywgdHJ1ZSk7XG5cdHZhciAkTWFwID0gR2V0SW50cmluc2ljKCclTWFwJScsIHRydWUpO1xuXG5cdHZhciAkd2Vha01hcEdldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuZ2V0JywgdHJ1ZSk7XG5cdHZhciAkd2Vha01hcFNldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XG5cdHZhciAkd2Vha01hcEhhcyA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG5cdHZhciAkbWFwR2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xuXHR2YXIgJG1hcFNldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcblx0dmFyICRtYXBIYXMgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuaGFzJywgdHJ1ZSk7XG5cblx0Lypcblx0ICogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGxpc3QgcmV0dXJuaW5nIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG5cdCAqIGdpdmVuIGtleS5cblx0ICpcblx0ICogVGhhdCBub2RlIGlzIGFsc28gbW92ZWQgdG8gdGhlIGhlYWQgb2YgdGhlIGxpc3QsIHNvIHRoYXQgaWYgaXQncyBhY2Nlc3NlZFxuXHQgKiBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseVxuXHQgKiB1c2VkIG5vZGVzIGNhbiBiZSBhY2Nlc3NlZCByZWxhdGl2ZWx5IHF1aWNrbHkuXG5cdCAqL1xuXHR2YXIgbGlzdEdldE5vZGUgPSBmdW5jdGlvbiAobGlzdCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0XHRmb3IgKHZhciBwcmV2ID0gbGlzdCwgY3VycjsgKGN1cnIgPSBwcmV2Lm5leHQpICE9PSBudWxsOyBwcmV2ID0gY3Vycikge1xuXHRcdFx0aWYgKGN1cnIua2V5ID09PSBrZXkpIHtcblx0XHRcdFx0cHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuXHRcdFx0XHRjdXJyLm5leHQgPSBsaXN0Lm5leHQ7XG5cdFx0XHRcdGxpc3QubmV4dCA9IGN1cnI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0XHRcdFx0cmV0dXJuIGN1cnI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBsaXN0R2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHRcdHZhciBub2RlID0gbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcblx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlO1xuXHR9O1xuXHR2YXIgbGlzdFNldCA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXksIHZhbHVlKSB7XG5cdFx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRcdGlmIChub2RlKSB7XG5cdFx0XHRub2RlLnZhbHVlID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFByZXBlbmQgdGhlIG5ldyBub2RlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3Rcblx0XHRcdG9iamVjdHMubmV4dCA9IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0XHRrZXk6IGtleSxcblx0XHRcdFx0bmV4dDogb2JqZWN0cy5uZXh0LFxuXHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXHR2YXIgbGlzdEhhcyA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0XHRyZXR1cm4gISFsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHR9O1xuXG5cdHZhciBzaWRlQ2hhbm5lbCA9IGZ1bmN0aW9uIGdldFNpZGVDaGFubmVsKCkge1xuXHRcdHZhciAkd207XG5cdFx0dmFyICRtO1xuXHRcdHZhciAkbztcblx0XHR2YXIgY2hhbm5lbCA9IHtcblx0XHRcdGFzc2VydDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAoIWNoYW5uZWwuaGFzKGtleSkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignU2lkZSBjaGFubmVsIGRvZXMgbm90IGNvbnRhaW4gJyArIGluc3BlY3Qoa2V5KSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIChrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRcdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRcdGlmICgkd20pIHtcblx0XHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEdldCgkd20sIGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRcdHJldHVybiAkbWFwR2V0KCRtLCBrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRcdHJldHVybiBsaXN0R2V0KCRvLCBrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRcdGlmICgkd20pIHtcblx0XHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEhhcygkd20sIGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCRNYXApIHtcblx0XHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRcdHJldHVybiAkbWFwSGFzKCRtLCBrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoJG8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lbHktaWZcblx0XHRcdFx0XHRcdHJldHVybiBsaXN0SGFzKCRvLCBrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRcdGlmICghJHdtKSB7XG5cdFx0XHRcdFx0XHQkd20gPSBuZXcgJFdlYWtNYXAoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JHdlYWtNYXBTZXQoJHdtLCBrZXksIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIGlmICgkTWFwKSB7XG5cdFx0XHRcdFx0aWYgKCEkbSkge1xuXHRcdFx0XHRcdFx0JG0gPSBuZXcgJE1hcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkbWFwU2V0KCRtLCBrZXksIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoISRvKSB7XG5cdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0ICogSW5pdGlhbGl6ZSB0aGUgbGlua2VkIGxpc3QgYXMgYW4gZW1wdHkgbm9kZSwgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG5cdFx0XHRcdFx0XHQgKiB0byBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2YgdGhlIGZpcnN0IG5vZGU6IHdlIGNhbiBhbHdheXMgcmVmZXIgdG9cblx0XHRcdFx0XHRcdCAqIGl0IGFzIChwcmV2aW91cyBub2RlKS5uZXh0LCBpbnN0ZWFkIG9mIHNvbWV0aGluZyBsaWtlIChsaXN0KS5oZWFkXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdCRvID0geyBrZXk6IHt9LCBuZXh0OiBudWxsIH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxpc3RTZXQoJG8sIGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gY2hhbm5lbDtcblx0fTtcblxuXHR2YXIgcmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblx0dmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxuXHR2YXIgRm9ybWF0ID0ge1xuXHQgICAgUkZDMTczODogJ1JGQzE3MzgnLFxuXHQgICAgUkZDMzk4NjogJ1JGQzM5ODYnXG5cdH07XG5cblx0dmFyIGZvcm1hdHMkMyA9IHtcblx0ICAgICdkZWZhdWx0JzogRm9ybWF0LlJGQzM5ODYsXG5cdCAgICBmb3JtYXR0ZXJzOiB7XG5cdCAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9LFxuXHQgICAgUkZDMTczODogRm9ybWF0LlJGQzE3MzgsXG5cdCAgICBSRkMzOTg2OiBGb3JtYXQuUkZDMzk4NlxuXHR9O1xuXG5cdHZhciBmb3JtYXRzJDIgPSBmb3JtYXRzJDM7XG5cblx0dmFyIGhhcyQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIGlzQXJyYXkkMyA9IEFycmF5LmlzQXJyYXk7XG5cblx0dmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBhcnJheSA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuXHQgICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhcnJheTtcblx0fSgpKTtcblxuXHR2YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG5cdCAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMSkge1xuXHQgICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG5cdCAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cblx0ICAgICAgICBpZiAoaXNBcnJheSQzKG9iaikpIHtcblx0ICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH07XG5cblx0dmFyIGFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KHNvdXJjZSwgb3B0aW9ucykge1xuXHQgICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqO1xuXHR9O1xuXG5cdHZhciBtZXJnZSQxID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0ICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuXHQgICAgaWYgKCFzb3VyY2UpIHtcblx0ICAgICAgICByZXR1cm4gdGFyZ2V0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICBpZiAoaXNBcnJheSQzKHRhcmdldCkpIHtcblx0ICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICBpZiAoKG9wdGlvbnMgJiYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSkgfHwgIWhhcyQyLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc291cmNlKSkge1xuXHQgICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHRhcmdldDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcblx0ICAgIGlmIChpc0FycmF5JDModGFyZ2V0KSAmJiAhaXNBcnJheSQzKHNvdXJjZSkpIHtcblx0ICAgICAgICBtZXJnZVRhcmdldCA9IGFycmF5VG9PYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzQXJyYXkkMyh0YXJnZXQpICYmIGlzQXJyYXkkMyhzb3VyY2UpKSB7XG5cdCAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcblx0ICAgICAgICAgICAgaWYgKGhhcyQyLmNhbGwodGFyZ2V0LCBpKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SXRlbSAmJiB0eXBlb2YgdGFyZ2V0SXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBtZXJnZSh0YXJnZXRJdGVtLCBpdGVtLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRhcmdldDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG5cdCAgICAgICAgaWYgKGhhcyQyLmNhbGwoYWNjLCBrZXkpKSB7XG5cdCAgICAgICAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWNjO1xuXHQgICAgfSwgbWVyZ2VUYXJnZXQpO1xuXHR9O1xuXG5cdHZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcblx0ICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcblx0ICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuXHQgICAgICAgIHJldHVybiBhY2M7XG5cdCAgICB9LCB0YXJnZXQpO1xuXHR9O1xuXG5cdHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3RyLCBkZWNvZGVyLCBjaGFyc2V0KSB7XG5cdCAgICB2YXIgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFwrL2csICcgJyk7XG5cdCAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG5cdCAgICAgICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XG5cdCAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzLnJlcGxhY2UoLyVbMC05YS1mXXsyfS9naSwgdW5lc2NhcGUpO1xuXHQgICAgfVxuXHQgICAgLy8gdXRmLThcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHJXaXRob3V0UGx1cyk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRQbHVzO1xuXHQgICAgfVxuXHR9O1xuXG5cdHZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XG5cdCAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cblx0ICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG5cdCAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiBzdHI7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzdHJpbmcgPSBzdHI7XG5cdCAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N5bWJvbCcpIHtcblx0ICAgICAgICBzdHJpbmcgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RyKTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICBzdHJpbmcgPSBTdHJpbmcoc3RyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuXHQgICAgICAgIHJldHVybiBlc2NhcGUoc3RyaW5nKS5yZXBsYWNlKC8ldVswLTlhLWZdezR9L2dpLCBmdW5jdGlvbiAoJDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuICclMjYlMjMnICsgcGFyc2VJbnQoJDAuc2xpY2UoMiksIDE2KSArICclM0InO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgb3V0ID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cblx0ICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuXHQgICAgICAgICAgICB8fCBjID09PSAweDJFIC8vIC5cblx0ICAgICAgICAgICAgfHwgYyA9PT0gMHg1RiAvLyBfXG5cdCAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuXHQgICAgICAgICAgICB8fCAoYyA+PSAweDMwICYmIGMgPD0gMHgzOSkgLy8gMC05XG5cdCAgICAgICAgICAgIHx8IChjID49IDB4NDEgJiYgYyA8PSAweDVBKSAvLyBhLXpcblx0ICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuXHQgICAgICAgICAgICB8fCAoZm9ybWF0ID09PSBmb3JtYXRzJDIuUkZDMTczOCAmJiAoYyA9PT0gMHgyOCB8fCBjID09PSAweDI5KSkgLy8gKCApXG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIG91dCArPSBzdHJpbmcuY2hhckF0KGkpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoYyA8IDB4ODApIHtcblx0ICAgICAgICAgICAgb3V0ID0gb3V0ICsgaGV4VGFibGVbY107XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjIDwgMHg4MDApIHtcblx0ICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuXHQgICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhFMCB8IChjID4+IDEyKV0gKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaSArPSAxO1xuXHQgICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuXHQgICAgICAgIC8qIGVzbGludCBvcGVyYXRvci1saW5lYnJlYWs6IFsyLCBcImJlZm9yZVwiXSAqL1xuXHQgICAgICAgIG91dCArPSBoZXhUYWJsZVsweEYwIHwgKGMgPj4gMTgpXVxuXHQgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG5cdCAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuXHQgICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG91dDtcblx0fTtcblxuXHR2YXIgY29tcGFjdCA9IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWUpIHtcblx0ICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG5cdCAgICB2YXIgcmVmcyA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcblx0ICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuXHQgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbal07XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goeyBvYmo6IG9iaiwgcHJvcDoga2V5IH0pO1xuXHQgICAgICAgICAgICAgICAgcmVmcy5wdXNoKHZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHR2YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcblx0ICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cdH07XG5cblx0dmFyIGlzQnVmZmVyJDEgPSBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcblx0ICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG5cdH07XG5cblx0dmFyIGNvbWJpbmUgPSBmdW5jdGlvbiBjb21iaW5lKGEsIGIpIHtcblx0ICAgIHJldHVybiBbXS5jb25jYXQoYSwgYik7XG5cdH07XG5cblx0dmFyIG1heWJlTWFwID0gZnVuY3Rpb24gbWF5YmVNYXAodmFsLCBmbikge1xuXHQgICAgaWYgKGlzQXJyYXkkMyh2YWwpKSB7XG5cdCAgICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbWFwcGVkO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZuKHZhbCk7XG5cdH07XG5cblx0dmFyIHV0aWxzJDMgPSB7XG5cdCAgICBhcnJheVRvT2JqZWN0OiBhcnJheVRvT2JqZWN0LFxuXHQgICAgYXNzaWduOiBhc3NpZ24sXG5cdCAgICBjb21iaW5lOiBjb21iaW5lLFxuXHQgICAgY29tcGFjdDogY29tcGFjdCxcblx0ICAgIGRlY29kZTogZGVjb2RlLFxuXHQgICAgZW5jb2RlOiBlbmNvZGUsXG5cdCAgICBpc0J1ZmZlcjogaXNCdWZmZXIkMSxcblx0ICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcblx0ICAgIG1heWJlTWFwOiBtYXliZU1hcCxcblx0ICAgIG1lcmdlOiBtZXJnZSQxXG5cdH07XG5cblx0dmFyIGdldFNpZGVDaGFubmVsID0gc2lkZUNoYW5uZWw7XG5cdHZhciB1dGlscyQyID0gdXRpbHMkMztcblx0dmFyIGZvcm1hdHMkMSA9IGZvcm1hdHMkMztcblx0dmFyIGhhcyQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHR2YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuXHQgICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkge1xuXHQgICAgICAgIHJldHVybiBwcmVmaXggKyAnW10nO1xuXHQgICAgfSxcblx0ICAgIGNvbW1hOiAnY29tbWEnLFxuXHQgICAgaW5kaWNlczogZnVuY3Rpb24gaW5kaWNlcyhwcmVmaXgsIGtleSkge1xuXHQgICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG5cdCAgICB9LFxuXHQgICAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQocHJlZml4KSB7XG5cdCAgICAgICAgcmV0dXJuIHByZWZpeDtcblx0ICAgIH1cblx0fTtcblxuXHR2YXIgaXNBcnJheSQyID0gQXJyYXkuaXNBcnJheTtcblx0dmFyIHNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdDtcblx0dmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcblx0dmFyIHB1c2hUb0FycmF5ID0gZnVuY3Rpb24gKGFyciwgdmFsdWVPckFycmF5KSB7XG5cdCAgICBwdXNoLmFwcGx5KGFyciwgaXNBcnJheSQyKHZhbHVlT3JBcnJheSkgPyB2YWx1ZU9yQXJyYXkgOiBbdmFsdWVPckFycmF5XSk7XG5cdH07XG5cblx0dmFyIHRvSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cblx0dmFyIGRlZmF1bHRGb3JtYXQgPSBmb3JtYXRzJDFbJ2RlZmF1bHQnXTtcblx0dmFyIGRlZmF1bHRzJDEgPSB7XG5cdCAgICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXG5cdCAgICBhbGxvd0RvdHM6IGZhbHNlLFxuXHQgICAgY2hhcnNldDogJ3V0Zi04Jyxcblx0ICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG5cdCAgICBkZWxpbWl0ZXI6ICcmJyxcblx0ICAgIGVuY29kZTogdHJ1ZSxcblx0ICAgIGVuY29kZXI6IHV0aWxzJDIuZW5jb2RlLFxuXHQgICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG5cdCAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG5cdCAgICBmb3JtYXR0ZXI6IGZvcm1hdHMkMS5mb3JtYXR0ZXJzW2RlZmF1bHRGb3JtYXRdLFxuXHQgICAgLy8gZGVwcmVjYXRlZFxuXHQgICAgaW5kaWNlczogZmFsc2UsXG5cdCAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHtcblx0ICAgICAgICByZXR1cm4gdG9JU08uY2FsbChkYXRlKTtcblx0ICAgIH0sXG5cdCAgICBza2lwTnVsbHM6IGZhbHNlLFxuXHQgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxuXHR9O1xuXG5cdHZhciBpc05vbk51bGxpc2hQcmltaXRpdmUgPSBmdW5jdGlvbiBpc05vbk51bGxpc2hQcmltaXRpdmUodikge1xuXHQgICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xuXHQgICAgICAgIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJ1xuXHQgICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYm9vbGVhbidcblx0ICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ3N5bWJvbCdcblx0ICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCc7XG5cdH07XG5cblx0dmFyIHNlbnRpbmVsID0ge307XG5cblx0dmFyIHN0cmluZ2lmeSQxID0gZnVuY3Rpb24gc3RyaW5naWZ5KFxuXHQgICAgb2JqZWN0LFxuXHQgICAgcHJlZml4LFxuXHQgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcblx0ICAgIHN0cmljdE51bGxIYW5kbGluZyxcblx0ICAgIHNraXBOdWxscyxcblx0ICAgIGVuY29kZXIsXG5cdCAgICBmaWx0ZXIsXG5cdCAgICBzb3J0LFxuXHQgICAgYWxsb3dEb3RzLFxuXHQgICAgc2VyaWFsaXplRGF0ZSxcblx0ICAgIGZvcm1hdCxcblx0ICAgIGZvcm1hdHRlcixcblx0ICAgIGVuY29kZVZhbHVlc09ubHksXG5cdCAgICBjaGFyc2V0LFxuXHQgICAgc2lkZUNoYW5uZWxcblx0KSB7XG5cdCAgICB2YXIgb2JqID0gb2JqZWN0O1xuXG5cdCAgICB2YXIgdG1wU2MgPSBzaWRlQ2hhbm5lbDtcblx0ICAgIHZhciBzdGVwID0gMDtcblx0ICAgIHZhciBmaW5kRmxhZyA9IGZhbHNlO1xuXHQgICAgd2hpbGUgKCh0bXBTYyA9IHRtcFNjLmdldChzZW50aW5lbCkpICE9PSB2b2lkIHVuZGVmaW5lZCAmJiAhZmluZEZsYWcpIHtcblx0ICAgICAgICAvLyBXaGVyZSBvYmplY3QgbGFzdCBhcHBlYXJlZCBpbiB0aGUgcmVmIHRyZWVcblx0ICAgICAgICB2YXIgcG9zID0gdG1wU2MuZ2V0KG9iamVjdCk7XG5cdCAgICAgICAgc3RlcCArPSAxO1xuXHQgICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgICAgICBpZiAocG9zID09PSBzdGVwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ3ljbGljIG9iamVjdCB2YWx1ZScpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZmluZEZsYWcgPSB0cnVlOyAvLyBCcmVhayB3aGlsZVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgdG1wU2MuZ2V0KHNlbnRpbmVsKSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgICAgc3RlcCA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XG5cdCAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcblx0ICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG5cdCAgICB9IGVsc2UgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNBcnJheSQyKG9iaikpIHtcblx0ICAgICAgICBvYmogPSB1dGlscyQyLm1heWJlTWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVEYXRlKHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvYmogPT09IG51bGwpIHtcblx0ICAgICAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzJDEuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCkgOiBwcmVmaXg7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgb2JqID0gJyc7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpc05vbk51bGxpc2hQcmltaXRpdmUob2JqKSB8fCB1dGlscyQyLmlzQnVmZmVyKG9iaikpIHtcblx0ICAgICAgICBpZiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzJDEuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCk7XG5cdCAgICAgICAgICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGVuY29kZVZhbHVlc09ubHkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNBcnJheSA9IHNwbGl0LmNhbGwoU3RyaW5nKG9iaiksICcsJyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVzSm9pbmVkID0gJyc7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlc0FycmF5Lmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWVzSm9pbmVkICs9IChpID09PSAwID8gJycgOiAnLCcpICsgZm9ybWF0dGVyKGVuY29kZXIodmFsdWVzQXJyYXlbaV0sIGRlZmF1bHRzJDEuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyB2YWx1ZXNKb2luZWRdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMkMS5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG5cdCAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWVzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgb2JqS2V5cztcblx0ICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkkMihvYmopKSB7XG5cdCAgICAgICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXG5cdCAgICAgICAgb2JqS2V5cyA9IFt7IHZhbHVlOiBvYmoubGVuZ3RoID4gMCA/IG9iai5qb2luKCcsJykgfHwgbnVsbCA6IHZvaWQgdW5kZWZpbmVkIH1dO1xuXHQgICAgfSBlbHNlIGlmIChpc0FycmF5JDIoZmlsdGVyKSkge1xuXHQgICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0ICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqS2V5cy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2pdO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkudmFsdWUgIT09ICd1bmRlZmluZWQnID8ga2V5LnZhbHVlIDogb2JqW2tleV07XG5cblx0ICAgICAgICBpZiAoc2tpcE51bGxzICYmIHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBrZXlQcmVmaXggPSBpc0FycmF5JDIob2JqKVxuXHQgICAgICAgICAgICA/IHR5cGVvZiBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnZnVuY3Rpb24nID8gZ2VuZXJhdGVBcnJheVByZWZpeChwcmVmaXgsIGtleSkgOiBwcmVmaXhcblx0ICAgICAgICAgICAgOiBwcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKTtcblxuXHQgICAgICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xuXHQgICAgICAgIHZhciB2YWx1ZVNpZGVDaGFubmVsID0gZ2V0U2lkZUNoYW5uZWwoKTtcblx0ICAgICAgICB2YWx1ZVNpZGVDaGFubmVsLnNldChzZW50aW5lbCwgc2lkZUNoYW5uZWwpO1xuXHQgICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxuXHQgICAgICAgICAgICB2YWx1ZSxcblx0ICAgICAgICAgICAga2V5UHJlZml4LFxuXHQgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuXHQgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG5cdCAgICAgICAgICAgIHNraXBOdWxscyxcblx0ICAgICAgICAgICAgZW5jb2Rlcixcblx0ICAgICAgICAgICAgZmlsdGVyLFxuXHQgICAgICAgICAgICBzb3J0LFxuXHQgICAgICAgICAgICBhbGxvd0RvdHMsXG5cdCAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG5cdCAgICAgICAgICAgIGZvcm1hdCxcblx0ICAgICAgICAgICAgZm9ybWF0dGVyLFxuXHQgICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuXHQgICAgICAgICAgICBjaGFyc2V0LFxuXHQgICAgICAgICAgICB2YWx1ZVNpZGVDaGFubmVsXG5cdCAgICAgICAgKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZXM7XG5cdH07XG5cblx0dmFyIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpIHtcblx0ICAgIGlmICghb3B0cykge1xuXHQgICAgICAgIHJldHVybiBkZWZhdWx0cyQxO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0cy5lbmNvZGVyICE9PSBudWxsICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2hhcnNldCA9IG9wdHMuY2hhcnNldCB8fCBkZWZhdWx0cyQxLmNoYXJzZXQ7XG5cdCAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGZvcm1hdCA9IGZvcm1hdHMkMVsnZGVmYXVsdCddO1xuXHQgICAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBpZiAoIWhhcyQxLmNhbGwoZm9ybWF0cyQxLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0KSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvcm1hdCA9IG9wdHMuZm9ybWF0O1xuXHQgICAgfVxuXHQgICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMkMS5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cblx0ICAgIHZhciBmaWx0ZXIgPSBkZWZhdWx0cyQxLmZpbHRlcjtcblx0ICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgaXNBcnJheSQyKG9wdHMuZmlsdGVyKSkge1xuXHQgICAgICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGFkZFF1ZXJ5UHJlZml4OiB0eXBlb2Ygb3B0cy5hZGRRdWVyeVByZWZpeCA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hZGRRdWVyeVByZWZpeCA6IGRlZmF1bHRzJDEuYWRkUXVlcnlQcmVmaXgsXG5cdCAgICAgICAgYWxsb3dEb3RzOiB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMkMS5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzLFxuXHQgICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG5cdCAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMkMS5jaGFyc2V0U2VudGluZWwsXG5cdCAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMkMS5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcblx0ICAgICAgICBlbmNvZGU6IHR5cGVvZiBvcHRzLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGUgOiBkZWZhdWx0cyQxLmVuY29kZSxcblx0ICAgICAgICBlbmNvZGVyOiB0eXBlb2Ygb3B0cy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5lbmNvZGVyIDogZGVmYXVsdHMkMS5lbmNvZGVyLFxuXHQgICAgICAgIGVuY29kZVZhbHVlc09ubHk6IHR5cGVvZiBvcHRzLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzJDEuZW5jb2RlVmFsdWVzT25seSxcblx0ICAgICAgICBmaWx0ZXI6IGZpbHRlcixcblx0ICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcblx0ICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcblx0ICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMkMS5zZXJpYWxpemVEYXRlLFxuXHQgICAgICAgIHNraXBOdWxsczogdHlwZW9mIG9wdHMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRzLnNraXBOdWxscyA6IGRlZmF1bHRzJDEuc2tpcE51bGxzLFxuXHQgICAgICAgIHNvcnQ6IHR5cGVvZiBvcHRzLnNvcnQgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNvcnQgOiBudWxsLFxuXHQgICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzJDEuc3RyaWN0TnVsbEhhbmRsaW5nXG5cdCAgICB9O1xuXHR9O1xuXG5cdHZhciBzdHJpbmdpZnlfMSA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdHMpIHtcblx0ICAgIHZhciBvYmogPSBvYmplY3Q7XG5cdCAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMob3B0cyk7XG5cblx0ICAgIHZhciBvYmpLZXlzO1xuXHQgICAgdmFyIGZpbHRlcjtcblxuXHQgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXHQgICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcblx0ICAgIH0gZWxzZSBpZiAoaXNBcnJheSQyKG9wdGlvbnMuZmlsdGVyKSkge1xuXHQgICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXHQgICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG5cdCAgICB9XG5cblx0ICAgIHZhciBrZXlzID0gW107XG5cblx0ICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gJyc7XG5cdCAgICB9XG5cblx0ICAgIHZhciBhcnJheUZvcm1hdDtcblx0ICAgIGlmIChvcHRzICYmIG9wdHMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG5cdCAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xuXHQgICAgfSBlbHNlIGlmIChvcHRzICYmICdpbmRpY2VzJyBpbiBvcHRzKSB7XG5cdCAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0Jztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYXJyYXlGb3JtYXQgPSAnaW5kaWNlcyc7XG5cdCAgICB9XG5cblx0ICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcblxuXHQgICAgaWYgKCFvYmpLZXlzKSB7XG5cdCAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvcHRpb25zLnNvcnQpIHtcblx0ICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHNpZGVDaGFubmVsID0gZ2V0U2lkZUNoYW5uZWwoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwdXNoVG9BcnJheShrZXlzLCBzdHJpbmdpZnkkMShcblx0ICAgICAgICAgICAgb2JqW2tleV0sXG5cdCAgICAgICAgICAgIGtleSxcblx0ICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcblx0ICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXG5cdCAgICAgICAgICAgIG9wdGlvbnMuc2tpcE51bGxzLFxuXHQgICAgICAgICAgICBvcHRpb25zLmVuY29kZSA/IG9wdGlvbnMuZW5jb2RlciA6IG51bGwsXG5cdCAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuXHQgICAgICAgICAgICBvcHRpb25zLnNvcnQsXG5cdCAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dEb3RzLFxuXHQgICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG5cdCAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0LFxuXHQgICAgICAgICAgICBvcHRpb25zLmZvcm1hdHRlcixcblx0ICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuXHQgICAgICAgICAgICBvcHRpb25zLmNoYXJzZXQsXG5cdCAgICAgICAgICAgIHNpZGVDaGFubmVsXG5cdCAgICAgICAgKSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuXHQgICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuXHQgICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG5cdCAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuXHQgICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0ImJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG5cdCAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lRTIlOUMlOTMmJztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xuXHR9O1xuXG5cdHZhciB1dGlscyQxID0gdXRpbHMkMztcblxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXk7XG5cblx0dmFyIGRlZmF1bHRzID0ge1xuXHQgICAgYWxsb3dEb3RzOiBmYWxzZSxcblx0ICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG5cdCAgICBhbGxvd1NwYXJzZTogZmFsc2UsXG5cdCAgICBhcnJheUxpbWl0OiAyMCxcblx0ICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG5cdCAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuXHQgICAgY29tbWE6IGZhbHNlLFxuXHQgICAgZGVjb2RlcjogdXRpbHMkMS5kZWNvZGUsXG5cdCAgICBkZWxpbWl0ZXI6ICcmJyxcblx0ICAgIGRlcHRoOiA1LFxuXHQgICAgaWdub3JlUXVlcnlQcmVmaXg6IGZhbHNlLFxuXHQgICAgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzOiBmYWxzZSxcblx0ICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuXHQgICAgcGFyc2VBcnJheXM6IHRydWUsXG5cdCAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuXHQgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxuXHR9O1xuXG5cdHZhciBpbnRlcnByZXROdW1lcmljRW50aXRpZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjKFxcZCspOy9nLCBmdW5jdGlvbiAoJDAsIG51bWJlclN0cikge1xuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG51bWJlclN0ciwgMTApKTtcblx0ICAgIH0pO1xuXHR9O1xuXG5cdHZhciBwYXJzZUFycmF5VmFsdWUgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG5cdCAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuY29tbWEgJiYgdmFsLmluZGV4T2YoJywnKSA+IC0xKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbC5zcGxpdCgnLCcpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsO1xuXHR9O1xuXG5cdC8vIFRoaXMgaXMgd2hhdCBicm93c2VycyB3aWxsIHN1Ym1pdCB3aGVuIHRoZSDinJMgY2hhcmFjdGVyIG9jY3VycyBpbiBhblxuXHQvLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgYm9keSBhbmQgdGhlIGVuY29kaW5nIG9mIHRoZSBwYWdlIGNvbnRhaW5pbmdcblx0Ly8gdGhlIGZvcm0gaXMgaXNvLTg4NTktMSwgb3Igd2hlbiB0aGUgc3VibWl0dGVkIGZvcm0gaGFzIGFuIGFjY2VwdC1jaGFyc2V0XG5cdC8vIGF0dHJpYnV0ZSBvZiBpc28tODg1OS0xLiBQcmVzdW1hYmx5IGFsc28gd2l0aCBvdGhlciBjaGFyc2V0cyB0aGF0IGRvIG5vdCBjb250YWluXG5cdC8vIHRoZSDinJMgY2hhcmFjdGVyLCBzdWNoIGFzIHVzLWFzY2lpLlxuXHR2YXIgaXNvU2VudGluZWwgPSAndXRmOD0lMjYlMjMxMDAwMyUzQic7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKVxuXG5cdC8vIFRoZXNlIGFyZSB0aGUgcGVyY2VudC1lbmNvZGVkIHV0Zi04IG9jdGV0cyByZXByZXNlbnRpbmcgYSBjaGVja21hcmssIGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCBhY3R1YWxseSBpcyB1dGYtOCBlbmNvZGVkLlxuXHR2YXIgY2hhcnNldFNlbnRpbmVsID0gJ3V0Zjg9JUUyJTlDJTkzJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuXG5cdHZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgb2JqID0ge307XG5cdCAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG5cdCAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG5cdCAgICB2YXIgcGFydHMgPSBjbGVhblN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgbGltaXQpO1xuXHQgICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuXHQgICAgdmFyIGk7XG5cblx0ICAgIHZhciBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0O1xuXHQgICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIGlmIChwYXJ0c1tpXS5pbmRleE9mKCd1dGY4PScpID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAndXRmLTgnO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXSA9PT0gaXNvU2VudGluZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc2tpcEluZGV4ID0gaTtcblx0ICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICBpZiAoaSA9PT0gc2tpcEluZGV4KSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG5cdCAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG5cdCAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuXHQgICAgICAgIHZhciBrZXksIHZhbDtcblx0ICAgICAgICBpZiAocG9zID09PSAtMSkge1xuXHQgICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xuXHQgICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZSgwLCBwb3MpLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG5cdCAgICAgICAgICAgIHZhbCA9IHV0aWxzJDEubWF5YmVNYXAoXG5cdCAgICAgICAgICAgICAgICBwYXJzZUFycmF5VmFsdWUocGFydC5zbGljZShwb3MgKyAxKSwgb3B0aW9ucyksXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZW5jb2RlZFZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHZhbCAmJiBvcHRpb25zLmludGVycHJldE51bWVyaWNFbnRpdGllcyAmJiBjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcblx0ICAgICAgICAgICAgdmFsID0gaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzKHZhbCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHBhcnQuaW5kZXhPZignW109JykgPiAtMSkge1xuXHQgICAgICAgICAgICB2YWwgPSBpc0FycmF5JDEodmFsKSA/IFt2YWxdIDogdmFsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcblx0ICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscyQxLmNvbWJpbmUob2JqW2tleV0sIHZhbCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqO1xuXHR9O1xuXG5cdHZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcblx0ICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XG5cblx0ICAgIGZvciAodmFyIGkgPSBjaGFpbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICAgIHZhciBvYmo7XG5cdCAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuXHQgICAgICAgIGlmIChyb290ID09PSAnW10nICYmIG9wdGlvbnMucGFyc2VBcnJheXMpIHtcblx0ICAgICAgICAgICAgb2JqID0gW10uY29uY2F0KGxlYWYpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXHQgICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuXHQgICAgICAgICAgICBpZiAoIW9wdGlvbnMucGFyc2VBcnJheXMgJiYgY2xlYW5Sb290ID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgb2JqID0geyAwOiBsZWFmIH07XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoXG5cdCAgICAgICAgICAgICAgICAhaXNOYU4oaW5kZXgpXG5cdCAgICAgICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3Rcblx0ICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuXHQgICAgICAgICAgICAgICAgJiYgaW5kZXggPj0gMFxuXHQgICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuXHQgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICAgIG9iaiA9IFtdO1xuXHQgICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xlYW5Sb290ICE9PSAnX19wcm90b19fJykge1xuXHQgICAgICAgICAgICAgICAgb2JqW2NsZWFuUm9vdF0gPSBsZWFmO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGVhZiA9IG9iajtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGxlYWY7XG5cdH07XG5cblx0dmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuXHQgICAgaWYgKCFnaXZlbktleSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXG5cdCAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cblx0ICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuXHQgICAgdmFyIGJyYWNrZXRzID0gLyhcXFtbXltcXF1dKl0pLztcblx0ICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG5cdCAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG5cdCAgICB2YXIgc2VnbWVudCA9IG9wdGlvbnMuZGVwdGggPiAwICYmIGJyYWNrZXRzLmV4ZWMoa2V5KTtcblx0ICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG5cdCAgICAvLyBTdGFzaCB0aGUgcGFyZW50IGlmIGl0IGV4aXN0c1xuXG5cdCAgICB2YXIga2V5cyA9IFtdO1xuXHQgICAgaWYgKHBhcmVudCkge1xuXHQgICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBwbGFpbiBvYmplY3RzLCBvcHRpb25hbGx5IHByZWZpeCBrZXlzIHRoYXQgd291bGQgb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuXHQgICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgcGFyZW50KSkge1xuXHQgICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcblx0ICAgIH1cblxuXHQgICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cblx0ICAgIHZhciBpID0gMDtcblx0ICAgIHdoaWxlIChvcHRpb25zLmRlcHRoID4gMCAmJiAoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcblx0ICAgICAgICBpICs9IDE7XG5cdCAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzZWdtZW50WzFdLnNsaWNlKDEsIC0xKSkpIHtcblx0ICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcblx0ICAgIH1cblxuXHQgICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG5cdCAgICBpZiAoc2VnbWVudCkge1xuXHQgICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpO1xuXHR9O1xuXG5cdHZhciBub3JtYWxpemVQYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cykge1xuXHQgICAgaWYgKCFvcHRzKSB7XG5cdCAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0cy5kZWNvZGVyICE9PSBudWxsICYmIG9wdHMuZGVjb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRzLmRlY29kZXIgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcblx0ICAgIH1cblx0ICAgIHZhciBjaGFyc2V0ID0gdHlwZW9mIG9wdHMuY2hhcnNldCA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5jaGFyc2V0IDogb3B0cy5jaGFyc2V0O1xuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG5cdCAgICAgICAgYWxsb3dQcm90b3R5cGVzOiB0eXBlb2Ygb3B0cy5hbGxvd1Byb3RvdHlwZXMgPT09ICdib29sZWFuJyA/IG9wdHMuYWxsb3dQcm90b3R5cGVzIDogZGVmYXVsdHMuYWxsb3dQcm90b3R5cGVzLFxuXHQgICAgICAgIGFsbG93U3BhcnNlOiB0eXBlb2Ygb3B0cy5hbGxvd1NwYXJzZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1NwYXJzZSA6IGRlZmF1bHRzLmFsbG93U3BhcnNlLFxuXHQgICAgICAgIGFycmF5TGltaXQ6IHR5cGVvZiBvcHRzLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0cy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdCxcblx0ICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxuXHQgICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcblx0ICAgICAgICBjb21tYTogdHlwZW9mIG9wdHMuY29tbWEgPT09ICdib29sZWFuJyA/IG9wdHMuY29tbWEgOiBkZWZhdWx0cy5jb21tYSxcblx0ICAgICAgICBkZWNvZGVyOiB0eXBlb2Ygb3B0cy5kZWNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5kZWNvZGVyIDogZGVmYXVsdHMuZGVjb2Rlcixcblx0ICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMkMS5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcblx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW1wbGljaXQtY29lcmNpb24sIG5vLWV4dHJhLXBhcmVuc1xuXHQgICAgICAgIGRlcHRoOiAodHlwZW9mIG9wdHMuZGVwdGggPT09ICdudW1iZXInIHx8IG9wdHMuZGVwdGggPT09IGZhbHNlKSA/ICtvcHRzLmRlcHRoIDogZGVmYXVsdHMuZGVwdGgsXG5cdCAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG5cdCAgICAgICAgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzOiB0eXBlb2Ygb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgPT09ICdib29sZWFuJyA/IG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzIDogZGVmYXVsdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzLFxuXHQgICAgICAgIHBhcmFtZXRlckxpbWl0OiB0eXBlb2Ygb3B0cy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLnBhcmFtZXRlckxpbWl0IDogZGVmYXVsdHMucGFyYW1ldGVyTGltaXQsXG5cdCAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuXHQgICAgICAgIHBsYWluT2JqZWN0czogdHlwZW9mIG9wdHMucGxhaW5PYmplY3RzID09PSAnYm9vbGVhbicgPyBvcHRzLnBsYWluT2JqZWN0cyA6IGRlZmF1bHRzLnBsYWluT2JqZWN0cyxcblx0ICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcblx0ICAgIH07XG5cdH07XG5cblx0dmFyIHBhcnNlJDEgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG5cdCAgICB2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKTtcblxuXHQgICAgaWYgKHN0ciA9PT0gJycgfHwgc3RyID09PSBudWxsIHx8IHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdGVtcE9iaiA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gcGFyc2VWYWx1ZXMoc3RyLCBvcHRpb25zKSA6IHN0cjtcblx0ICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuXHQgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG5cdCAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRlbXBPYmopO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICAgICAgdmFyIG5ld09iaiA9IHBhcnNlS2V5cyhrZXksIHRlbXBPYmpba2V5XSwgb3B0aW9ucywgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpO1xuXHQgICAgICAgIG9iaiA9IHV0aWxzJDEubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0aW9ucy5hbGxvd1NwYXJzZSA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIHJldHVybiBvYmo7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1dGlscyQxLmNvbXBhY3Qob2JqKTtcblx0fTtcblxuXHR2YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5XzE7XG5cdHZhciBwYXJzZSA9IHBhcnNlJDE7XG5cdHZhciBmb3JtYXRzID0gZm9ybWF0cyQzO1xuXG5cdHZhciBsaWIgPSB7XG5cdCAgICBmb3JtYXRzOiBmb3JtYXRzLFxuXHQgICAgcGFyc2U6IHBhcnNlLFxuXHQgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcblx0fTtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwkMSA9PSAnb2JqZWN0JyAmJiBnbG9iYWwkMSAmJiBnbG9iYWwkMS5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWwkMTtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXHR2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuXHQvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cblx0dmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBTeW1ib2wkMSA9IHJvb3QuU3ltYm9sO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvJGYgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkkYyA9IG9iamVjdFByb3RvJGYuaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcblx0ICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG5cdCAqIG9mIHZhbHVlcy5cblx0ICovXG5cdHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kZi50b1N0cmluZztcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHN5bVRvU3RyaW5nVGFnJDEgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcblx0ICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eSRjLmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLFxuXHQgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcblxuXHQgIHRyeSB7XG5cdCAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHVuZGVmaW5lZDtcblx0ICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG5cdCAgfSBjYXRjaCAoZSkge31cblxuXHQgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpO1xuXHQgIGlmICh1bm1hc2tlZCkge1xuXHQgICAgaWYgKGlzT3duKSB7XG5cdCAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdGFnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8kZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcblx0ICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG5cdCAqIG9mIHZhbHVlcy5cblx0ICovXG5cdHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvJGUudG9TdHJpbmc7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcblx0ICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdH1cblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuXHQgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCQxID8gU3ltYm9sJDEudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuXHQgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG5cdCAgfVxuXHQgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcblx0ICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuXHQgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG5cdCAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcblx0ICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3Qoe30pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdChudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0JDEodmFsdWUpIHtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuXHR9XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG5cdCAgICBmdW5jVGFnJDIgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuXHQgICAgZ2VuVGFnJDEgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuXHQgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNGdW5jdGlvbihfKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNGdW5jdGlvbiQxKHZhbHVlKSB7XG5cdCAgaWYgKCFpc09iamVjdCQxKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3Jcblx0ICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cblx0ICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG5cdCAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnJDIgfHwgdGFnID09IGdlblRhZyQxIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG5cdH1cblxuXHQvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG5cdHZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cblx0dmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcblx0ICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG5cdH0oKSk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcblx0ICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuXHR9XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuXHR2YXIgZnVuY1RvU3RyaW5nJDEgPSBmdW5jUHJvdG8kMS50b1N0cmluZztcblxuXHQvKipcblx0ICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG5cdCAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZyQxLmNhbGwoZnVuYyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cdCAgcmV0dXJuICcnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcblx0ICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG5cdCAqL1xuXHR2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cblx0dmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuXHQgICAgb2JqZWN0UHJvdG8kZCA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuXHR2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkkYiA9IG9iamVjdFByb3RvJGQuaGFzT3duUHJvcGVydHk7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cblx0dmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcblx0ICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSRiKS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG5cdCAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG5cdCk7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuXHQgKiAgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG5cdCAgaWYgKCFpc09iamVjdCQxKHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uJDEodmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3Rvcjtcblx0ICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcblx0ICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcblx0ICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG5cdCAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcblx0fVxuXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcblx0ICB0cnkge1xuXHQgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcblx0ICAgIGZ1bmMoe30sICcnLCB7fSk7XG5cdCAgICByZXR1cm4gZnVuYztcblx0ICB9IGNhdGNoIChlKSB7fVxuXHR9KCkpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuXHQgKiB2YWx1ZSBjaGVja3MuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuXHQgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcblx0ICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG5cdCAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcblx0ICAgICAgJ3ZhbHVlJzogdmFsdWUsXG5cdCAgICAgICd3cml0YWJsZSc6IHRydWVcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhXG5cdCAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuXHQgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcblx0ICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcblx0ICpcblx0ICogXy5lcShvYmplY3QsIG9iamVjdCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5lcShvYmplY3QsIG90aGVyKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5lcSgnYScsICdhJyk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5lcShOYU4sIE5hTik7XG5cdCAqIC8vID0+IHRydWVcblx0ICovXG5cdGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuXHR9XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8kYyA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSRhID0gb2JqZWN0UHJvdG8kYy5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuXHQgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuXHQgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcblx0ICBpZiAoIShoYXNPd25Qcm9wZXJ0eSRhLmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG5cdCAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG5cdCAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5pc0FycmF5KCdhYmMnKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5pc0FycmF5KF8ubm9vcCk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuXHQgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKlxuXHQgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcblx0fVxuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHN5bWJvbFRhZyQzID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNTeW1ib2woJ2FiYycpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG5cdCAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWckMyk7XG5cdH1cblxuXHQvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG5cdHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuXHQgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcblx0ICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuXHQgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcblx0ICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG5cdH1cblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cdHZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGNsZWFyXG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG5cdCAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuXHQgIHRoaXMuc2l6ZSA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGRlbGV0ZVxuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuXHQgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG5cdCAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG5cdHZhciBIQVNIX1VOREVGSU5FRCQyID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvJGIgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkkOSA9IG9iamVjdFByb3RvJGIuaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBnZXRcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXHQgIGlmIChuYXRpdmVDcmVhdGUpIHtcblx0ICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG5cdCAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCQyID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuXHQgIH1cblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkkOS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byRhID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDggPSBvYmplY3RQcm90byRhLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGhhc1xuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eSQ4LmNhbGwoZGF0YSwga2V5KTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblx0dmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcblx0ICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQkMSA6IHZhbHVlO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuXHQgIHRoaXMuY2xlYXIoKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgIH1cblx0fVxuXG5cdC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cblx0SGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5cdEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5cdEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5cdEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5cdEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGNsZWFyXG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuXHQgIHRoaXMuX19kYXRhX18gPSBbXTtcblx0ICB0aGlzLnNpemUgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG5cdCAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cblx0ICovXG5cdGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG5cdCAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0ICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG5cdCAgICAgIHJldHVybiBsZW5ndGg7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fVxuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGRlbGV0ZVxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuXHQgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcblx0ICAgIGRhdGEucG9wKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcblx0ICB9XG5cdCAgLS10aGlzLnNpemU7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGdldFxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgaGFzXG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcblx0ICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIHNldFxuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcblx0ICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgICsrdGhpcy5zaXplO1xuXHQgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cblx0ICovXG5cdGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuXHQgIHRoaXMuY2xlYXIoKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgIH1cblx0fVxuXG5cdC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuXHRMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5cdExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuXHRMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcblx0TGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5cdExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cblx0dmFyIE1hcCQxID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBjbGVhclxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG5cdCAgdGhpcy5zaXplID0gMDtcblx0ICB0aGlzLl9fZGF0YV9fID0ge1xuXHQgICAgJ2hhc2gnOiBuZXcgSGFzaCxcblx0ICAgICdtYXAnOiBuZXcgKE1hcCQxIHx8IExpc3RDYWNoZSksXG5cdCAgICAnc3RyaW5nJzogbmV3IEhhc2hcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcblx0ICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcblx0ICAgIDogKHZhbHVlID09PSBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG5cdCAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG5cdCAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG5cdCAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuXHQgICAgOiBkYXRhLm1hcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBkZWxldGVcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcblx0ICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuXHQgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGdldFxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuXHQgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGhhc1xuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuXHQgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIHNldFxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuXHQgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuXHQgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG5cdCAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuXHQgIHRoaXMuY2xlYXIoKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgIH1cblx0fVxuXG5cdC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5cdE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cdE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcblx0TWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuXHRNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5cdE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuXHQvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG5cdHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG5cdCAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcblx0ICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG5cdCAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG5cdCAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG5cdCAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuXHQgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuXHQgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuXHQgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcblx0ICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuXHQgKlxuXHQgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcblx0ICogdmFsdWVzKG9iamVjdCk7XG5cdCAqIC8vID0+IFsxLCAyXVxuXHQgKlxuXHQgKiB2YWx1ZXMob3RoZXIpO1xuXHQgKiAvLyA9PiBbMywgNF1cblx0ICpcblx0ICogb2JqZWN0LmEgPSAyO1xuXHQgKiB2YWx1ZXMob2JqZWN0KTtcblx0ICogLy8gPT4gWzEsIDJdXG5cdCAqXG5cdCAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuXHQgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG5cdCAqIHZhbHVlcyhvYmplY3QpO1xuXHQgKiAvLyA9PiBbJ2EnLCAnYiddXG5cdCAqXG5cdCAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG5cdCAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG5cdCAqL1xuXHRmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG5cdCAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG5cdCAgfVxuXHQgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdCAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG5cdCAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuXHQgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG5cdCAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHQgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcblx0ICByZXR1cm4gbWVtb2l6ZWQ7XG5cdH1cblxuXHQvLyBFeHBvc2UgYE1hcENhY2hlYC5cblx0bWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5cdC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cblx0dmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cblx0LyoqXG5cdCAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3Ncblx0ICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuXHQgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuXHQgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcblx0ICAgICAgY2FjaGUuY2xlYXIoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBrZXk7XG5cdCAgfSk7XG5cblx0ICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblx0dmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cblx0LyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG5cdHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuXHQvKipcblx0ICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuXHQgKi9cblx0dmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuXHQgICAgcmVzdWx0LnB1c2goJycpO1xuXHQgIH1cblx0ICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdCAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fSk7XG5cblx0LyoqXG5cdCAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuXHQgKiBzaG9ydGhhbmRzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cblx0ICovXG5cdGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBJTkZJTklUWSQzID0gMSAvIDA7XG5cblx0LyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG5cdHZhciBzeW1ib2xQcm90byQyID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvJDIgPyBzeW1ib2xQcm90byQyLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcblx0ICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuXHQgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cdCAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcblx0ICB9XG5cdCAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcblx0ICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZJDMpID8gJy0wJyA6IHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuXHQgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy50b1N0cmluZyhudWxsKTtcblx0ICogLy8gPT4gJydcblx0ICpcblx0ICogXy50b1N0cmluZygtMCk7XG5cdCAqIC8vID0+ICctMCdcblx0ICpcblx0ICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuXHQgKiAvLyA9PiAnMSwyLDMnXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG5cdCAqL1xuXHRmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG5cdCAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcblx0fVxuXG5cdC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXHR2YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG5cdHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSJDEgOiBsZW5ndGg7XG5cblx0ICByZXR1cm4gISFsZW5ndGggJiZcblx0ICAgICh0eXBlID09ICdudW1iZXInIHx8XG5cdCAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcblx0ICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG5cdH1cblxuXHQvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cblx0dmFyIElORklOSVRZJDIgPSAxIC8gMDtcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuXHQgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkkMikgPyAnLTAnIDogcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuXHQgIGlmICghaXNPYmplY3QkMShvYmplY3QpKSB7XG5cdCAgICByZXR1cm4gb2JqZWN0O1xuXHQgIH1cblx0ICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcblx0ICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcblx0ICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG5cdCAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG5cdCAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuXHQgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcblx0ICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuXHQgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcblx0ICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuXHQgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3QkMShvYmpWYWx1ZSlcblx0ICAgICAgICAgID8gb2JqVmFsdWVcblx0ICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuXHQgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG5cdCAgfVxuXHQgIHJldHVybiBvYmplY3Q7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG5cdCAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuXHQgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuXHQgKiBgcGF0aGAgY3JlYXRpb24uXG5cdCAqXG5cdCAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAzLjcuMFxuXHQgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcblx0ICpcblx0ICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcblx0ICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcblx0ICogLy8gPT4gNFxuXHQgKlxuXHQgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcblx0ICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcblx0ICogLy8gPT4gNVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcblx0ICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuXHQgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG5cdCAgdmFyIGluZGV4ID0gMCxcblx0ICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cblx0ICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG5cdCAgfVxuXHQgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuXHQgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMy43LjBcblx0ICogQGNhdGVnb3J5IE9iamVjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcblx0ICpcblx0ICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcblx0ICogLy8gPT4gM1xuXHQgKlxuXHQgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcblx0ICogLy8gPT4gM1xuXHQgKlxuXHQgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG5cdCAqIC8vID0+ICdkZWZhdWx0J1xuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXHQgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblx0dmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG5cdC8qKlxuXHQgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBhZGRcblx0ICogQG1lbWJlck9mIFNldENhY2hlXG5cdCAqIEBhbGlhcyBwdXNoXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG5cdCAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcblx0ICByZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGhhc1xuXHQgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcblx0ICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cblx0ICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcblx0ICB9XG5cdH1cblxuXHQvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuXHRTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblx0U2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG5cdCAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuXHQgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG5cdCAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cblx0ICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuXHQgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcblx0ICAgICAgcmV0dXJuIGluZGV4O1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gLTE7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG5cdCAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuXHQgKi9cblx0ZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuXHQgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG5cdCAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gaW5kZXg7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuXHQgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuXHQgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3Jcblx0ICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcblx0ICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cdCAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcblx0ICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG5cdH1cblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cdHZhciBTZXQkMSA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDIuMy4wXG5cdCAqIEBjYXRlZ29yeSBVdGlsXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udGltZXMoMiwgXy5ub29wKTtcblx0ICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuXHQgKi9cblx0ZnVuY3Rpb24gbm9vcCgpIHtcblx0ICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cblx0ICovXG5cdGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuXHQgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcblx0ICB9KTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBJTkZJTklUWSQxID0gMSAvIDA7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cblx0ICovXG5cdHZhciBjcmVhdGVTZXQgPSAhKFNldCQxICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0JDEoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkkMSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG5cdCAgcmV0dXJuIG5ldyBTZXQkMSh2YWx1ZXMpO1xuXHR9O1xuXG5cdC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuXHR2YXIgTEFSR0VfQVJSQVlfU0laRSQxID0gMjAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG5cdCAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgaXNDb21tb24gPSB0cnVlLFxuXHQgICAgICByZXN1bHQgPSBbXSxcblx0ICAgICAgc2VlbiA9IHJlc3VsdDtcblxuXHQgIGlmIChjb21wYXJhdG9yKSB7XG5cdCAgICBpc0NvbW1vbiA9IGZhbHNlO1xuXHQgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcblx0ICB9XG5cdCAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUkMSkge1xuXHQgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG5cdCAgICBpZiAoc2V0KSB7XG5cdCAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG5cdCAgICB9XG5cdCAgICBpc0NvbW1vbiA9IGZhbHNlO1xuXHQgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcblx0ICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG5cdCAgfVxuXHQgIG91dGVyOlxuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG5cdCAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG5cdCAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcblx0ICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcblx0ICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuXHQgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcblx0ICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuXHQgICAgICAgICAgY29udGludWUgb3V0ZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChpdGVyYXRlZSkge1xuXHQgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuXHQgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG5cdCAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcblx0ICAgICAgfVxuXHQgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG5cdCAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcblx0ICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuXHQgKiBpbiB0aGUgYXJyYXkuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBBcnJheVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udW5pcShbMiwgMSwgMl0pO1xuXHQgKiAvLyA9PiBbMiwgMV1cblx0ICovXG5cdGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcblx0ICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgY2xlYXJcblx0ICogQG1lbWJlck9mIFN0YWNrXG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuXHQgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuXHQgIHRoaXMuc2l6ZSA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBkZWxldGVcblx0ICogQG1lbWJlck9mIFN0YWNrXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cblx0ICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGdldFxuXHQgKiBAbWVtYmVyT2YgU3RhY2tcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuXHQgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGhhc1xuXHQgKiBAbWVtYmVyT2YgU3RhY2tcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuXHQgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuXHR9XG5cblx0LyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG5cdHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBzZXRcblx0ICogQG1lbWJlck9mIFN0YWNrXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblx0ICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuXHQgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcblx0ICAgIGlmICghTWFwJDEgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuXHQgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG5cdCAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcblx0ICB9XG5cdCAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcblx0ICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG5cdH1cblxuXHQvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuXHRTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuXHRTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5cdFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblx0U3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuXHRTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cblx0LyoqXG5cdCAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcblx0ICogc2hvcnRoYW5kcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuXHQgKiAgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuXHR2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSA9IDEsXG5cdCAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDMgPSAyO1xuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG5cdCAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuXHQgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSxcblx0ICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cblx0ICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG5cdCAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuXHQgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcblx0ICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG5cdCAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuXHQgIH1cblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgcmVzdWx0ID0gdHJ1ZSxcblx0ICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQzKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuXHQgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuXHQgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG5cdCAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuXHQgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG5cdCAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG5cdCAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cblx0ICAgIGlmIChjdXN0b21pemVyKSB7XG5cdCAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuXHQgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuXHQgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcblx0ICAgIH1cblx0ICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGlmIChjb21wYXJlZCkge1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cdCAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cdCAgICBpZiAoc2Vlbikge1xuXHQgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG5cdCAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSkpIHtcblx0ICAgICAgICByZXN1bHQgPSBmYWxzZTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmICghKFxuXHQgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG5cdCAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuXHQgICAgICAgICkpIHtcblx0ICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblx0ICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuXHQgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgVWludDhBcnJheSQxID0gcm9vdC5VaW50OEFycmF5O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cblx0ICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdCAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuXHR2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNCA9IDEsXG5cdCAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDIgPSAyO1xuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGJvb2xUYWckMyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcblx0ICAgIGRhdGVUYWckMyA9ICdbb2JqZWN0IERhdGVdJyxcblx0ICAgIGVycm9yVGFnJDIgPSAnW29iamVjdCBFcnJvcl0nLFxuXHQgICAgbWFwVGFnJDYgPSAnW29iamVjdCBNYXBdJyxcblx0ICAgIG51bWJlclRhZyQzID0gJ1tvYmplY3QgTnVtYmVyXScsXG5cdCAgICByZWdleHBUYWckMyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuXHQgICAgc2V0VGFnJDYgPSAnW29iamVjdCBTZXRdJyxcblx0ICAgIHN0cmluZ1RhZyQzID0gJ1tvYmplY3QgU3RyaW5nXScsXG5cdCAgICBzeW1ib2xUYWckMiA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG5cdHZhciBhcnJheUJ1ZmZlclRhZyQzID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcblx0ICAgIGRhdGFWaWV3VGFnJDQgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG5cdC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuXHR2YXIgc3ltYm9sUHJvdG8kMSA9IFN5bWJvbCQxID8gU3ltYm9sJDEucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuXHQgICAgc3ltYm9sVmFsdWVPZiQxID0gc3ltYm9sUHJvdG8kMSA/IHN5bWJvbFByb3RvJDEudmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuXHQgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG5cdCAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcblx0ICBzd2l0Y2ggKHRhZykge1xuXHQgICAgY2FzZSBkYXRhVmlld1RhZyQ0OlxuXHQgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG5cdCAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcblx0ICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cblx0ICAgIGNhc2UgYXJyYXlCdWZmZXJUYWckMzpcblx0ICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuXHQgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheSQxKG9iamVjdCksIG5ldyBVaW50OEFycmF5JDEob3RoZXIpKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdHJ1ZTtcblxuXHQgICAgY2FzZSBib29sVGFnJDM6XG5cdCAgICBjYXNlIGRhdGVUYWckMzpcblx0ICAgIGNhc2UgbnVtYmVyVGFnJDM6XG5cdCAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG5cdCAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG5cdCAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG5cdCAgICBjYXNlIGVycm9yVGFnJDI6XG5cdCAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cblx0ICAgIGNhc2UgcmVnZXhwVGFnJDM6XG5cdCAgICBjYXNlIHN0cmluZ1RhZyQzOlxuXHQgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuXHQgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG5cdCAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG5cdCAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG5cdCAgICBjYXNlIG1hcFRhZyQ2OlxuXHQgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cblx0ICAgIGNhc2Ugc2V0VGFnJDY6XG5cdCAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNDtcblx0ICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG5cdCAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuXHQgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuXHQgICAgICBpZiAoc3RhY2tlZCkge1xuXHQgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuXHQgICAgICB9XG5cdCAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRyQyO1xuXG5cdCAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXHQgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG5cdCAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcblx0ICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cblx0ICAgIGNhc2Ugc3ltYm9sVGFnJDI6XG5cdCAgICAgIGlmIChzeW1ib2xWYWx1ZU9mJDEpIHtcblx0ICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiQxLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mJDEuY2FsbChvdGhlcik7XG5cdCAgICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuXHQgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcblx0ICB9XG5cdCAgcmV0dXJuIGFycmF5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuXHQgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcblx0ICogc3ltYm9scyBvZiBgb2JqZWN0YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcblx0ICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcblx0ICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG5cdCAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgcmVzSW5kZXggPSAwLFxuXHQgICAgICByZXN1bHQgPSBbXTtcblxuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cdCAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG5cdCAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMTMuMFxuXHQgKiBAY2F0ZWdvcnkgVXRpbFxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuXHQgKlxuXHQgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuXHQgKiAvLyA9PiBbW10sIFtdXVxuXHQgKlxuXHQgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG5cdCAgcmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8kOSA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSQxID0gb2JqZWN0UHJvdG8kOS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG5cdHZhciBuYXRpdmVHZXRTeW1ib2xzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cblx0ICovXG5cdHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMkMSA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuXHQgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIFtdO1xuXHQgIH1cblx0ICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblx0ICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyQxKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuXHQgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEuY2FsbChvYmplY3QsIHN5bWJvbCk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcblx0ICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuXHQgIHdoaWxlICgrK2luZGV4IDwgbikge1xuXHQgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGFyZ3NUYWckMyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcblx0ICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnJDM7XG5cdH1cblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQ4ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDcgPSBvYmplY3RQcm90byQ4Lmhhc093blByb3BlcnR5O1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQ4LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuXHQgKiAgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkNy5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcblx0ICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4xMy4wXG5cdCAqIEBjYXRlZ29yeSBVdGlsXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuXHQgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuXHQgKi9cblx0ZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyQyID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblx0dmFyIGZyZWVNb2R1bGUkMiA9IGZyZWVFeHBvcnRzJDIgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cblx0LyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cblx0dmFyIG1vZHVsZUV4cG9ydHMkMiA9IGZyZWVNb2R1bGUkMiAmJiBmcmVlTW9kdWxlJDIuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMkMjtcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIEJ1ZmZlciQyID0gbW9kdWxlRXhwb3J0cyQyID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXHR2YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIkMiA/IEJ1ZmZlciQyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4zLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHR2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cblx0ICpcblx0ICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cblx0ICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNMZW5ndGgoMyk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqXG5cdCAqIF8uaXNMZW5ndGgoJzMnKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuXHQgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuXHR9XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgYXJnc1RhZyQyID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG5cdCAgICBhcnJheVRhZyQyID0gJ1tvYmplY3QgQXJyYXldJyxcblx0ICAgIGJvb2xUYWckMiA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcblx0ICAgIGRhdGVUYWckMiA9ICdbb2JqZWN0IERhdGVdJyxcblx0ICAgIGVycm9yVGFnJDEgPSAnW29iamVjdCBFcnJvcl0nLFxuXHQgICAgZnVuY1RhZyQxID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcblx0ICAgIG1hcFRhZyQ1ID0gJ1tvYmplY3QgTWFwXScsXG5cdCAgICBudW1iZXJUYWckMiA9ICdbb2JqZWN0IE51bWJlcl0nLFxuXHQgICAgb2JqZWN0VGFnJDMgPSAnW29iamVjdCBPYmplY3RdJyxcblx0ICAgIHJlZ2V4cFRhZyQyID0gJ1tvYmplY3QgUmVnRXhwXScsXG5cdCAgICBzZXRUYWckNSA9ICdbb2JqZWN0IFNldF0nLFxuXHQgICAgc3RyaW5nVGFnJDIgPSAnW29iamVjdCBTdHJpbmddJyxcblx0ICAgIHdlYWtNYXBUYWckMiA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxuXHR2YXIgYXJyYXlCdWZmZXJUYWckMiA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG5cdCAgICBkYXRhVmlld1RhZyQzID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcblx0ICAgIGZsb2F0MzJUYWckMiA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuXHQgICAgZmxvYXQ2NFRhZyQyID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG5cdCAgICBpbnQ4VGFnJDIgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcblx0ICAgIGludDE2VGFnJDIgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG5cdCAgICBpbnQzMlRhZyQyID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuXHQgICAgdWludDhUYWckMiA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcblx0ICAgIHVpbnQ4Q2xhbXBlZFRhZyQyID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcblx0ICAgIHVpbnQxNlRhZyQyID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcblx0ICAgIHVpbnQzMlRhZyQyID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuXHQvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG5cdHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuXHR0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnJDJdID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZyQyXSA9XG5cdHR5cGVkQXJyYXlUYWdzW2ludDhUYWckMl0gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZyQyXSA9XG5cdHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnJDJdID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWckMl0gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1t1aW50MzJUYWckMl0gPSB0cnVlO1xuXHR0eXBlZEFycmF5VGFnc1thcmdzVGFnJDJdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZyQyXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZyQzXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1tlcnJvclRhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWckMV0gPVxuXHR0eXBlZEFycmF5VGFnc1ttYXBUYWckNV0gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1tvYmplY3RUYWckM10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1tzZXRUYWckNV0gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWckMl0gPVxuXHR0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnJDJdID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdCAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcblx0ICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG5cdCAgfTtcblx0fVxuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyQxID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblx0dmFyIGZyZWVNb2R1bGUkMSA9IGZyZWVFeHBvcnRzJDEgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cblx0LyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cblx0dmFyIG1vZHVsZUV4cG9ydHMkMSA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMkMTtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cblx0dmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyQxICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuXHQvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cblx0dmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cblx0ICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG5cdCAgICBpZiAodHlwZXMpIHtcblx0ICAgICAgcmV0dXJuIHR5cGVzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuXHQgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cdH0oKSk7XG5cblx0LyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMy4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNUeXBlZEFycmF5KFtdKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQ3ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDYgPSBvYmplY3RQcm90byQ3Lmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcblx0ICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcblx0ICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuXHQgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcblx0ICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG5cdCAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcblx0ICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG5cdCAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cblx0ICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0ICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5JDYuY2FsbCh2YWx1ZSwga2V5KSkgJiZcblx0ICAgICAgICAhKHNraXBJbmRleGVzICYmIChcblx0ICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG5cdCAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG5cdCAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG5cdCAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG5cdCAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuXHQgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuXHQgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cblx0ICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuXHQgICAgICAgICkpKSB7XG5cdCAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQ2ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuXHQgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG5cdCAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvJDY7XG5cblx0ICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuXHQgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcblx0ICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcblx0ICB9O1xuXHR9XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXHR2YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSQ1ID0gb2JqZWN0UHJvdG8kNS5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcblx0ICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcblx0ICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcblx0ICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQ1LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG5cdCAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuXHQgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG5cdCAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbiQxKHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cblx0ICpcblx0ICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcblx0ICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuXHQgKiBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogZnVuY3Rpb24gRm9vKCkge1xuXHQgKiAgIHRoaXMuYSA9IDE7XG5cdCAqICAgdGhpcy5iID0gMjtcblx0ICogfVxuXHQgKlxuXHQgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuXHQgKlxuXHQgKiBfLmtleXMobmV3IEZvbyk7XG5cdCAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICpcblx0ICogXy5rZXlzKCdoaScpO1xuXHQgKiAvLyA9PiBbJzAnLCAnMSddXG5cdCAqL1xuXHRmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHQgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuXHQgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xuXHR9XG5cblx0LyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG5cdHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQzID0gMTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ0Lmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuXHQgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcblx0ICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHJDMsXG5cdCAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuXHQgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG5cdCAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG5cdCAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuXHQgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuXHQgIHdoaWxlIChpbmRleC0tKSB7XG5cdCAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuXHQgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkkNC5jYWxsKG90aGVyLCBrZXkpKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG5cdCAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcblx0ICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG5cdCAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuXHQgICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSB0cnVlO1xuXHQgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcblx0ICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cblx0ICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG5cdCAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcblx0ICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcblx0ICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuXHQgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuXHQgICAgaWYgKGN1c3RvbWl6ZXIpIHtcblx0ICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG5cdCAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcblx0ICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcblx0ICAgIH1cblx0ICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXHQgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuXHQgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcblx0ICAgICAgICAgIDogY29tcGFyZWRcblx0ICAgICAgICApKSB7XG5cdCAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcblx0ICB9XG5cdCAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcblx0ICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuXHQgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuXHQgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG5cdCAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG5cdCAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG5cdCAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG5cdCAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuXHQgICAgICByZXN1bHQgPSBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG5cdCAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuXHR2YXIgRGF0YVZpZXckMSA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cdHZhciBQcm9taXNlJDEgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cdHZhciBXZWFrTWFwJDEgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBtYXBUYWckNCA9ICdbb2JqZWN0IE1hcF0nLFxuXHQgICAgb2JqZWN0VGFnJDIgPSAnW29iamVjdCBPYmplY3RdJyxcblx0ICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG5cdCAgICBzZXRUYWckNCA9ICdbb2JqZWN0IFNldF0nLFxuXHQgICAgd2Vha01hcFRhZyQxID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG5cdHZhciBkYXRhVmlld1RhZyQyID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuXHR2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXckMSksXG5cdCAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwJDEpLFxuXHQgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlJDEpLFxuXHQgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCQxKSxcblx0ICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCQxKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cblx0ICovXG5cdHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG5cdC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cblx0aWYgKChEYXRhVmlldyQxICYmIGdldFRhZyhuZXcgRGF0YVZpZXckMShuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZyQyKSB8fFxuXHQgICAgKE1hcCQxICYmIGdldFRhZyhuZXcgTWFwJDEpICE9IG1hcFRhZyQ0KSB8fFxuXHQgICAgKFByb21pc2UkMSAmJiBnZXRUYWcoUHJvbWlzZSQxLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcblx0ICAgIChTZXQkMSAmJiBnZXRUYWcobmV3IFNldCQxKSAhPSBzZXRUYWckNCkgfHxcblx0ICAgIChXZWFrTWFwJDEgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwJDEpICE9IHdlYWtNYXBUYWckMSkpIHtcblx0ICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuXHQgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnJDIgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcblx0ICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cblx0ICAgIGlmIChjdG9yU3RyaW5nKSB7XG5cdCAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuXHQgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWckMjtcblx0ICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWckNDtcblx0ICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcblx0ICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWckNDtcblx0ICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZyQxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cdH1cblxuXHR2YXIgZ2V0VGFnJDEgPSBnZXRUYWc7XG5cblx0LyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG5cdHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQyID0gMTtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcblx0ICAgIGFycmF5VGFnJDEgPSAnW29iamVjdCBBcnJheV0nLFxuXHQgICAgb2JqZWN0VGFnJDEgPSAnW29iamVjdCBPYmplY3RdJztcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQzID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG5cdCAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcblx0ICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG5cdCAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuXHQgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuXHQgICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnJDEgOiBnZXRUYWckMShvYmplY3QpLFxuXHQgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnJDEgOiBnZXRUYWckMShvdGhlcik7XG5cblx0ICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyQxID8gb2JqZWN0VGFnJDEgOiBvYmpUYWc7XG5cdCAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWckMSA/IG9iamVjdFRhZyQxIDogb3RoVGFnO1xuXG5cdCAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyQxLFxuXHQgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWckMSxcblx0ICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuXHQgIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuXHQgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgb2JqSXNBcnIgPSB0cnVlO1xuXHQgICAgb2JqSXNPYmogPSBmYWxzZTtcblx0ICB9XG5cdCAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcblx0ICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG5cdCAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuXHQgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG5cdCAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuXHQgIH1cblx0ICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMikpIHtcblx0ICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcblx0ICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG5cdCAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuXHQgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG5cdCAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cblx0ICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcblx0ICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAoIWlzU2FtZVRhZykge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuXHQgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuXHQgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuXHQgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG5cdCAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cblx0ICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuXHQgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0ICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuXHQgIH1cblx0ICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuXHR2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMSA9IDEsXG5cdCAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEgPSAyO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcblx0ICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuXHQgICAgICBsZW5ndGggPSBpbmRleCxcblx0ICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cblx0ICBpZiAob2JqZWN0ID09IG51bGwpIHtcblx0ICAgIHJldHVybiAhbGVuZ3RoO1xuXHQgIH1cblx0ICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblx0ICB3aGlsZSAoaW5kZXgtLSkge1xuXHQgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuXHQgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcblx0ICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG5cdCAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG5cdCAgICAgICAgKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuXHQgICAgdmFyIGtleSA9IGRhdGFbMF0sXG5cdCAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcblx0ICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cblx0ICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuXHQgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG5cdCAgICAgIGlmIChjdXN0b21pemVyKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcblx0ICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHJDEgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuXHQgICAgICAgICAgICA6IHJlc3VsdFxuXHQgICAgICAgICAgKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuXHQgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0JDEodmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcblx0ICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuXHQgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG5cdCAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG5cdCAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuXHQgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG5cdCAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuXHQgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG5cdCAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuXHQgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG5cdCAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuXHQgIH1cblx0ICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcblx0ICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcblx0ICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcblx0ICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcblx0ICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuXHQgIH1cblx0ICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblx0ICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuXHQgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG5cdCAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG5cdCAqXG5cdCAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG5cdCAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuXHR9XG5cblx0LyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG5cdHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG5cdCAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuXHQgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG5cdCAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcblx0ICB9XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuXHQgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG5cdCAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuXHQgICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcblx0ICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQG1lbWJlck9mIF9cblx0ICogQGNhdGVnb3J5IFV0aWxcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuXHQgKlxuXHQgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICovXG5cdGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuXHQgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDIuNC4wXG5cdCAqIEBjYXRlZ29yeSBVdGlsXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2YXIgb2JqZWN0cyA9IFtcblx0ICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuXHQgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cblx0ICogXTtcblx0ICpcblx0ICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuXHQgKiAvLyA9PiBbMiwgMV1cblx0ICpcblx0ICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcblx0ICogLy8gPT4gWzEsIDJdXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG5cdCAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuXHQgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG5cdCAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cblx0ICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgIHJldHVybiBpZGVudGl0eTtcblx0ICB9XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuXHQgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG5cdCAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG5cdCAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuXHQgIH1cblx0ICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcblx0ICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblx0ICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcblx0ICAgICAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSk7XG5cdCAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuXHQgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuXHQgICAgfVxuXHQgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG5cdCAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG5cdCAgfTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xuXHR2YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cblx0LyoqXG5cdCAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2Vcblx0ICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuXHQgKi9cblx0ZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuXHQgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cblx0ICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9XG5cblx0LyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xuXHR2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG5cdCAgcmV0dXJuIHN0cmluZ1xuXHQgICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcblx0ICAgIDogc3RyaW5nO1xuXHR9XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBOQU4gPSAwIC8gMDtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuXHR2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG5cdC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG5cdHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKDMuMik7XG5cdCAqIC8vID0+IDMuMlxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuXHQgKiAvLyA9PiA1ZS0zMjRcblx0ICpcblx0ICogXy50b051bWJlcihJbmZpbml0eSk7XG5cdCAqIC8vID0+IEluZmluaXR5XG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoJzMuMicpO1xuXHQgKiAvLyA9PiAzLjJcblx0ICovXG5cdGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gTkFOO1xuXHQgIH1cblx0ICBpZiAoaXNPYmplY3QkMSh2YWx1ZSkpIHtcblx0ICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcblx0ICAgIHZhbHVlID0gaXNPYmplY3QkMShvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcblx0ICB9XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG5cdCAgfVxuXHQgIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuXHQgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG5cdCAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG5cdCAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcblx0ICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuXHR9XG5cblx0LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdHZhciBJTkZJTklUWSA9IDEgLyAwLFxuXHQgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMTIuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnRvRmluaXRlKDMuMik7XG5cdCAqIC8vID0+IDMuMlxuXHQgKlxuXHQgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuXHQgKiAvLyA9PiA1ZS0zMjRcblx0ICpcblx0ICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG5cdCAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG5cdCAqXG5cdCAqIF8udG9GaW5pdGUoJzMuMicpO1xuXHQgKiAvLyA9PiAzLjJcblx0ICovXG5cdGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG5cdCAgaWYgKCF2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuXHQgIH1cblx0ICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcblx0ICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcblx0ICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG5cdCAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuXHQgIH1cblx0ICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cblx0ICpcblx0ICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cblx0ICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udG9JbnRlZ2VyKDMuMik7XG5cdCAqIC8vID0+IDNcblx0ICpcblx0ICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG5cdCAqIC8vID0+IDBcblx0ICpcblx0ICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuXHQgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuXHQgKlxuXHQgKiBfLnRvSW50ZWdlcignMy4yJyk7XG5cdCAqIC8vID0+IDNcblx0ICovXG5cdGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuXHQgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG5cdCAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cblx0ICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG5cdH1cblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG5cdHZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Rcblx0ICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDEuMS4wXG5cdCAqIEBjYXRlZ29yeSBBcnJheVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciB1c2VycyA9IFtcblx0ICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcblx0ICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcblx0ICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG5cdCAqIF07XG5cdCAqXG5cdCAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuXHQgKiAvLyA9PiAwXG5cdCAqXG5cdCAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG5cdCAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG5cdCAqIC8vID0+IDFcblx0ICpcblx0ICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuXHQgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuXHQgKiAvLyA9PiAwXG5cdCAqXG5cdCAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuXHQgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuXHQgKiAvLyA9PiAyXG5cdCAqL1xuXHRmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG5cdCAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXHQgIGlmICghbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfVxuXHQgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcblx0ICB9XG5cdCAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpLCBpbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuXHQgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG5cdCAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIHVzZXJzID0gW1xuXHQgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcblx0ICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuXHQgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuXHQgKiBdO1xuXHQgKlxuXHQgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuXHQgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG5cdCAqXG5cdCAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG5cdCAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG5cdCAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG5cdCAqXG5cdCAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cblx0ICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG5cdCAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG5cdCAqXG5cdCAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuXHQgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcblx0ICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuXHQgKi9cblx0dmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXHR2YXIgbmF0aXZlSXNGaW5pdGUgPSByb290LmlzRmluaXRlLFxuXHQgICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuXHQgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcblx0ICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcblx0ICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG5cdCAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG5cdCAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcblx0ICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG5cdCAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcblx0ICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cblx0ICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG5cdCAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmdW5jKG51bWJlcik7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAzLjEwLjBcblx0ICogQGNhdGVnb3J5IE1hdGhcblx0ICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5yb3VuZCg0LjAwNik7XG5cdCAqIC8vID0+IDRcblx0ICpcblx0ICogXy5yb3VuZCg0LjAwNiwgMik7XG5cdCAqIC8vID0+IDQuMDFcblx0ICpcblx0ICogXy5yb3VuZCg0MDYwLCAtMik7XG5cdCAqIC8vID0+IDQxMDBcblx0ICovXG5cdHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG5cdCAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gYXJyYXk7XG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICovXG5cdGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG5cdCAgdmFyIGlzTmV3ID0gIW9iamVjdDtcblx0ICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuXHQgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuXHQgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuXHQgICAgICA6IHVuZGVmaW5lZDtcblxuXHQgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcblx0ICAgIH1cblx0ICAgIGlmIChpc05ldykge1xuXHQgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBvYmplY3Q7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcblx0ICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuXHQgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2Vcblx0ICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuXHQgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuXHQgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG5cdCAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQyID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQyLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcblx0ICBpZiAoIWlzT2JqZWN0JDEob2JqZWN0KSkge1xuXHQgICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuXHQgIH1cblx0ICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG5cdCAgICAgIHJlc3VsdCA9IFtdO1xuXG5cdCAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5JDIuY2FsbChvYmplY3QsIGtleSkpKSkge1xuXHQgICAgICByZXN1bHQucHVzaChrZXkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG5cdCAqXG5cdCAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAzLjAuMFxuXHQgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogZnVuY3Rpb24gRm9vKCkge1xuXHQgKiAgIHRoaXMuYSA9IDE7XG5cdCAqICAgdGhpcy5iID0gMjtcblx0ICogfVxuXHQgKlxuXHQgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuXHQgKlxuXHQgKiBfLmtleXNJbihuZXcgRm9vKTtcblx0ICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG5cdCAqL1xuXHRmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG5cdCAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuXHQgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcblx0ICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcblx0fVxuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cdHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cblx0LyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cblx0dmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBCdWZmZXIkMSA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcblx0ICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyJDEgPyBCdWZmZXIkMS5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuXHQgKi9cblx0ZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcblx0ICBpZiAoaXNEZWVwKSB7XG5cdCAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG5cdCAgfVxuXHQgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuXHQgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cblx0ICBidWZmZXIuY29weShyZXN1bHQpO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG5cdCAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG5cdCAgfVxuXHQgIHJldHVybiBhcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgKi9cblx0ZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcblx0ICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcblx0fVxuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXHR2YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG5cdCAqL1xuXHR2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgd2hpbGUgKG9iamVjdCkge1xuXHQgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcblx0ICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAqL1xuXHRmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG5cdCAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG5cdCAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcblx0ICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG5cdH1cblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQxLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcblx0ICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuXHQgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG5cdCAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkkMS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuXHQgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG5cdCAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cblx0ICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuXHQgKi9cblx0ZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuXHQgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG5cdCAgbmV3IFVpbnQ4QXJyYXkkMShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheSQxKGFycmF5QnVmZmVyKSk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG5cdCAqL1xuXHRmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcblx0ICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuXHQgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcblx0fVxuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuXHR2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuXHQgKi9cblx0ZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuXHQgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cblx0dmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG5cdCAqL1xuXHRmdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcblx0ICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cblx0ICovXG5cdGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcblx0ICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcblx0ICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcblx0fVxuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGJvb2xUYWckMSA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcblx0ICAgIGRhdGVUYWckMSA9ICdbb2JqZWN0IERhdGVdJyxcblx0ICAgIG1hcFRhZyQzID0gJ1tvYmplY3QgTWFwXScsXG5cdCAgICBudW1iZXJUYWckMSA9ICdbb2JqZWN0IE51bWJlcl0nLFxuXHQgICAgcmVnZXhwVGFnJDEgPSAnW29iamVjdCBSZWdFeHBdJyxcblx0ICAgIHNldFRhZyQzID0gJ1tvYmplY3QgU2V0XScsXG5cdCAgICBzdHJpbmdUYWckMSA9ICdbb2JqZWN0IFN0cmluZ10nLFxuXHQgICAgc3ltYm9sVGFnJDEgPSAnW29iamVjdCBTeW1ib2xdJztcblxuXHR2YXIgYXJyYXlCdWZmZXJUYWckMSA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG5cdCAgICBkYXRhVmlld1RhZyQxID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcblx0ICAgIGZsb2F0MzJUYWckMSA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuXHQgICAgZmxvYXQ2NFRhZyQxID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG5cdCAgICBpbnQ4VGFnJDEgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcblx0ICAgIGludDE2VGFnJDEgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG5cdCAgICBpbnQzMlRhZyQxID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuXHQgICAgdWludDhUYWckMSA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcblx0ICAgIHVpbnQ4Q2xhbXBlZFRhZyQxID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcblx0ICAgIHVpbnQxNlRhZyQxID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcblx0ICAgIHVpbnQzMlRhZyQxID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuXHQgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG5cdCAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG5cdCAgc3dpdGNoICh0YWcpIHtcblx0ICAgIGNhc2UgYXJyYXlCdWZmZXJUYWckMTpcblx0ICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuXHQgICAgY2FzZSBib29sVGFnJDE6XG5cdCAgICBjYXNlIGRhdGVUYWckMTpcblx0ICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG5cdCAgICBjYXNlIGRhdGFWaWV3VGFnJDE6XG5cdCAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuXHQgICAgY2FzZSBmbG9hdDMyVGFnJDE6IGNhc2UgZmxvYXQ2NFRhZyQxOlxuXHQgICAgY2FzZSBpbnQ4VGFnJDE6IGNhc2UgaW50MTZUYWckMTogY2FzZSBpbnQzMlRhZyQxOlxuXHQgICAgY2FzZSB1aW50OFRhZyQxOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZyQxOiBjYXNlIHVpbnQxNlRhZyQxOiBjYXNlIHVpbnQzMlRhZyQxOlxuXHQgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuXHQgICAgY2FzZSBtYXBUYWckMzpcblx0ICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG5cdCAgICBjYXNlIG51bWJlclRhZyQxOlxuXHQgICAgY2FzZSBzdHJpbmdUYWckMTpcblx0ICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cblx0ICAgIGNhc2UgcmVnZXhwVGFnJDE6XG5cdCAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG5cdCAgICBjYXNlIHNldFRhZyQzOlxuXHQgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cblx0ICAgIGNhc2Ugc3ltYm9sVGFnJDE6XG5cdCAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuXHQgIH1cblx0fVxuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuXHQgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuXHQgKi9cblx0dmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG5cdCAgZnVuY3Rpb24gb2JqZWN0KCkge31cblx0ICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcblx0ICAgIGlmICghaXNPYmplY3QkMShwcm90bykpIHtcblx0ICAgICAgcmV0dXJuIHt9O1xuXHQgICAgfVxuXHQgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuXHQgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcblx0ICAgIH1cblx0ICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcblx0ICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuXHQgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblx0fSgpKTtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuXHQgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuXHQgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuXHQgICAgOiB7fTtcblx0fVxuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG1hcFRhZyQyID0gJ1tvYmplY3QgTWFwXSc7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcblx0ICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWckMSh2YWx1ZSkgPT0gbWFwVGFnJDI7XG5cdH1cblxuXHQvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuXHR2YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMy4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzTWFwKG5ldyBNYXApO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0dmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgc2V0VGFnJDIgPSAnW29iamVjdCBTZXRdJztcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuXHQgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyQxKHZhbHVlKSA9PSBzZXRUYWckMjtcblx0fVxuXG5cdC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG5cdHZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4zLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNTZXQobmV3IFNldCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc1NldChuZXcgV2Vha1NldCk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHR2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuXHQvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuXHR2YXIgQ0xPTkVfREVFUF9GTEFHJDEgPSAxLFxuXHQgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcblx0ICAgIENMT05FX1NZTUJPTFNfRkxBRyQxID0gNDtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG5cdCAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG5cdCAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuXHQgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcblx0ICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcblx0ICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuXHQgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcblx0ICAgIG1hcFRhZyQxID0gJ1tvYmplY3QgTWFwXScsXG5cdCAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcblx0ICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuXHQgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG5cdCAgICBzZXRUYWckMSA9ICdbb2JqZWN0IFNldF0nLFxuXHQgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG5cdCAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcblx0ICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cblx0dmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcblx0ICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcblx0ICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcblx0ICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcblx0ICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcblx0ICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuXHQgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG5cdCAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcblx0ICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG5cdCAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuXHQgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuXHQvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuXHR2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuXHRjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuXHRjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cblx0Y2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuXHRjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5cdGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5cdGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWckMV0gPVxuXHRjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuXHRjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZyQxXSA9XG5cdGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5cdGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cblx0Y2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcblx0Y2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cblx0Y2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG5cdCAqIHRyYXZlcnNlZCBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuXHQgKiAgMSAtIERlZXAgY2xvbmVcblx0ICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG5cdCAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuXHQgIHZhciByZXN1bHQsXG5cdCAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUckMSxcblx0ICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcblx0ICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRyQxO1xuXG5cdCAgaWYgKGN1c3RvbWl6ZXIpIHtcblx0ICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcblx0ICB9XG5cdCAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblx0ICBpZiAoIWlzT2JqZWN0JDEodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuXHQgIGlmIChpc0Fycikge1xuXHQgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuXHQgICAgaWYgKCFpc0RlZXApIHtcblx0ICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHRhZyA9IGdldFRhZyQxKHZhbHVlKSxcblx0ICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG5cdCAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcblx0ICAgIH1cblx0ICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcblx0ICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuXHQgICAgICBpZiAoIWlzRGVlcCkge1xuXHQgICAgICAgIHJldHVybiBpc0ZsYXRcblx0ICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuXHQgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG5cdCAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG5cdCAgICAgIH1cblx0ICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cblx0ICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuXHQgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcblx0ICBpZiAoc3RhY2tlZCkge1xuXHQgICAgcmV0dXJuIHN0YWNrZWQ7XG5cdCAgfVxuXHQgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuXHQgIGlmIChpc1NldCh2YWx1ZSkpIHtcblx0ICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcblx0ICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG5cdCAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcblx0ICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuXHQgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcblx0ICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG5cdCAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG5cdCAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG5cdCAgICBpZiAocHJvcHMpIHtcblx0ICAgICAga2V5ID0gc3ViVmFsdWU7XG5cdCAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcblx0ICAgIH1cblx0ICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cdCAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuXHQgIH0pO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuXHR2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcblx0ICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAxLjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuXHQgKiBAc2VlIF8uY2xvbmVcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG5cdCAqXG5cdCAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG5cdCAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG5cdCAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG5cdCAqIGVxdWl2YWxlbnQuXG5cdCAqXG5cdCAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcblx0ICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuXHQgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuXHQgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cblx0ICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cblx0ICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG5cdCAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG5cdCAqXG5cdCAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBvYmplY3QgPT09IG90aGVyO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcblx0ICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcblx0fVxuXG5cdHZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdFx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG5cdH07XG5cblx0ZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdFx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdFx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRcdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxuXHR9XG5cblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG5cdHZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cdHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cblx0ZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuXHR9XG5cblx0ZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cblx0fVxuXG5cdGZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0XHQ6IHZhbHVlXG5cdH1cblxuXHRmdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHRcdH1cblx0XHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdFx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRcdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRcdHJldHVybiB0YXJnZXQucHJvcGVydHlJc0VudW1lcmFibGUoc3ltYm9sKVxuXHRcdFx0fSlcblx0XHRcdDogW11cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcblx0fVxuXG5cdGZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0XHR9IGNhdGNoKF8pIHtcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblx0fVxuXG5cdC8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0XHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG5cdH1cblxuXHRmdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRcdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBkZXN0aW5hdGlvblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRcdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHRcdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0XHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdFx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdFx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdFx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdFx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdFx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHRcdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHRcdH1cblx0fVxuXG5cdGRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdFx0fSwge30pXG5cdH07XG5cblx0dmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5cdHZhciBjanMgPSBkZWVwbWVyZ2VfMTtcblxuXHRmdW5jdGlvbiB0KHQpe3JldHVybiA2NTw9dCYmdDw9OTB9ZnVuY3Rpb24gbih0KXtyZXR1cm4gOTc8PXQmJnQ8PTEyMn1mdW5jdGlvbiByKHQpe3JldHVybiA0ODw9dCYmdDw9NTd9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gdC0zMn1mdW5jdGlvbiBlKHQpe3JldHVybiB0KzMyfWZ1bmN0aW9uIHUodSl7Y29uc3QgYz11LmNoYXJDb2RlQXQoMCk7aWYocihjKXx8NDU9PT1jfHxpc05hTihjKSlyZXR1cm4gdTtsZXQgaT10KGMpO2NvbnN0IGY9aT9bZShjKV06W2NdLHM9dS5sZW5ndGg7Zm9yKGxldCB0PTE7dDxzO3QrKyl7bGV0IHI9dS5jaGFyQ29kZUF0KHQpO2lmKDk1PT09cnx8MzI9PT1yfHw0NT09PXIpe2lmKGk9ITAscj11LmNoYXJDb2RlQXQoKyt0KSxpc05hTihyKSlyZXR1cm4gdTtuKHIpP2YucHVzaChvKHIpKTpmLnB1c2gocik7fWVsc2UgZi5wdXNoKHIpO31yZXR1cm4gaT9TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KHZvaWQgMCxmKTp1fWZ1bmN0aW9uIGMocixvKXtjb25zdCB1PXIuY2hhckNvZGVBdCgwKTtpZighbih1KXx8aXNOYU4odSkpcmV0dXJuIHI7bGV0IGM9ITE7Y29uc3QgaT1bdV07bGV0IGY9OTU7byYmby5jaGFyQ29kZUF0KDApJiYoZj1vLmNoYXJDb2RlQXQoMCkpO2NvbnN0IHM9ci5sZW5ndGg7Zm9yKGxldCBuPTE7bjxzO24rKyl7Y29uc3Qgbz1yLmNoYXJDb2RlQXQobik7dChvKT8oYz0hMCxpLnB1c2goZiksaS5wdXNoKGUobykpKTppLnB1c2gobyk7fXJldHVybiBjP1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkodm9pZCAwLGkpOnJ9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gQm9vbGVhbih0KSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJiEodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSYmISh0IGluc3RhbmNlb2YgRGF0ZSl9ZnVuY3Rpb24gYSh0LG4scil7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gZnVuY3Rpb24odCxuLHIpe2NvbnN0IG89bmV3IEFycmF5KHQubGVuZ3RoKTtsZXQgZT0wO2Zvcihjb25zdCB1IG9mIHQpb1tlKytdPXModSk/YSh1LG4scik6dTtyZXR1cm4gb30odCxuLHIpO2lmKHZvaWQgMCE9PXQucHJvdG90eXBlKXJldHVybiB0O2NvbnN0IG89e307Zm9yKGNvbnN0IGUgaW4gdCl7Y29uc3QgdT10W2VdO29bbihlLHIpXT1zKHUpP2EodSxuLHIpOnU7fXJldHVybiBvfWZ1bmN0aW9uIGwodCl7cmV0dXJuIHModCk/YSh0LHUpOnR9ZnVuY3Rpb24gZCh0LG4pe3JldHVybiBzKHQpP2EodCxjLG4pOnR9XG5cblx0bGV0IG9wdGlvbnMkMiA9IHt9O1xuXHRmdW5jdGlvbiBtZXJnZSh4LCB5LCBvcHQgPSB7fSkge1xuXHQgIGlmICgheSB8fCB0eXBlb2YgeSAhPT0gXCJvYmplY3RcIikge1xuXHQgICAgcmV0dXJuIHg7XG5cdCAgfVxuXHQgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikge1xuXHQgICAgcmV0dXJuIHg7XG5cdCAgfVxuXHQgIGZ1bmN0aW9uIGFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMyKSB7XG5cdCAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRhcmdldC5zbGljZSgpO1xuXHQgICAgc291cmNlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG5cdCAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25baW5kZXhdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgZGVzdGluYXRpb25baW5kZXhdID0gb3B0aW9uczIuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG5cdCAgICAgICAgICBpdGVtLFxuXHQgICAgICAgICAgb3B0aW9uczJcblx0ICAgICAgICApO1xuXHQgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMyLmlzTWVyZ2VhYmxlT2JqZWN0KGl0ZW0pKSB7XG5cdCAgICAgICAgZGVzdGluYXRpb25baW5kZXhdID0gbWVyZ2UodGFyZ2V0W2luZGV4XSwgaXRlbSwgb3B0aW9uczIpO1xuXHQgICAgICB9IGVsc2UgaWYgKHRhcmdldC5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuXHQgICAgICAgIGRlc3RpbmF0aW9uLnB1c2goaXRlbSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuXHQgIH1cblx0ICByZXR1cm4gY2pzKHgsIHksIHtcblx0ICAgIGFycmF5TWVyZ2Vcblx0ICB9KTtcblx0fVxuXHRmdW5jdGlvbiBzZXRPcHRpb25zKG9wdG5zKSB7XG5cdCAgb3B0aW9ucyQyID0gb3B0bnM7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcblx0ICByZXR1cm4gb3B0aW9ucyQyO1xuXHR9XG5cdGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuXHQgIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhKHZhbCBpbnN0YW5jZW9mIEFycmF5KTtcblx0fVxuXHRmdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XG5cdCAgcmV0dXJuIHUoc3RyKTtcblx0fVxuXHRmdW5jdGlvbiBzbmFrZUNhc2Uoc3RyKSB7XG5cdCAgcmV0dXJuIGMoc3RyLCBcIl9cIik7XG5cdH1cblx0ZnVuY3Rpb24gdG9DYW1lbChvYmopIHtcblx0ICBpZiAoIW9iailcblx0ICAgIHJldHVybiBvYmo7XG5cdCAgY29uc3Qgb2JqQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG5cdCAgcmV0dXJuIGwob2JqQ29weSk7XG5cdH1cblx0ZnVuY3Rpb24gdG9DYW1lbFBhdGgoc3RyKSB7XG5cdCAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHJldHVybiBzdHIuc3BsaXQoXCIuXCIpLm1hcCh1KS5qb2luKFwiLlwiKTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXHRmdW5jdGlvbiB0b1NuYWtlKG9iaikge1xuXHQgIGlmICghb2JqKVxuXHQgICAgcmV0dXJuIG9iajtcblx0ICBjb25zdCBvYmpDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcblx0ICByZXR1cm4gZChvYmpDb3B5LCBcIl9cIik7XG5cdH1cblx0ZnVuY3Rpb24gdHJpbUJvdGgoc3RyKSB7XG5cdCAgcmV0dXJuIHRyaW1TdGFydCh0cmltRW5kKHN0cikpO1xuXHR9XG5cdGZ1bmN0aW9uIHRyaW1TdGFydChzdHIpIHtcblx0ICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiA/IHN0ci5yZXBsYWNlKC9eWy9dKy8sIFwiXCIpIDogXCJcIjtcblx0fVxuXHRmdW5jdGlvbiB0cmltRW5kKHN0cikge1xuXHQgIHJldHVybiB0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiID8gc3RyLnJlcGxhY2UoL1svXSskLywgXCJcIikgOiBcIlwiO1xuXHR9XG5cdGZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5KHN0cikge1xuXHQgIHJldHVybiBsaWIuc3RyaW5naWZ5KHN0cik7XG5cdH1cblx0ZnVuY3Rpb24gbWFwJDEoYXJyLCBjYikge1xuXHQgIHJldHVybiBhcnIgaW5zdGFuY2VvZiBBcnJheSA/IGFyci5tYXAoY2IpIDogW107XG5cdH1cblx0ZnVuY3Rpb24gcmVkdWNlJDEoYXJyLCBjYiwgaW5pdCkge1xuXHQgIHJldHVybiBhcnIgaW5zdGFuY2VvZiBBcnJheSA/IGFyci5yZWR1Y2UoY2IsIGluaXQpIDogaW5pdDtcblx0fVxuXHRmdW5jdGlvbiBpc1NlcnZlcigpIHtcblx0ICByZXR1cm4gISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAmJiB3aW5kb3cuZG9jdW1lbnQpO1xuXHR9XG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYykge1xuXHQgIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiO1xuXHR9XG5cdGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RzKHJlcXVlc3QsIHVyaSwgbWV0aG9kcykge1xuXHQgIHJldHVybiB7XG5cdCAgICBsaXN0OiBtZXRob2RzLmluZGV4T2YoXCJsaXN0XCIpID49IDAgPyBmdW5jdGlvbihxdWVyeSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcImdldFwiLCB1cmksIHZvaWQgMCwgcXVlcnkpO1xuXHQgICAgfSA6IHZvaWQgMCxcblx0ICAgIGdldDogbWV0aG9kcy5pbmRleE9mKFwiZ2V0XCIpID49IDAgPyBmdW5jdGlvbihpZCwgcXVlcnkpIHtcblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJnZXRcIiwgdXJpLCBpZCwgcXVlcnkpO1xuXHQgICAgfSA6IHZvaWQgMFxuXHQgIH07XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gdmF1bHRSZXF1ZXN0KG1ldGhvZCwgdXJsLCBkYXRhLCBvcHQgPSB2b2lkIDApIHtcblx0ICBjb25zdCB2YXVsdFVybCA9IG9wdGlvbnMkMi52YXVsdFVybDtcblx0ICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucyQyLnRpbWVvdXQ7XG5cdCAgY29uc3QgcmVxdWVzdElkID0gdmF1bHRSZXF1ZXN0SWQoKTtcblx0ICBjb25zdCBjYWxsYmFjayA9IGBzd2VsbF92YXVsdF9yZXNwb25zZV8ke3JlcXVlc3RJZH1gO1xuXHQgIGRhdGEgPSB7XG5cdCAgICAkanNvbnA6IHtcblx0ICAgICAgbWV0aG9kLFxuXHQgICAgICBjYWxsYmFja1xuXHQgICAgfSxcblx0ICAgICRkYXRhOiBkYXRhLFxuXHQgICAgJGtleTogb3B0aW9ucyQyLmtleVxuXHQgIH07XG5cdCAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0ICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cdCAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdCAgICBzY3JpcHQuc3JjID0gYCR7dHJpbUVuZCh2YXVsdFVybCl9LyR7dHJpbVN0YXJ0KHVybCl9PyR7c2VyaWFsaXplRGF0YShcbiAgICAgIGRhdGFcbiAgICApfWA7XG5cdCAgICBjb25zdCBlcnJvclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0ICAgICAgd2luZG93W2NhbGxiYWNrXSh7XG5cdCAgICAgICAgJGVycm9yOiBgUmVxdWVzdCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0IC8gMWUzfSBzZWNvbmRzYCxcblx0ICAgICAgICAkc3RhdHVzOiA1MDBcblx0ICAgICAgfSk7XG5cdCAgICB9LCB0aW1lb3V0KTtcblx0ICAgIHdpbmRvd1tjYWxsYmFja10gPSAocmVzdWx0KSA9PiB7XG5cdCAgICAgIGNsZWFyVGltZW91dChlcnJvclRpbWVvdXQpO1xuXHQgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC4kZXJyb3IpIHtcblx0ICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IocmVzdWx0LiRlcnJvcik7XG5cdCAgICAgICAgZXJyLmNvZGUgPSBcInJlcXVlc3RfZXJyb3JcIjtcblx0ICAgICAgICBlcnIuc3RhdHVzID0gcmVzdWx0LiRzdGF0dXM7XG5cdCAgICAgICAgcmVqZWN0KGVycik7XG5cdCAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdCB8fCByZXN1bHQuJHN0YXR1cyA+PSAzMDApIHtcblx0ICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG5cdCAgICAgICAgICBcIkEgY29ubmVjdGlvbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBtYWtpbmcgdGhlIHJlcXVlc3RcIlxuXHQgICAgICAgICk7XG5cdCAgICAgICAgZXJyLmNvZGUgPSBcImNvbm5lY3Rpb25fZXJyb3JcIjtcblx0ICAgICAgICBlcnIuc3RhdHVzID0gcmVzdWx0LiRzdGF0dXM7XG5cdCAgICAgICAgcmVqZWN0KGVycik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVzb2x2ZShvcHRpb25zJDIudXNlQ2FtZWxDYXNlID8gdG9DYW1lbChyZXN1bHQuJGRhdGEpIDogcmVzdWx0LiRkYXRhKTtcblx0ICAgICAgfVxuXHQgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXTtcblx0ICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0ICAgIH07XG5cdCAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0ICB9KTtcblx0fVxuXHRmdW5jdGlvbiB2YXVsdFJlcXVlc3RJZCgpIHtcblx0ICB3aW5kb3cuX19zd2VsbF92YXVsdF9yZXF1ZXN0X2lkID0gd2luZG93Ll9fc3dlbGxfdmF1bHRfcmVxdWVzdF9pZCB8fCAwO1xuXHQgIHdpbmRvdy5fX3N3ZWxsX3ZhdWx0X3JlcXVlc3RfaWQrKztcblx0ICByZXR1cm4gd2luZG93Ll9fc3dlbGxfdmF1bHRfcmVxdWVzdF9pZDtcblx0fVxuXHRmdW5jdGlvbiBzZXJpYWxpemVEYXRhKGRhdGEpIHtcblx0ICBjb25zdCBzID0gW107XG5cdCAgY29uc3QgYWRkID0gZnVuY3Rpb24oa2V5MiwgdmFsdWUpIHtcblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG5cdCAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgdmFsdWUgPSBcIlwiO1xuXHQgICAgfVxuXHQgICAgc1tzLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoa2V5MikgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdCAgfTtcblx0ICBmb3IgKGNvbnN0IGtleTIgaW4gZGF0YSkge1xuXHQgICAgYnVpbGRQYXJhbXMoa2V5MiwgZGF0YVtrZXkyXSwgYWRkKTtcblx0ICB9XG5cdCAgcmV0dXJuIHMuam9pbihcIiZcIikucmVwbGFjZShcIiBcIiwgXCIrXCIpO1xuXHR9XG5cdGNvbnN0IHJicmFja2V0ID0gL1xcW1xcXSQvO1xuXHRmdW5jdGlvbiBidWlsZFBhcmFtcyhrZXksIG9iaiwgYWRkKSB7XG5cdCAgbGV0IG5hbWU7XG5cdCAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAocmJyYWNrZXQudGVzdChrZXkpKSB7XG5cdCAgICAgICAgYWRkKGtleSwgdik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYnVpbGRQYXJhbXMoXG5cdCAgICAgICAgICBrZXkgKyBcIltcIiArICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIikgKyBcIl1cIixcblx0ICAgICAgICAgIHYsXG5cdCAgICAgICAgICBhZGRcblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgZm9yIChuYW1lIGluIG9iaikge1xuXHQgICAgICBidWlsZFBhcmFtcyhrZXkgKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqW25hbWVdLCBhZGQpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBhZGQoa2V5LCBvYmopO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBiYXNlNjRFbmNvZGUoc3RyaW5nKSB7XG5cdCAgaWYgKHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuXHQgIH1cblx0ICByZXR1cm4gQnVmZmVyLmZyb20oc3RyaW5nKS50b1N0cmluZyhcImJhc2U2NFwiKTtcblx0fVxuXHRmdW5jdGlvbiBnZXRMb2NhdGlvblBhcmFtcyhsb2NhdGlvbikge1xuXHQgIGNvbnN0IHVybCA9IGxvY2F0aW9uLnNlYXJjaDtcblx0ICBjb25zdCBxdWVyeSA9IHVybC5zdWJzdHIoMSk7XG5cdCAgY29uc3QgcmVzdWx0ID0ge307XG5cdCAgcXVlcnkuc3BsaXQoXCImXCIpLmZvckVhY2goZnVuY3Rpb24ocGFydCkge1xuXHQgICAgY29uc3QgaXRlbSA9IHBhcnQuc3BsaXQoXCI9XCIpO1xuXHQgICAgcmVzdWx0W2l0ZW1bMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KGl0ZW1bMV0pO1xuXHQgIH0pO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlVXJsUGFyYW1zKCkge1xuXHQgIGNvbnN0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG5cdCAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHsgcGF0aDogdXJsIH0sIFwiXCIsIHVybCk7XG5cdH1cblxuXHR2YXIgdXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdGRlZmF1bHRNZXRob2RzOiBkZWZhdWx0TWV0aG9kcyxcblx0XHRzZXQ6IHNldCxcblx0XHRnZXQ6IGdldCxcblx0XHR1bmlxOiB1bmlxLFxuXHRcdGZpbmQ6IGZpbmQsXG5cdFx0cm91bmQ6IHJvdW5kLFxuXHRcdGZpbmRJbmRleDogZmluZEluZGV4LFxuXHRcdGNhbWVsQ2FzZTogY2FtZWxDYXNlLFxuXHRcdGNsb25lRGVlcDogY2xvbmVEZWVwLFxuXHRcdG1lcmdlOiBtZXJnZSxcblx0XHRzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuXHRcdGdldE9wdGlvbnM6IGdldE9wdGlvbnMsXG5cdFx0dG9DYW1lbDogdG9DYW1lbCxcblx0XHR0b0NhbWVsUGF0aDogdG9DYW1lbFBhdGgsXG5cdFx0dG9TbmFrZTogdG9TbmFrZSxcblx0XHR0cmltQm90aDogdHJpbUJvdGgsXG5cdFx0dHJpbVN0YXJ0OiB0cmltU3RhcnQsXG5cdFx0dHJpbUVuZDogdHJpbUVuZCxcblx0XHRzdHJpbmdpZnlRdWVyeTogc3RyaW5naWZ5UXVlcnksXG5cdFx0aXNTZXJ2ZXI6IGlzU2VydmVyLFxuXHRcdGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG5cdFx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRcdGlzRXF1YWw6IGlzRXF1YWwsXG5cdFx0c25ha2VDYXNlOiBzbmFrZUNhc2UsXG5cdFx0bWFwOiBtYXAkMSxcblx0XHRyZWR1Y2U6IHJlZHVjZSQxLFxuXHRcdGJhc2U2NEVuY29kZTogYmFzZTY0RW5jb2RlLFxuXHRcdHZhdWx0UmVxdWVzdDogdmF1bHRSZXF1ZXN0LFxuXHRcdGdldExvY2F0aW9uUGFyYW1zOiBnZXRMb2NhdGlvblBhcmFtcyxcblx0XHRyZW1vdmVVcmxQYXJhbXM6IHJlbW92ZVVybFBhcmFtc1xuXHR9KTtcblxuXHRjb25zdCBjYXJkQXBpID0ge1xuXHQgIGFzeW5jIGNyZWF0ZVRva2VuKGRhdGEpIHtcblx0ICAgIGxldCBlcnJvciA9IG51bGw7XG5cdCAgICBsZXQgY29kZSA9IG51bGw7XG5cdCAgICBsZXQgcGFyYW0gPSBudWxsO1xuXHQgICAgaWYgKCFkYXRhKSB7XG5cdCAgICAgIGVycm9yID0gXCJDYXJkIGRldGFpbHMgYXJlIG1pc3NpbmcgaW4gYHN3ZWxsLmNhcmQuY3JlYXRlVG9rZW4oY2FyZClgXCI7XG5cdCAgICAgIHBhcmFtID0gXCJcIjtcblx0ICAgIH1cblx0ICAgIGNvbnN0IGNhcmQgPSB0b1NuYWtlKGRhdGEpO1xuXHQgICAgaWYgKCFjYXJkLm5vbmNlKSB7XG5cdCAgICAgIGlmICghdGhpcy52YWxpZGF0ZU51bWJlcihjYXJkLm51bWJlcikpIHtcblx0ICAgICAgICBlcnJvciA9IFwiQ2FyZCBudW1iZXIgYXBwZWFycyB0byBiZSBpbnZhbGlkXCI7XG5cdCAgICAgICAgY29kZSA9IFwiaW52YWxpZF9jYXJkX251bWJlclwiO1xuXHQgICAgICAgIHBhcmFtID0gXCJudW1iZXJcIjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoY2FyZC5leHApIHtcblx0ICAgICAgICBjb25zdCBleHAgPSB0aGlzLmV4cGlyeShjYXJkLmV4cCk7XG5cdCAgICAgICAgY2FyZC5leHBfbW9udGggPSBleHAubW9udGg7XG5cdCAgICAgICAgY2FyZC5leHBfeWVhciA9IGV4cC55ZWFyO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghdGhpcy52YWxpZGF0ZUV4cGlyeShjYXJkLmV4cF9tb250aCwgY2FyZC5leHBfeWVhcikpIHtcblx0ICAgICAgICBlcnJvciA9IFwiQ2FyZCBleHBpcnkgYXBwZWFycyB0byBiZSBpbnZhbGlkXCI7XG5cdCAgICAgICAgY29kZSA9IFwiaW52YWxpZF9jYXJkX2V4cGlyeVwiO1xuXHQgICAgICAgIHBhcmFtID0gXCJleHBfbW9udGhcIjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIXRoaXMudmFsaWRhdGVDVkMoY2FyZC5jdmMpKSB7XG5cdCAgICAgICAgZXJyb3IgPSBcIkNhcmQgQ1ZDIGNvZGUgYXBwZWFycyB0byBiZSBpbnZhbGlkXCI7XG5cdCAgICAgICAgY29kZSA9IFwiaW52YWxpZF9jYXJkX2N2Y1wiO1xuXHQgICAgICAgIHBhcmFtID0gXCJleHBfY3ZjXCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChlcnJvcikge1xuXHQgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJyb3IpO1xuXHQgICAgICBlcnIuY29kZSA9IGNvZGUgfHwgXCJpbnZhbGlkX2NhcmRcIjtcblx0ICAgICAgZXJyLnN0YXR1cyA9IDQwMjtcblx0ICAgICAgZXJyLnBhcmFtID0gcGFyYW07XG5cdCAgICAgIHRocm93IGVycjtcblx0ICAgIH1cblx0ICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhdWx0UmVxdWVzdChcInBvc3RcIiwgXCIvdG9rZW5zXCIsIGNhcmQpO1xuXHQgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcblx0ICAgICAgY29uc3QgcGFyYW0yID0gT2JqZWN0LmtleXMocmVzdWx0LmVycm9ycylbMF07XG5cdCAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihyZXN1bHQuZXJyb3JzW3BhcmFtMl0ubWVzc2FnZSB8fCBcIlVua25vd24gZXJyb3JcIik7XG5cdCAgICAgIGVyci5jb2RlID0gXCJ2YXVsdF9lcnJvclwiO1xuXHQgICAgICBlcnIuc3RhdHVzID0gNDAyO1xuXHQgICAgICBlcnIucGFyYW0gPSBwYXJhbTI7XG5cdCAgICAgIHRocm93IGVycjtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblx0ICBleHBpcnkodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5tb250aCAmJiB2YWx1ZS55ZWFyKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIGNvbnN0IHBhcnRzID0gbmV3IFN0cmluZyh2YWx1ZSkuc3BsaXQoL1tcXHNcXC9cXC1dKy8sIDIpO1xuXHQgICAgY29uc3QgbW9udGggPSBwYXJ0c1swXTtcblx0ICAgIGxldCB5ZWFyID0gcGFydHNbMV07XG5cdCAgICBpZiAoeWVhciAmJiB5ZWFyLmxlbmd0aCA9PT0gMiAmJiAvXlxcZCskLy50ZXN0KHllYXIpKSB7XG5cdCAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpLnN1YnN0cmluZygwLCAyKTtcblx0ICAgICAgeWVhciA9IHByZWZpeCArIHllYXI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBtb250aDogfn5tb250aCxcblx0ICAgICAgeWVhcjogfn55ZWFyXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgdHlwZXMoKSB7XG5cdCAgICBsZXQgZSwgdCwgbiwgcjtcblx0ICAgIHQgPSB7fTtcblx0ICAgIGZvciAoZSA9IG4gPSA0MDsgbiA8PSA0OTsgZSA9ICsrbilcblx0ICAgICAgdFtlXSA9IFwiVmlzYVwiO1xuXHQgICAgZm9yIChlID0gciA9IDUwOyByIDw9IDU5OyBlID0gKytyKVxuXHQgICAgICB0W2VdID0gXCJNYXN0ZXJDYXJkXCI7XG5cdCAgICByZXR1cm4gdFszNF0gPSB0WzM3XSA9IFwiQW1lcmljYW4gRXhwcmVzc1wiLCB0WzYwXSA9IHRbNjJdID0gdFs2NF0gPSB0WzY1XSA9IFwiRGlzY292ZXJcIiwgdFszNV0gPSBcIkpDQlwiLCB0WzMwXSA9IHRbMzZdID0gdFszOF0gPSB0WzM5XSA9IFwiRGluZXJzIENsdWJcIiwgdDtcblx0ICB9LFxuXHQgIHR5cGUobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy50eXBlcygpW251bS5zbGljZSgwLCAyKV0gfHwgXCJVbmtub3duXCI7XG5cdCAgfSxcblx0ICBsdWhuQ2hlY2sobnVtKSB7XG5cdCAgICBsZXQgdCwgbiwgciwgaSwgcywgbztcblx0ICAgIHIgPSB0cnVlLCBpID0gMCwgbiA9IChudW0gKyBcIlwiKS5zcGxpdChcIlwiKS5yZXZlcnNlKCk7XG5cdCAgICBmb3IgKHMgPSAwLCBvID0gbi5sZW5ndGg7IHMgPCBvOyBzKyspIHtcblx0ICAgICAgdCA9IG5bc10sIHQgPSBwYXJzZUludCh0LCAxMCk7XG5cdCAgICAgIGlmIChyID0gIXIpXG5cdCAgICAgICAgdCAqPSAyO1xuXHQgICAgICB0ID4gOSAmJiAodCAtPSA5KSwgaSArPSB0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGkgJSAxMCA9PT0gMDtcblx0ICB9LFxuXHQgIHZhbGlkYXRlTnVtYmVyKG51bSkge1xuXHQgICAgcmV0dXJuIG51bSA9IChudW0gKyBcIlwiKS5yZXBsYWNlKC9cXHMrfC0vZywgXCJcIiksIG51bS5sZW5ndGggPj0gMTAgJiYgbnVtLmxlbmd0aCA8PSAxNiAmJiB0aGlzLmx1aG5DaGVjayhudW0pO1xuXHQgIH0sXG5cdCAgdmFsaWRhdGVFeHBpcnkobW9udGgsIHllYXIpIHtcblx0ICAgIGxldCByLCBpO1xuXHQgICAgcmV0dXJuIG1vbnRoID0gU3RyaW5nKG1vbnRoKS50cmltKCksIHllYXIgPSBTdHJpbmcoeWVhcikudHJpbSgpLCAvXlxcZCskLy50ZXN0KG1vbnRoKSA/IC9eXFxkKyQvLnRlc3QoeWVhcikgPyBwYXJzZUludChtb250aCwgMTApIDw9IDEyID8gKGkgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCksIHIgPSBuZXcgRGF0ZSgpLCBpLnNldE1vbnRoKGkuZ2V0TW9udGgoKSAtIDEpLCBpLnNldE1vbnRoKGkuZ2V0TW9udGgoKSArIDEsIDEpLCBpID4gcikgOiBmYWxzZSA6IGZhbHNlIDogZmFsc2U7XG5cdCAgfSxcblx0ICB2YWxpZGF0ZUNWQyh2YWwpIHtcblx0ICAgIHJldHVybiB2YWwgPSBTdHJpbmcodmFsKS50cmltKCksIC9eXFxkKyQvLnRlc3QodmFsKSAmJiB2YWwubGVuZ3RoID49IDMgJiYgdmFsLmxlbmd0aCA8PSA0O1xuXHQgIH1cblx0fTtcblxuXHR2YXIgX19kZWZQcm9wJDkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdHZhciBfX2dldE93blByb3BTeW1ib2xzJDkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgX19oYXNPd25Qcm9wJDkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgX19wcm9wSXNFbnVtJDkgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgX19kZWZOb3JtYWxQcm9wJDkgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDkob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xuXHR2YXIgX19zcHJlYWRWYWx1ZXMkOSA9IChhLCBiKSA9PiB7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuXHQgICAgaWYgKF9faGFzT3duUHJvcCQ5LmNhbGwoYiwgcHJvcCkpXG5cdCAgICAgIF9fZGVmTm9ybWFsUHJvcCQ5KGEsIHByb3AsIGJbcHJvcF0pO1xuXHQgIGlmIChfX2dldE93blByb3BTeW1ib2xzJDkpXG5cdCAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkOShiKSkge1xuXHQgICAgICBpZiAoX19wcm9wSXNFbnVtJDkuY2FsbChiLCBwcm9wKSlcblx0ICAgICAgICBfX2RlZk5vcm1hbFByb3AkOShhLCBwcm9wLCBiW3Byb3BdKTtcblx0ICAgIH1cblx0ICByZXR1cm4gYTtcblx0fTtcblx0Y29uc3QgQ09PS0lFX01BWF9BR0UgPSA2MDQ4MDA7XG5cdGZ1bmN0aW9uIGdldENvb2tpZShuYW1lKSB7XG5cdCAgaWYgKGlzU2VydmVyKCkpIHtcblx0ICAgIHJldHVybiB2b2lkIDA7XG5cdCAgfVxuXHQgIGNvbnN0IG1hdGNoZXMgPSBkb2N1bWVudC5jb29raWUubWF0Y2goXG5cdCAgICBuZXcgUmVnRXhwKFxuXHQgICAgICBcIig/Ol58OyApXCIgKyBuYW1lLnJlcGxhY2UoLyhbLiQ/Knx7fSgpW11cXFxcXFwvXFwrXl0pL2csIFwiXFxcXCQxXCIpICsgXCI9KFteO10qKVwiXG5cdCAgICApXG5cdCAgKTtcblx0ICByZXR1cm4gbWF0Y2hlcyA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaGVzWzFdKSA6IHZvaWQgMDtcblx0fVxuXHRmdW5jdGlvbiBzZXRDb29raWUobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXHQgIGlmIChpc1NlcnZlcigpKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyQ5KHtcblx0ICAgIHBhdGg6IFwiL1wiLFxuXHQgICAgXCJtYXgtYWdlXCI6IENPT0tJRV9NQVhfQUdFLFxuXHQgICAgc2FtZXNpdGU6IFwibGF4XCJcblx0ICB9LCBvcHRpb25zKTtcblx0ICBpZiAob3B0aW9ucy5leHBpcmVzICYmIG9wdGlvbnMuZXhwaXJlcy50b1VUQ1N0cmluZykge1xuXHQgICAgb3B0aW9ucy5leHBpcmVzID0gb3B0aW9ucy5leHBpcmVzLnRvVVRDU3RyaW5nKCk7XG5cdCAgfVxuXHQgIGxldCB1cGRhdGVkQ29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHQgIGZvciAoY29uc3Qgb3B0aW9uS2V5IGluIG9wdGlvbnMpIHtcblx0ICAgIHVwZGF0ZWRDb29raWUgKz0gXCI7IFwiICsgb3B0aW9uS2V5O1xuXHQgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb25zW29wdGlvbktleV07XG5cdCAgICBpZiAob3B0aW9uVmFsdWUgIT09IHRydWUpIHtcblx0ICAgICAgdXBkYXRlZENvb2tpZSArPSBcIj1cIiArIG9wdGlvblZhbHVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICBkb2N1bWVudC5jb29raWUgPSB1cGRhdGVkQ29va2llO1xuXHR9XG5cblx0dmFyIF9fZGVmUHJvcCQ4ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHR2YXIgX19nZXRPd25Qcm9wU3ltYm9scyQ4ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblx0dmFyIF9faGFzT3duUHJvcCQ4ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIF9fcHJvcElzRW51bSQ4ID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIF9fZGVmTm9ybWFsUHJvcCQ4ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ4KG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcblx0dmFyIF9fc3ByZWFkVmFsdWVzJDggPSAoYSwgYikgPT4ge1xuXHQgIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcblx0ICAgIGlmIChfX2hhc093blByb3AkOC5jYWxsKGIsIHByb3ApKVxuXHQgICAgICBfX2RlZk5vcm1hbFByb3AkOChhLCBwcm9wLCBiW3Byb3BdKTtcblx0ICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQ4KVxuXHQgICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDgoYikpIHtcblx0ICAgICAgaWYgKF9fcHJvcElzRW51bSQ4LmNhbGwoYiwgcHJvcCkpXG5cdCAgICAgICAgX19kZWZOb3JtYWxQcm9wJDgoYSwgcHJvcCwgYltwcm9wXSk7XG5cdCAgICB9XG5cdCAgcmV0dXJuIGE7XG5cdH07XG5cdGNvbnN0IFJFQ09SRF9USU1FT1VUID0gNWUzO1xuXHRsZXQgVkFMVUVTID0ge307XG5cdGNvbnN0IGNhY2hlQXBpID0ge1xuXHQgIG9wdGlvbnM6IHtcblx0ICAgIGVuYWJsZWQ6IHRydWUsXG5cdCAgICBkZWJ1ZzogZmFsc2Vcblx0ICB9LFxuXHQgIGRlYnVnKC4uLmFyZ3MpIHtcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcblx0ICAgICAgY29uc29sZS5sb2coLi4uYXJncyk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICB2YWx1ZXMoeyBtb2RlbCwgaWQgfSwgc2V0VmFsdWVzID0gdm9pZCAwKSB7XG5cdCAgICB0aGlzLmRlYnVnKFwiY2FjaGUudmFsdWVzXCIsIC4uLmFyZ3VtZW50cyk7XG5cdCAgICBpZiAoc2V0VmFsdWVzICE9PSB2b2lkIDApIHtcblx0ICAgICAgZm9yIChsZXQga2V5IGluIHNldFZhbHVlcykge1xuXHQgICAgICAgIHNldChWQUxVRVMsIGAke21vZGVsfS4ke2lkfS4ke2tleX1gLCBzZXRWYWx1ZXNba2V5XSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGdldChWQUxVRVMsIGAke21vZGVsfS4ke2lkfWAsIHt9KTtcblx0ICB9LFxuXHQgIHByZXNldChkZXRhaWxzKSB7XG5cdCAgICB0aGlzLmRlYnVnKFwiY2FjaGUucHJlc2V0XCIsIC4uLmFyZ3VtZW50cyk7XG5cdCAgICBjb25zdCB7IHByZXNldHMgPSBbXSB9ID0gdGhpcy52YWx1ZXMoZGV0YWlscyk7XG5cdCAgICBwcmVzZXRzLnB1c2goZGV0YWlscyk7XG5cdCAgICB0aGlzLnZhbHVlcyhkZXRhaWxzLCB7IHByZXNldHMgfSk7XG5cdCAgfSxcblx0ICBzZXQoZGV0YWlscykge1xuXHQgICAgdGhpcy5kZWJ1ZyhcImNhY2hlLnNldFwiLCAuLi5hcmd1bWVudHMpO1xuXHQgICAgbGV0IHsgbW9kZWwsIGlkLCBwYXRoLCB2YWx1ZSB9ID0gZGV0YWlscztcblx0ICAgIGxldCB7IGRhdGEgPSB7fSwgcmVjb3JkLCBwcmVzZXRzIH0gPSB0aGlzLnZhbHVlcyhkZXRhaWxzKTtcblx0ICAgIGlmIChpZCA9PT0gbnVsbCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAocmVjb3JkID09PSB2b2lkIDApIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHJlc2V0KGRldGFpbHMpO1xuXHQgICAgfVxuXHQgICAgZGF0YSA9IG1lcmdlKHJlY29yZCB8fCB7fSwgZGF0YSk7XG5cdCAgICBjb25zdCB7IHVzZUNhbWVsQ2FzZSB9ID0gZ2V0T3B0aW9ucygpO1xuXHQgICAgaWYgKHVzZUNhbWVsQ2FzZSAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgdmFsdWUgPSB0b0NhbWVsKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmIChwYXRoIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgICAgbGV0IHVwRGF0YSA9IF9fc3ByZWFkVmFsdWVzJDgoe30sIGRhdGEgfHwge30pO1xuXHQgICAgICBsZXQgdXBQYXRoID0gdXNlQ2FtZWxDYXNlID8gdG9DYW1lbFBhdGgocGF0aCkgOiBwYXRoO1xuXHQgICAgICBzZXQodXBEYXRhLCB1cFBhdGggfHwgXCJcIiwgdmFsdWUpO1xuXHQgICAgICBkYXRhID0gdXBEYXRhO1xuXHQgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgZGF0YSA9IGRhdGEgfHwge307XG5cdCAgICAgIGRhdGEgPSBtZXJnZShkYXRhLCB2YWx1ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkYXRhID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgICB0aGlzLnZhbHVlcyhkZXRhaWxzLCB7IGRhdGEgfSk7XG5cdCAgICB0cnkge1xuXHQgICAgICBjb25zdCBjYWNoZSA9IFZBTFVFU1ttb2RlbF1baWRdO1xuXHQgICAgICBpZiAoY2FjaGUgIT09IHZvaWQgMCkge1xuXHQgICAgICAgIGlmIChjYWNoZS5kYXRhICE9PSB2b2lkIDApIHtcblx0ICAgICAgICAgIGNhY2hlLmRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNhY2hlLmRhdGEpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNhY2hlLnJlY29yZCAhPT0gdm9pZCAwKSB7XG5cdCAgICAgICAgICBjYWNoZS5yZWNvcmQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNhY2hlLnJlY29yZCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXQobW9kZWwsIGlkKSB7XG5cdCAgICB0aGlzLmRlYnVnKFwiY2FjaGUuZ2V0XCIsIC4uLmFyZ3VtZW50cyk7XG5cdCAgICBjb25zdCB7IGRhdGEsIHJlY29yZFRpbWVyIH0gPSB0aGlzLnZhbHVlcyh7IG1vZGVsLCBpZCB9KTtcblx0ICAgIHRoaXMuZGVidWcoXCJjYWNoZS5nZXQ6ZGF0YStyZWNvcmRUaW1lclwiLCAuLi5hcmd1bWVudHMpO1xuXHQgICAgaWYgKHJlY29yZFRpbWVyKSB7XG5cdCAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgc2V0UmVjb3JkKHJlY29yZCwgZGV0YWlscykge1xuXHQgICAgdGhpcy5kZWJ1ZyhcImNhY2hlLnNldFJlY29yZFwiLCAuLi5hcmd1bWVudHMpO1xuXHQgICAgbGV0IHsgcmVjb3JkVGltZXIsIHByZXNldHMgfSA9IHRoaXMudmFsdWVzKGRldGFpbHMpO1xuXHQgICAgaWYgKHJlY29yZFRpbWVyKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dChyZWNvcmRUaW1lcik7XG5cdCAgICB9XG5cdCAgICByZWNvcmRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHQgICAgICB0aGlzLnZhbHVlcyhkZXRhaWxzLCB7IHJlY29yZDogdm9pZCAwLCByZWNvcmRUaW1lcjogdm9pZCAwIH0pO1xuXHQgICAgfSwgUkVDT1JEX1RJTUVPVVQpO1xuXHQgICAgdGhpcy52YWx1ZXMoZGV0YWlscywge1xuXHQgICAgICByZWNvcmQ6IHJlY29yZCAhPT0gdm9pZCAwID8gcmVjb3JkIDogbnVsbCxcblx0ICAgICAgcmVjb3JkVGltZXJcblx0ICAgIH0pO1xuXHQgICAgaWYgKHByZXNldHMpIHtcblx0ICAgICAgZm9yIChsZXQgcHJlc2V0IG9mIHByZXNldHMpIHtcblx0ICAgICAgICB0aGlzLnNldChwcmVzZXQpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMudmFsdWVzKGRldGFpbHMsIHsgcHJlc2V0czogdm9pZCAwIH0pO1xuXHQgICAgfVxuXHQgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXQoZGV0YWlscy5tb2RlbCwgZGV0YWlscy5pZCk7XG5cdCAgICByZXR1cm4gcmVzdWx0ICE9PSB2b2lkIDAgPyByZXN1bHQgOiByZWNvcmQ7XG5cdCAgfSxcblx0ICBhc3luYyBnZXRGZXRjaChtb2RlbCwgaWQsIGZldGNoKSB7XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcblx0ICAgICAgdGhpcy5kZWJ1ZyhcImNhY2hlLmdldEZldGNoXCIsIC4uLmFyZ3VtZW50cyk7XG5cdCAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQobW9kZWwsIGlkKTtcblx0ICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IGZldGNoKCk7XG5cdCAgICByZXR1cm4gdGhpcy5zZXRSZWNvcmQocmVjb3JkLCB7IG1vZGVsLCBpZCB9KTtcblx0ICB9LFxuXHQgIGNsZWFyKG1vZGVsID0gdm9pZCAwLCBpZCA9IHZvaWQgMCkge1xuXHQgICAgdGhpcy5kZWJ1ZyhcImNhY2hlLmNsZWFyXCIsIC4uLmFyZ3VtZW50cyk7XG5cdCAgICBpZiAobW9kZWwpIHtcblx0ICAgICAgaWYgKGlkKSB7XG5cdCAgICAgICAgc2V0KFZBTFVFUywgYCR7bW9kZWx9LiR7aWR9YCwgdm9pZCAwKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzZXQoVkFMVUVTLCBtb2RlbCwgdm9pZCAwKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgVkFMVUVTID0ge307XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIG1ldGhvZHMkYShyZXF1ZXN0KSB7XG5cdCAgY29uc3QgeyBnZXQsIGxpc3QgfSA9IGRlZmF1bHRNZXRob2RzKHJlcXVlc3QsIFwiL2F0dHJpYnV0ZXNcIiwgW1wibGlzdFwiLCBcImdldFwiXSk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGdldDogKGlkLCAuLi5hcmdzKSA9PiB7XG5cdCAgICAgIHJldHVybiBjYWNoZUFwaS5nZXRGZXRjaChcImF0dHJpYnV0ZXNcIiwgaWQsICgpID0+IGdldChpZCwgLi4uYXJncykpO1xuXHQgICAgfSxcblx0ICAgIGxpc3Rcblx0ICB9O1xuXHR9XG5cblx0dmFyIF9fZGVmUHJvcCQ3ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHR2YXIgX19kZWZQcm9wcyQ0ID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG5cdHZhciBfX2dldE93blByb3BEZXNjcyQ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cdHZhciBfX2dldE93blByb3BTeW1ib2xzJDcgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgX19oYXNPd25Qcm9wJDcgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgX19wcm9wSXNFbnVtJDcgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgX19kZWZOb3JtYWxQcm9wJDcgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDcob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xuXHR2YXIgX19zcHJlYWRWYWx1ZXMkNyA9IChhLCBiKSA9PiB7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuXHQgICAgaWYgKF9faGFzT3duUHJvcCQ3LmNhbGwoYiwgcHJvcCkpXG5cdCAgICAgIF9fZGVmTm9ybWFsUHJvcCQ3KGEsIHByb3AsIGJbcHJvcF0pO1xuXHQgIGlmIChfX2dldE93blByb3BTeW1ib2xzJDcpXG5cdCAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkNyhiKSkge1xuXHQgICAgICBpZiAoX19wcm9wSXNFbnVtJDcuY2FsbChiLCBwcm9wKSlcblx0ICAgICAgICBfX2RlZk5vcm1hbFByb3AkNyhhLCBwcm9wLCBiW3Byb3BdKTtcblx0ICAgIH1cblx0ICByZXR1cm4gYTtcblx0fTtcblx0dmFyIF9fc3ByZWFkUHJvcHMkNCA9IChhLCBiKSA9PiBfX2RlZlByb3BzJDQoYSwgX19nZXRPd25Qcm9wRGVzY3MkNChiKSk7XG5cdGxldCBPUFRJT05TO1xuXHRmdW5jdGlvbiBtZXRob2RzJDkocmVxdWVzdCwgb3B0KSB7XG5cdCAgT1BUSU9OUyA9IG9wdDtcblx0ICBjb25zdCB7IGdldDogZ2V0MiwgbGlzdCB9ID0gZGVmYXVsdE1ldGhvZHMocmVxdWVzdCwgXCIvcHJvZHVjdHNcIiwgW1wibGlzdFwiLCBcImdldFwiXSk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGdldDogKGlkLCAuLi5hcmdzKSA9PiB7XG5cdCAgICAgIHJldHVybiBjYWNoZUFwaS5nZXRGZXRjaChcInByb2R1Y3RzXCIsIGlkLCAoKSA9PiBnZXQyKGlkLCAuLi5hcmdzKSk7XG5cdCAgICB9LFxuXHQgICAgbGlzdCxcblx0ICAgIHZhcmlhdGlvbjogY2FsY3VsYXRlVmFyaWF0aW9uLFxuXHQgICAgY2F0ZWdvcmllczogZ2V0Q2F0ZWdvcmllcyxcblx0ICAgIGF0dHJpYnV0ZXM6IGdldEF0dHJpYnV0ZXMsXG5cdCAgICBwcmljZVJhbmdlOiBnZXRQcmljZVJhbmdlLFxuXHQgICAgZmlsdGVyczogZ2V0RmlsdGVycyxcblx0ICAgIGZpbHRlcmFibGVBdHRyaWJ1dGVGaWx0ZXJzOiAocHJvZHVjdHMsIG9wdGlvbnMpID0+IGdldEZpbHRlcmFibGVBdHRyaWJ1dGVGaWx0ZXJzKHJlcXVlc3QsIHByb2R1Y3RzLCBvcHRpb25zKVxuXHQgIH07XG5cdH1cblx0ZnVuY3Rpb24gZ2V0UHJvZHVjdE9wdGlvbkluZGV4KHByb2R1Y3QsIGZpbHRlciA9IHZvaWQgMCkge1xuXHQgIGlmICghcHJvZHVjdC5vcHRpb25zKSB7XG5cdCAgICByZXR1cm4ge307XG5cdCAgfVxuXHQgIGNvbnN0IHByb2R1Y3RPcHRpb25zID0gZmlsdGVyID8gcHJvZHVjdC5vcHRpb25zLmZpbHRlcihmaWx0ZXIpIDogcHJvZHVjdC5vcHRpb25zO1xuXHQgIHJldHVybiByZWR1Y2UkMShcblx0ICAgIHByb2R1Y3RPcHRpb25zLFxuXHQgICAgKGFjYywgb3ApID0+IHtcblx0ICAgICAgY29uc3QgdmFsdWVzID0gcmVkdWNlJDEoXG5cdCAgICAgICAgb3AudmFsdWVzLFxuXHQgICAgICAgIChhY2MyLCB2YWwpID0+IF9fc3ByZWFkUHJvcHMkNChfX3NwcmVhZFZhbHVlcyQ3KHt9LCBhY2MyKSwge1xuXHQgICAgICAgICAgW3ZhbC5pZF06IF9fc3ByZWFkUHJvcHMkNChfX3NwcmVhZFZhbHVlcyQ3KHt9LCB2YWwpLCB7IGlkOiB2YWwuaWQgfSksXG5cdCAgICAgICAgICBbdmFsLm5hbWVdOiBfX3NwcmVhZFByb3BzJDQoX19zcHJlYWRWYWx1ZXMkNyh7fSwgdmFsKSwgeyBpZDogdmFsLmlkIH0pXG5cdCAgICAgICAgfSksXG5cdCAgICAgICAge31cblx0ICAgICAgKTtcblx0ICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMkNChfX3NwcmVhZFZhbHVlcyQ3KHt9LCBhY2MpLCB7XG5cdCAgICAgICAgW29wLmlkXTogX19zcHJlYWRQcm9wcyQ0KF9fc3ByZWFkVmFsdWVzJDcoe30sIG9wKSwgeyB2YWx1ZXMgfSksXG5cdCAgICAgICAgW29wLm5hbWVdOiBfX3NwcmVhZFByb3BzJDQoX19zcHJlYWRWYWx1ZXMkNyh7fSwgb3ApLCB7IHZhbHVlcyB9KVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICB7fVxuXHQgICk7XG5cdH1cblx0ZnVuY3Rpb24gY2xlYW5Qcm9kdWN0T3B0aW9ucyhvcHRpb25zKSB7XG5cdCAgbGV0IHJlc3VsdCA9IG9wdGlvbnMgfHwgW107XG5cdCAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgIShvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXN1bHQgPSBbXTtcblx0ICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcblx0ICAgICAgcmVzdWx0LnB1c2goe1xuXHQgICAgICAgIGlkOiBrZXksXG5cdCAgICAgICAgdmFsdWU6IG9wdGlvbnNba2V5XVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICByZXR1cm4gcmVzdWx0Lm1hcCgob3ApID0+ICh7XG5cdCAgICAgIGlkOiBvcC5pZCB8fCBvcC5uYW1lLFxuXHQgICAgICB2YWx1ZTogb3AudmFsdWVcblx0ICAgIH0pKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBmaW5kVmFyaWFudFdpdGhPcHRpb25WYWx1ZUlkcyhwcm9kdWN0LCBpZHMpIHtcblx0ICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcblx0ICAgIGNvbnN0IHZhcmlhbnRzID0gcHJvZHVjdC52YXJpYW50cyAmJiBwcm9kdWN0LnZhcmlhbnRzLnJlc3VsdHM7XG5cdCAgICBpZiAodmFyaWFudHMubGVuZ3RoID4gMCkge1xuXHQgICAgICBmb3IgKGNvbnN0IHZhcmlhbnQgb2YgdmFyaWFudHMpIHtcblx0ICAgICAgICBjb25zdCB2YXJpYW50T2JqID0gdG9TbmFrZSh2YXJpYW50KTtcblx0ICAgICAgICBjb25zdCBtYXRjaGVkID0gaXNFcXVhbCh2YXJpYW50T2JqLm9wdGlvbl92YWx1ZV9pZHMuc29ydCgpLCBpZHMuc29ydCgpKTtcblx0ICAgICAgICBpZiAobWF0Y2hlZCkge1xuXHQgICAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cdGZ1bmN0aW9uIGNhbGN1bGF0ZVZhcmlhdGlvbihpbnB1dCwgb3B0aW9ucywgcHVyY2hhc2VPcHRpb24pIHtcblx0ICBjb25zdCBwcm9kdWN0ID0gT1BUSU9OUy51c2VDYW1lbENhc2UgPyB0b1NuYWtlKGlucHV0KSA6IGlucHV0O1xuXHQgIGNvbnN0IHB1cmNoYXNlT3AgPSBmaW5kUHVyY2hhc2VPcHRpb24ocHJvZHVjdCwgcHVyY2hhc2VPcHRpb24pO1xuXHQgIGNvbnN0IHZhcmlhdGlvbiA9IF9fc3ByZWFkUHJvcHMkNChfX3NwcmVhZFZhbHVlcyQ3KHt9LCBwcm9kdWN0KSwge1xuXHQgICAgcHJpY2U6IHB1cmNoYXNlT3AucHJpY2UgfHwgMCxcblx0ICAgIHNhbGVfcHJpY2U6IHB1cmNoYXNlT3Auc2FsZV9wcmljZSxcblx0ICAgIG9yaWdfcHJpY2U6IHB1cmNoYXNlT3Aub3JpZ19wcmljZSxcblx0ICAgIHN0b2NrX3N0YXR1czogcHJvZHVjdC5zdG9ja19zdGF0dXNcblx0ICB9KTtcblx0ICBsZXQgb3B0aW9uUHJpY2UgPSAwO1xuXHQgIGNvbnN0IHZhcmlhbnRPcHRpb25WYWx1ZUlkcyA9IFtdO1xuXHQgIGNvbnN0IGNsZWFuT3B0aW9ucyA9IGNsZWFuUHJvZHVjdE9wdGlvbnMob3B0aW9ucyk7XG5cdCAgY29uc3QgaW5kZXggPSBnZXRQcm9kdWN0T3B0aW9uSW5kZXgocHJvZHVjdCk7XG5cdCAgZm9yIChjb25zdCBvcHRpb24gb2YgY2xlYW5PcHRpb25zKSB7XG5cdCAgICBpZiAoaW5kZXhbb3B0aW9uLmlkXSAmJiBpbmRleFtvcHRpb24uaWRdLnZhbHVlc1tvcHRpb24udmFsdWVdKSB7XG5cdCAgICAgIGlmIChpbmRleFtvcHRpb24uaWRdLnZhcmlhbnQpIHtcblx0ICAgICAgICB2YXJpYW50T3B0aW9uVmFsdWVJZHMucHVzaChpbmRleFtvcHRpb24uaWRdLnZhbHVlc1tvcHRpb24udmFsdWVdLmlkKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBvcHRpb25QcmljZSArPSBpbmRleFtvcHRpb24uaWRdLnZhbHVlc1tvcHRpb24udmFsdWVdLnByaWNlIHx8IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKHZhcmlhbnRPcHRpb25WYWx1ZUlkcy5sZW5ndGggPiAwKSB7XG5cdCAgICBjb25zdCB2YXJpYW50ID0gZmluZFZhcmlhbnRXaXRoT3B0aW9uVmFsdWVJZHMoXG5cdCAgICAgIHByb2R1Y3QsXG5cdCAgICAgIHZhcmlhbnRPcHRpb25WYWx1ZUlkc1xuXHQgICAgKTtcblx0ICAgIGlmICh2YXJpYW50KSB7XG5cdCAgICAgIGxldCB2YXJpYW50UHVyY2hhc2VPcCA9IHB1cmNoYXNlT3A7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgdmFyaWFudFB1cmNoYXNlT3AgPSBmaW5kUHVyY2hhc2VPcHRpb24odmFyaWFudCwgcHVyY2hhc2VPcHRpb24pO1xuXHQgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgfVxuXHQgICAgICB2YXJpYXRpb24udmFyaWFudF9pZCA9IHZhcmlhbnQuaWQ7XG5cdCAgICAgIHZhcmlhdGlvbi5wcmljZSA9IHZhcmlhbnRQdXJjaGFzZU9wLnByaWNlIHx8IDA7XG5cdCAgICAgIHZhcmlhdGlvbi5zYWxlX3ByaWNlID0gdmFyaWFudFB1cmNoYXNlT3Auc2FsZV9wcmljZSB8fCBwdXJjaGFzZU9wLnNhbGVfcHJpY2U7XG5cdCAgICAgIHZhcmlhdGlvbi5vcmlnX3ByaWNlID0gdmFyaWFudFB1cmNoYXNlT3Aub3JpZ19wcmljZSB8fCBwdXJjaGFzZU9wLm9yaWdfcHJpY2U7XG5cdCAgICAgIHZhcmlhdGlvbi5zdG9ja19zdGF0dXMgPSB2YXJpYW50LnN0b2NrX3N0YXR1cztcblx0ICAgICAgdmFyaWF0aW9uLnN0b2NrX2xldmVsID0gdmFyaWFudC5zdG9ja19sZXZlbCB8fCAwO1xuXHQgICAgICB2YXJpYXRpb24uaW1hZ2VzID0gKHZhcmlhbnQuaW1hZ2VzICYmIHZhcmlhbnQuaW1hZ2VzLmxlbmd0aCA/IHZhcmlhbnQuaW1hZ2VzIDogcHJvZHVjdC5pbWFnZXMpIHx8IFtdO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAob3B0aW9uUHJpY2UgPiAwKSB7XG5cdCAgICB2YXJpYXRpb24ucHJpY2UgKz0gb3B0aW9uUHJpY2U7XG5cdCAgICBpZiAodmFyaWF0aW9uLnNhbGVfcHJpY2UpIHtcblx0ICAgICAgdmFyaWF0aW9uLnNhbGVfcHJpY2UgKz0gb3B0aW9uUHJpY2U7XG5cdCAgICB9XG5cdCAgICBpZiAodmFyaWF0aW9uLm9yaWdfcHJpY2UpIHtcblx0ICAgICAgdmFyaWF0aW9uLm9yaWdfcHJpY2UgKz0gb3B0aW9uUHJpY2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICh2YXJpYXRpb24uc2FsZV9wcmljZSA9PT0gdm9pZCAwKSB7XG5cdCAgICBkZWxldGUgdmFyaWF0aW9uLnNhbGVfcHJpY2U7XG5cdCAgfVxuXHQgIGlmICh2YXJpYXRpb24ub3JpZ19wcmljZSA9PT0gdm9pZCAwKSB7XG5cdCAgICBkZWxldGUgdmFyaWF0aW9uLm9yaWdfcHJpY2U7XG5cdCAgfVxuXHQgIHJldHVybiBPUFRJT05TLnVzZUNhbWVsQ2FzZSA/IHRvQ2FtZWwodmFyaWF0aW9uKSA6IHZhcmlhdGlvbjtcblx0fVxuXHRmdW5jdGlvbiBmaW5kUHVyY2hhc2VPcHRpb24ocHJvZHVjdCwgcHVyY2hhc2VPcHRpb24pIHtcblx0ICBjb25zdCBwbGFuID0gZ2V0KHB1cmNoYXNlT3B0aW9uLCBcInBsYW5faWRcIiwgZ2V0KHB1cmNoYXNlT3B0aW9uLCBcInBsYW5cIikpO1xuXHQgIGNvbnN0IHR5cGUgPSBnZXQoXG5cdCAgICBwdXJjaGFzZU9wdGlvbixcblx0ICAgIFwidHlwZVwiLFxuXHQgICAgdHlwZW9mIHB1cmNoYXNlT3B0aW9uID09PSBcInN0cmluZ1wiID8gcHVyY2hhc2VPcHRpb24gOiBwbGFuICE9PSB2b2lkIDAgPyBcInN1YnNjcmlwdGlvblwiIDogXCJzdGFuZGFyZFwiXG5cdCAgKTtcblx0ICBsZXQgb3B0aW9uID0gZ2V0KHByb2R1Y3QsIGBwdXJjaGFzZV9vcHRpb25zLiR7dHlwZX1gKTtcblx0ICBpZiAoIW9wdGlvbiAmJiB0eXBlICE9PSBcInN0YW5kYXJkXCIpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgYFByb2R1Y3QgcHVyY2hhc2Ugb3B0aW9uICcke3R5cGV9JyBub3QgZm91bmQgb3Igbm90IGFjdGl2ZWBcblx0ICAgICk7XG5cdCAgfVxuXHQgIGlmIChvcHRpb24pIHtcblx0ICAgIGlmIChvcHRpb24ucGxhbnMpIHtcblx0ICAgICAgaWYgKHBsYW4gIT09IHZvaWQgMCkge1xuXHQgICAgICAgIG9wdGlvbiA9IGZpbmQob3B0aW9uLnBsYW5zLCB7IGlkOiBwbGFuIH0pO1xuXHQgICAgICAgIGlmICghb3B0aW9uKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG5cdCAgICAgICAgICAgIGBTdWJzY3JpcHRpb24gcHVyY2hhc2UgcGxhbiAnJHtwbGFufScgbm90IGZvdW5kIG9yIG5vdCBhY3RpdmVgXG5cdCAgICAgICAgICApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBvcHRpb24gPSBvcHRpb24ucGxhbnNbMF07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBfX3NwcmVhZFByb3BzJDQoX19zcHJlYWRWYWx1ZXMkNyh7fSwgb3B0aW9uKSwge1xuXHQgICAgICBwcmljZTogdHlwZW9mIG9wdGlvbi5wcmljZSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbi5wcmljZSA6IHByb2R1Y3QucHJpY2UsXG5cdCAgICAgIHNhbGVfcHJpY2U6IHR5cGVvZiBvcHRpb24uc2FsZV9wcmljZSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbi5zYWxlX3ByaWNlIDogcHJvZHVjdC5zYWxlX3ByaWNlLFxuXHQgICAgICBvcmlnX3ByaWNlOiB0eXBlb2Ygb3B0aW9uLm9yaWdfcHJpY2UgPT09IFwibnVtYmVyXCIgPyBvcHRpb24ub3JpZ19wcmljZSA6IHByb2R1Y3Qub3JpZ19wcmljZVxuXHQgICAgfSk7XG5cdCAgfVxuXHQgIHJldHVybiB7XG5cdCAgICB0eXBlOiBcInN0YW5kYXJkXCIsXG5cdCAgICBwcmljZTogcHJvZHVjdC5wcmljZSxcblx0ICAgIHNhbGVfcHJpY2U6IHByb2R1Y3Quc2FsZV9wcmljZSxcblx0ICAgIG9yaWdfcHJpY2U6IHByb2R1Y3Qub3JpZ19wcmljZVxuXHQgIH07XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gZ2V0RmlsdGVyYWJsZUF0dHJpYnV0ZUZpbHRlcnMocmVxdWVzdCwgcHJvZHVjdHMsIG9wdGlvbnMpIHtcblx0ICBjb25zdCB7IHJlc3VsdHM6IGZpbHRlcmFibGVBdHRyaWJ1dGVzIH0gPSBhd2FpdCBtZXRob2RzJGEoXG5cdCAgICByZXF1ZXN0KS5saXN0KHtcblx0ICAgIGZpbHRlcmFibGU6IHRydWVcblx0ICB9KTtcblx0ICByZXR1cm4gZ2V0RmlsdGVycyhwcm9kdWN0cywgX19zcHJlYWRQcm9wcyQ0KF9fc3ByZWFkVmFsdWVzJDcoe30sIG9wdGlvbnMpLCB7IGZpbHRlcmFibGVBdHRyaWJ1dGVzIH0pKTtcblx0fVxuXHRmdW5jdGlvbiBnZXRGaWx0ZXJzKHByb2R1Y3RzLCBvcHRpb25zID0ge30pIHtcblx0ICBsZXQgYXR0cmlidXRlcyA9IChvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5hdHRyaWJ1dGVzID09PSB2b2lkIDApICYmIGdldEF0dHJpYnV0ZXMocHJvZHVjdHMpO1xuXHQgIGlmIChvcHRpb25zLmZpbHRlcmFibGVBdHRyaWJ1dGVzKSB7XG5cdCAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5maWx0ZXIoXG5cdCAgICAgIChwcm9kdWN0QXR0cikgPT4gb3B0aW9ucy5maWx0ZXJhYmxlQXR0cmlidXRlcy5maW5kKFxuXHQgICAgICAgIChmaWx0ZXJhYmxlQXR0cikgPT4gcHJvZHVjdEF0dHIuaWQgPT09IGZpbHRlcmFibGVBdHRyLmlkXG5cdCAgICAgIClcblx0ICAgICk7XG5cdCAgfVxuXHQgIGNvbnN0IGNhdGVnb3JpZXMgPSAob3B0aW9ucy5jYXRlZ29yaWVzIHx8IG9wdGlvbnMuY2F0ZWdvcmllcyA9PT0gdm9pZCAwKSAmJiBnZXRDYXRlZ29yaWVzKHByb2R1Y3RzKTtcblx0ICBjb25zdCBwcmljZVJhbmdlID0gKG9wdGlvbnMucHJpY2UgfHwgb3B0aW9ucy5wcmljZSA9PT0gdm9pZCAwKSAmJiBnZXRQcmljZVJhbmdlKHByb2R1Y3RzKTtcblx0ICBsZXQgZmlsdGVycyA9IFtdO1xuXHQgIGlmIChwcmljZVJhbmdlKSB7XG5cdCAgICBmaWx0ZXJzLnB1c2goe1xuXHQgICAgICBpZDogXCJwcmljZVwiLFxuXHQgICAgICBsYWJlbDogXCJQcmljZVwiLFxuXHQgICAgICB0eXBlOiBcInJhbmdlXCIsXG5cdCAgICAgIG9wdGlvbnM6IFtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJpY2VSYW5nZS5taW4sXG5cdCAgICAgICAgICBsYWJlbDogcHJpY2VSYW5nZS5taW5cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhbHVlOiBwcmljZVJhbmdlLm1heCxcblx0ICAgICAgICAgIGxhYmVsOiBwcmljZVJhbmdlLm1heFxuXHQgICAgICAgIH1cblx0ICAgICAgXSxcblx0ICAgICAgaW50ZXJ2YWw6IHByaWNlUmFuZ2UuaW50ZXJ2YWxcblx0ICAgIH0pO1xuXHQgIH1cblx0ICBpZiAoY2F0ZWdvcmllcyAmJiBjYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcblx0ICAgIGZpbHRlcnMucHVzaCh7XG5cdCAgICAgIGlkOiBcImNhdGVnb3J5XCIsXG5cdCAgICAgIGxhYmVsOiBcIkNhdGVnb3J5XCIsXG5cdCAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG5cdCAgICAgIG9wdGlvbnM6IGNhdGVnb3JpZXMubWFwKChjYXRlZ29yeSkgPT4gKHtcblx0ICAgICAgICB2YWx1ZTogY2F0ZWdvcnkuc2x1Zyxcblx0ICAgICAgICBsYWJlbDogY2F0ZWdvcnkubmFtZVxuXHQgICAgICB9KSlcblx0ICAgIH0pO1xuXHQgIH1cblx0ICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcblx0ICAgIGZpbHRlcnMgPSBbXG5cdCAgICAgIC4uLmZpbHRlcnMsXG5cdCAgICAgIC4uLnJlZHVjZSQxKFxuXHQgICAgICAgIGF0dHJpYnV0ZXMsXG5cdCAgICAgICAgKGFjYywgYXR0cikgPT4gW1xuXHQgICAgICAgICAgLi4uYWNjLFxuXHQgICAgICAgICAgLi4uYXR0ci5pZCAhPT0gXCJjYXRlZ29yeVwiICYmIGF0dHIuaWQgIT09IFwicHJpY2VcIiAmJiBhdHRyLnZhbHVlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGF0dHIudmFsdWVzLmxlbmd0aCA+IDAgPyBbXG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICBpZDogYXR0ci5pZCxcblx0ICAgICAgICAgICAgICBsYWJlbDogYXR0ci5uYW1lLFxuXHQgICAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG5cdCAgICAgICAgICAgICAgb3B0aW9uczogYXR0ci52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gKHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLFxuXHQgICAgICAgICAgICAgICAgbGFiZWw6IHZhbHVlXG5cdCAgICAgICAgICAgICAgfSkpXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIF0gOiBbXVxuXHQgICAgICAgIF0sXG5cdCAgICAgICAgW11cblx0ICAgICAgKVxuXHQgICAgXTtcblx0ICB9XG5cdCAgcmV0dXJuIGZpbHRlcnM7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0Q2F0ZWdvcmllcyhwcm9kdWN0cykge1xuXHQgIGNvbnN0IGNhdGVnb3JpZXMgPSBbXTtcblx0ICBjb25zdCBjb2xsZWN0aW9uID0gcHJvZHVjdHMgJiYgcHJvZHVjdHMucmVzdWx0cyB8fCAocHJvZHVjdHMuaWQgPyBbcHJvZHVjdHNdIDogcHJvZHVjdHMpO1xuXHQgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgIGZvciAobGV0IHByb2R1Y3Qgb2YgY29sbGVjdGlvbikge1xuXHQgICAgICBpZiAocHJvZHVjdC5jYXRlZ29yaWVzKSB7XG5cdCAgICAgICAgZm9yIChsZXQgY2F0ZWdvcnkgb2YgcHJvZHVjdC5jYXRlZ29yaWVzKSB7XG5cdCAgICAgICAgICBpZiAoIWNhdGVnb3J5KVxuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgIGxldCBleCA9IGZpbmQoY2F0ZWdvcmllcywgeyBpZDogY2F0ZWdvcnkuaWQgfSk7XG5cdCAgICAgICAgICBpZiAoIWV4KSB7XG5cdCAgICAgICAgICAgIGNhdGVnb3JpZXMucHVzaChjYXRlZ29yeSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBjYXRlZ29yaWVzO1xuXHR9XG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMocHJvZHVjdHMpIHtcblx0ICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG5cdCAgY29uc3QgY29sbGVjdGlvbiA9IHByb2R1Y3RzICYmIHByb2R1Y3RzLnJlc3VsdHMgfHwgKHByb2R1Y3RzLmlkID8gW3Byb2R1Y3RzXSA6IHByb2R1Y3RzKTtcblx0ICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICBmb3IgKGxldCBwcm9kdWN0IG9mIGNvbGxlY3Rpb24pIHtcblx0ICAgICAgaWYgKHByb2R1Y3QuYXR0cmlidXRlcykge1xuXHQgICAgICAgIGZvciAobGV0IGlkIGluIHByb2R1Y3QuYXR0cmlidXRlcykge1xuXHQgICAgICAgICAgaWYgKCFwcm9kdWN0LmF0dHJpYnV0ZXNbaWRdKVxuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvZHVjdC5hdHRyaWJ1dGVzW2lkXS52YWx1ZTtcblx0ICAgICAgICAgIGxldCBhdHRyID0gZmluZChhdHRyaWJ1dGVzLCB7IGlkOiBzbmFrZUNhc2UoaWQpIH0pO1xuXHQgICAgICAgICAgaWYgKGF0dHIpIHtcblx0ICAgICAgICAgICAgYXR0ci52YWx1ZXMgPSB1bmlxKFtcblx0ICAgICAgICAgICAgICAuLi5hdHRyLnZhbHVlcyxcblx0ICAgICAgICAgICAgICAuLi52YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUgOiBbdmFsdWVdXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKF9fc3ByZWFkUHJvcHMkNChfX3NwcmVhZFZhbHVlcyQ3KHt9LCBwcm9kdWN0LmF0dHJpYnV0ZXNbaWRdKSwge1xuXHQgICAgICAgICAgICAgIHZhbHVlOiB2b2lkIDAsXG5cdCAgICAgICAgICAgICAgdmFsdWVzOiBbLi4udmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHZhbHVlIDogW3ZhbHVlXV1cblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gYXR0cmlidXRlcztcblx0fVxuXHRmdW5jdGlvbiBnZXRQcmljZVJhbmdlKHByb2R1Y3RzKSB7XG5cdCAgbGV0IG1pbjtcblx0ICBsZXQgbWF4O1xuXHQgIGxldCBpbnRlcnZhbDtcblx0ICBjb25zdCBjb2xsZWN0aW9uID0gcHJvZHVjdHMgJiYgcHJvZHVjdHMucmVzdWx0cyB8fCAocHJvZHVjdHMuaWQgPyBbcHJvZHVjdHNdIDogcHJvZHVjdHMpO1xuXHQgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgIGZvciAobGV0IHByb2R1Y3Qgb2YgY29sbGVjdGlvbikge1xuXHQgICAgICBpZiAobWF4ID09PSB2b2lkIDAgfHwgcHJvZHVjdC5wcmljZSA+IG1heCkge1xuXHQgICAgICAgIG1heCA9IE1hdGguY2VpbChwcm9kdWN0LnByaWNlKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAobWluID09PSB2b2lkIDAgfHwgcHJvZHVjdC5wcmljZSA8IG1pbikge1xuXHQgICAgICAgIG1pbiA9IE1hdGguZmxvb3IocHJvZHVjdC5wcmljZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKG1pbiA9PT0gbWF4KSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cdCAgaW50ZXJ2YWwgPSBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAxMCkgfHwgMTtcblx0ICBpZiAoaW50ZXJ2YWwgPiAxZTMpIHtcblx0ICAgIGludGVydmFsID0gMWUzO1xuXHQgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPiAxMDApIHtcblx0ICAgIGludGVydmFsID0gMTAwO1xuXHQgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPiAxMCkge1xuXHQgICAgaW50ZXJ2YWwgPSAxMDtcblx0ICB9XG5cdCAgaWYgKG1heCAlIGludGVydmFsID4gMCkge1xuXHQgICAgbWF4ID0gaW50ZXJ2YWwgKyBtYXggLSBtYXggJSBpbnRlcnZhbDtcblx0ICB9XG5cdCAgaWYgKG1pbiAlIGludGVydmFsID4gMCkge1xuXHQgICAgbWluID0gbWluIC0gbWluICUgaW50ZXJ2YWw7XG5cdCAgfVxuXHQgIHdoaWxlICgobWF4IC0gbWluKSAvIGludGVydmFsICUgMSA+IDApIHtcblx0ICAgIG1heCsrO1xuXHQgIH1cblx0ICByZXR1cm4ge1xuXHQgICAgbWluLFxuXHQgICAgbWF4LFxuXHQgICAgaW50ZXJ2YWxcblx0ICB9O1xuXHR9XG5cblx0dmFyIF9fZGVmUHJvcCQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHR2YXIgX19kZWZQcm9wcyQzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG5cdHZhciBfX2dldE93blByb3BEZXNjcyQzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cdHZhciBfX2dldE93blByb3BTeW1ib2xzJDYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgX19oYXNPd25Qcm9wJDYgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgX19wcm9wSXNFbnVtJDYgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgX19kZWZOb3JtYWxQcm9wJDYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDYob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xuXHR2YXIgX19zcHJlYWRWYWx1ZXMkNiA9IChhLCBiKSA9PiB7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuXHQgICAgaWYgKF9faGFzT3duUHJvcCQ2LmNhbGwoYiwgcHJvcCkpXG5cdCAgICAgIF9fZGVmTm9ybWFsUHJvcCQ2KGEsIHByb3AsIGJbcHJvcF0pO1xuXHQgIGlmIChfX2dldE93blByb3BTeW1ib2xzJDYpXG5cdCAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkNihiKSkge1xuXHQgICAgICBpZiAoX19wcm9wSXNFbnVtJDYuY2FsbChiLCBwcm9wKSlcblx0ICAgICAgICBfX2RlZk5vcm1hbFByb3AkNihhLCBwcm9wLCBiW3Byb3BdKTtcblx0ICAgIH1cblx0ICByZXR1cm4gYTtcblx0fTtcblx0dmFyIF9fc3ByZWFkUHJvcHMkMyA9IChhLCBiKSA9PiBfX2RlZlByb3BzJDMoYSwgX19nZXRPd25Qcm9wRGVzY3MkMyhiKSk7XG5cdGZ1bmN0aW9uIG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHN0YXRlOiBudWxsLFxuXHQgICAgb3JkZXI6IG51bGwsXG5cdCAgICBzZXR0aW5nczogbnVsbCxcblx0ICAgIHJlcXVlc3RlZDogZmFsc2UsXG5cdCAgICBwZW5kaW5nUmVxdWVzdHM6IFtdLFxuXHQgICAgY2FjaGVDbGVhcjogbnVsbCxcblx0ICAgIGFzeW5jIHJlcXVlc3RTdGF0ZUNoYW5nZShtZXRob2QsIHVybCwgaWQsIGRhdGEpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0YXRlU3luYyhhc3luYyAoKSA9PiB7XG5cdCAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdChtZXRob2QsIHVybCwgaWQsIGRhdGEpO1xuXHQgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmVycm9ycykge1xuXHQgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IHJlc3VsdDtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICBhc3luYyByZXF1ZXN0U3RhdGVTeW5jKGhhbmRsZXIpIHtcblx0ICAgICAgaWYgKHRoaXMuc3RhdGUpIHtcblx0ICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlcigpO1xuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdGVkKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdCAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5wdXNoKHsgaGFuZGxlciwgcmVzb2x2ZSB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLnJlcXVlc3RlZCA9IHRydWU7XG5cdCAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoKTtcblx0ICAgICAgdGhpcy5yZXF1ZXN0ZWQgPSBmYWxzZTtcblx0ICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBjb25zdCB7IGhhbmRsZXI6IGhhbmRsZXIyLCByZXNvbHZlIH0gPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5zaGlmdCgpO1xuXHQgICAgICAgIHJlc29sdmUoaGFuZGxlcjIoKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH0sXG5cdCAgICBnZXQoKSB7XG5cdCAgICAgIGxldCBkYXRhO1xuXHQgICAgICBpZiAodGhpcy5jYWNoZUNsZWFyKSB7XG5cdCAgICAgICAgdGhpcy5jYWNoZUNsZWFyID0gbnVsbDtcblx0ICAgICAgICBkYXRhID0geyAkY2FjaGU6IGZhbHNlIH07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0YXRlQ2hhbmdlKFwiZ2V0XCIsIFwiL2NhcnRcIiwgdm9pZCAwLCBkYXRhKTtcblx0ICAgIH0sXG5cdCAgICBjbGVhckNhY2hlKCkge1xuXHQgICAgICB0aGlzLmNhY2hlQ2xlYXIgPSB0cnVlO1xuXHQgICAgfSxcblx0ICAgIGdldEl0ZW1EYXRhKGl0ZW0sIGRhdGEgPSB7fSkge1xuXHQgICAgICBsZXQgcmVzdWx0ID0gY2xvbmVEZWVwKGl0ZW0pO1xuXHQgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICByZXN1bHQgPSBfX3NwcmVhZFByb3BzJDMoX19zcHJlYWRWYWx1ZXMkNih7fSwgZGF0YSB8fCB7fSksIHtcblx0ICAgICAgICAgIHByb2R1Y3RfaWQ6IGl0ZW1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5vcHRpb25zKSB7XG5cdCAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBjbGVhblByb2R1Y3RPcHRpb25zKHJlc3VsdC5vcHRpb25zKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfSxcblx0ICAgIGFkZEl0ZW0oaXRlbSwgZGF0YSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RhdGVDaGFuZ2UoXG5cdCAgICAgICAgXCJwb3N0XCIsXG5cdCAgICAgICAgXCIvY2FydC9pdGVtc1wiLFxuXHQgICAgICAgIHRoaXMuZ2V0SXRlbURhdGEoaXRlbSwgZGF0YSlcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgICB1cGRhdGVJdGVtKGlkLCBpdGVtKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcblx0ICAgICAgICBcInB1dFwiLFxuXHQgICAgICAgIGAvY2FydC9pdGVtcy8ke2lkfWAsXG5cdCAgICAgICAgdGhpcy5nZXRJdGVtRGF0YShpdGVtKVxuXHQgICAgICApO1xuXHQgICAgfSxcblx0ICAgIHNldEl0ZW1zKGlucHV0KSB7XG5cdCAgICAgIGxldCBpdGVtcyA9IGlucHV0O1xuXHQgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubWFwKSB7XG5cdCAgICAgICAgaXRlbXMgPSBpdGVtcy5tYXAodGhpcy5nZXRJdGVtRGF0YSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0YXRlQ2hhbmdlKFwicHV0XCIsIFwiL2NhcnQvaXRlbXNcIiwgaXRlbXMpO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZUl0ZW0oaWQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0YXRlQ2hhbmdlKFwiZGVsZXRlXCIsIGAvY2FydC9pdGVtcy8ke2lkfWApO1xuXHQgICAgfSxcblx0ICAgIHJlY292ZXIoY2hlY2tvdXRJZCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RhdGVDaGFuZ2UoXCJwdXRcIiwgYC9jYXJ0L3JlY292ZXIvJHtjaGVja291dElkfWApO1xuXHQgICAgfSxcblx0ICAgIHVwZGF0ZShpbnB1dCkge1xuXHQgICAgICBsZXQgZGF0YSA9IGlucHV0O1xuXHQgICAgICBpZiAoZGF0YS5pdGVtcyAmJiBkYXRhLml0ZW1zLm1hcCkge1xuXHQgICAgICAgIGRhdGEgPSBfX3NwcmVhZFByb3BzJDMoX19zcHJlYWRWYWx1ZXMkNih7fSwgZGF0YSksIHtcblx0ICAgICAgICAgIGl0ZW1zOiBkYXRhLml0ZW1zLm1hcCh0aGlzLmdldEl0ZW1EYXRhKVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcInB1dFwiLCBgL2NhcnRgLCBkYXRhKTtcblx0ICAgIH0sXG5cdCAgICBhcHBseUNvdXBvbihjb2RlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcInB1dFwiLCBcIi9jYXJ0L2NvdXBvblwiLCB7IGNvZGUgfSk7XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlQ291cG9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RhdGVDaGFuZ2UoXCJkZWxldGVcIiwgXCIvY2FydC9jb3Vwb25cIik7XG5cdCAgICB9LFxuXHQgICAgYXBwbHlHaWZ0Y2FyZChjb2RlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcInBvc3RcIiwgXCIvY2FydC9naWZ0Y2FyZHNcIiwgeyBjb2RlIH0pO1xuXHQgICAgfSxcblx0ICAgIHJlbW92ZUdpZnRjYXJkKGlkKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcImRlbGV0ZVwiLCBgL2NhcnQvZ2lmdGNhcmRzLyR7aWR9YCk7XG5cdCAgICB9LFxuXHQgICAgYXN5bmMgZ2V0U2hpcHBpbmdSYXRlcygpIHtcblx0ICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0U3RhdGVDaGFuZ2UoXCJnZXRcIiwgXCIvY2FydC9zaGlwbWVudC1yYXRpbmdcIik7XG5cdCAgICAgIHJldHVybiB0aGlzLnN0YXRlW29wdGlvbnMudXNlQ2FtZWxDYXNlID8gXCJzaGlwbWVudFJhdGluZ1wiIDogXCJzaGlwbWVudF9yYXRpbmdcIl07XG5cdCAgICB9LFxuXHQgICAgYXN5bmMgc3VibWl0T3JkZXIoKSB7XG5cdCAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QoXCJwb3N0XCIsIFwiL2NhcnQvb3JkZXJcIik7XG5cdCAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblx0ICAgICAgdGhpcy5vcmRlciA9IHJlc3VsdDtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH0sXG5cdCAgICBhc3luYyBnZXRPcmRlcihjaGVja291dElkID0gdm9pZCAwKSB7XG5cdCAgICAgIGxldCByZXN1bHQ7XG5cdCAgICAgIGlmIChjaGVja291dElkKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdChcImdldFwiLCBgL2NhcnQvb3JkZXJgLCB7XG5cdCAgICAgICAgICBjaGVja291dF9pZDogY2hlY2tvdXRJZFxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QoXCJnZXRcIiwgYC9jYXJ0L29yZGVyYCk7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5vcmRlciA9IHJlc3VsdDtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH0sXG5cdCAgICBhc3luYyBnZXRTZXR0aW5ncygpIHtcblx0ICAgICAgdGhpcy5zZXR0aW5ncyA9IGF3YWl0IHJlcXVlc3QoXCJnZXRcIiwgXCIvY2FydC9zZXR0aW5nc1wiKTtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3M7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ldGhvZHMkNyhyZXF1ZXN0KSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHN0YXRlOiBudWxsLFxuXHQgICAgYXN5bmMgcmVxdWVzdFN0YXRlQ2hhbmdlKG1ldGhvZCwgdXJsLCBpZCwgZGF0YSkge1xuXHQgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0KG1ldGhvZCwgdXJsLCBpZCwgZGF0YSk7XG5cdCAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmVycm9ycykge1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPSByZXN1bHQ7XG5cdCAgICB9LFxuXHQgICAgZ2V0KHF1ZXJ5KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcImdldFwiLCBcIi9hY2NvdW50XCIsIHF1ZXJ5KTtcblx0ICAgIH0sXG5cdCAgICBjcmVhdGUoZGF0YSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RhdGVDaGFuZ2UoXCJwb3N0XCIsIFwiL2FjY291bnRcIiwgZGF0YSk7XG5cdCAgICB9LFxuXHQgICAgdXBkYXRlKGRhdGEpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0YXRlQ2hhbmdlKFwicHV0XCIsIFwiL2FjY291bnRcIiwgZGF0YSk7XG5cdCAgICB9LFxuXHQgICAgbG9naW4oZW1haWwsIHBhc3N3b3JkKSB7XG5cdCAgICAgIGlmIChwYXNzd29yZCAmJiBwYXNzd29yZC5wYXNzd29yZF90b2tlbikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcInBvc3RcIiwgXCIvYWNjb3VudC9sb2dpblwiLCB7XG5cdCAgICAgICAgICBlbWFpbCxcblx0ICAgICAgICAgIHBhc3N3b3JkX3Rva2VuOiBwYXNzd29yZC5wYXNzd29yZF90b2tlblxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdGF0ZUNoYW5nZShcInBvc3RcIiwgXCIvYWNjb3VudC9sb2dpblwiLCB7XG5cdCAgICAgICAgZW1haWwsXG5cdCAgICAgICAgcGFzc3dvcmRcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgbG9nb3V0KCkge1xuXHQgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJwb3N0XCIsIFwiL2FjY291bnQvbG9nb3V0XCIpO1xuXHQgICAgfSxcblx0ICAgIHJlY292ZXIoZGF0YSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcInBvc3RcIiwgXCIvYWNjb3VudC9yZWNvdmVyXCIsIGRhdGEpO1xuXHQgICAgfSxcblx0ICAgIGxpc3RBZGRyZXNzZXMocXVlcnkpIHtcblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJnZXRcIiwgXCIvYWNjb3VudC9hZGRyZXNzZXNcIiwgcXVlcnkpO1xuXHQgICAgfSxcblx0ICAgIGNyZWF0ZUFkZHJlc3MoZGF0YSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcInBvc3RcIiwgXCIvYWNjb3VudC9hZGRyZXNzZXNcIiwgZGF0YSk7XG5cdCAgICB9LFxuXHQgICAgdXBkYXRlQWRkcmVzcyhpZCwgZGF0YSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcInB1dFwiLCBgL2FjY291bnQvYWRkcmVzc2VzLyR7aWR9YCwgZGF0YSk7XG5cdCAgICB9LFxuXHQgICAgZGVsZXRlQWRkcmVzcyhpZCkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcImRlbGV0ZVwiLCBgL2FjY291bnQvYWRkcmVzc2VzLyR7aWR9YCk7XG5cdCAgICB9LFxuXHQgICAgbGlzdENhcmRzKHF1ZXJ5KSB7XG5cdCAgICAgIHJldHVybiByZXF1ZXN0KFwiZ2V0XCIsIFwiL2FjY291bnQvY2FyZHNcIiwgcXVlcnkpO1xuXHQgICAgfSxcblx0ICAgIGNyZWF0ZUNhcmQoZGF0YSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcInBvc3RcIiwgXCIvYWNjb3VudC9jYXJkc1wiLCBkYXRhKTtcblx0ICAgIH0sXG5cdCAgICB1cGRhdGVDYXJkKGlkLCBkYXRhKSB7XG5cdCAgICAgIHJldHVybiByZXF1ZXN0KFwicHV0XCIsIGAvYWNjb3VudC9jYXJkcy8ke2lkfWAsIGRhdGEpO1xuXHQgICAgfSxcblx0ICAgIGRlbGV0ZUNhcmQoaWQpIHtcblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJkZWxldGVcIiwgYC9hY2NvdW50L2NhcmRzLyR7aWR9YCk7XG5cdCAgICB9LFxuXHQgICAgbGlzdE9yZGVycyhxdWVyeSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcImdldFwiLCBgL2FjY291bnQvb3JkZXJzYCwgcXVlcnkpO1xuXHQgICAgfSxcblx0ICAgIGdldE9yZGVyKGlkKSB7XG5cdCAgICAgIHJldHVybiByZXF1ZXN0KFwiZ2V0XCIsIGAvYWNjb3VudC9vcmRlcnMvJHtpZH1gKTtcblx0ICAgIH0sXG5cdCAgICBnZXRBZGRyZXNzZXMocXVlcnkpIHtcblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJnZXRcIiwgXCIvYWNjb3VudC9hZGRyZXNzZXNcIiwgcXVlcnkpO1xuXHQgICAgfSxcblx0ICAgIGdldENhcmRzKHF1ZXJ5KSB7XG5cdCAgICAgIHJldHVybiByZXF1ZXN0KFwiZ2V0XCIsIFwiL2FjY291bnQvY2FyZHNcIiwgcXVlcnkpO1xuXHQgICAgfSxcblx0ICAgIGdldE9yZGVycyhxdWVyeSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcImdldFwiLCBgL2FjY291bnQvb3JkZXJzYCwgcXVlcnkpO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBtZXRob2RzJDYocmVxdWVzdCkge1xuXHQgIGNvbnN0IHsgZ2V0LCBsaXN0IH0gPSBkZWZhdWx0TWV0aG9kcyhyZXF1ZXN0LCBcIi9jYXRlZ29yaWVzXCIsIFtcImxpc3RcIiwgXCJnZXRcIl0pO1xuXHQgIHJldHVybiB7XG5cdCAgICBnZXQ6IChpZCwgLi4uYXJncykgPT4ge1xuXHQgICAgICByZXR1cm4gY2FjaGVBcGkuZ2V0RmV0Y2goXCJjYXRlZ29yaWVzXCIsIGlkLCAoKSA9PiBnZXQoaWQsIC4uLmFyZ3MpKTtcblx0ICAgIH0sXG5cdCAgICBsaXN0XG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ldGhvZHMkNShyZXF1ZXN0KSB7XG5cdCAgY29uc3QgeyBnZXQsIGxpc3QgfSA9IGRlZmF1bHRNZXRob2RzKHJlcXVlc3QsIFwiL3N1YnNjcmlwdGlvbnNcIiwgW1xuXHQgICAgXCJsaXN0XCIsXG5cdCAgICBcImdldFwiXG5cdCAgXSk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGdldDogKGlkLCAuLi5hcmdzKSA9PiB7XG5cdCAgICAgIHJldHVybiBjYWNoZUFwaS5nZXRGZXRjaChcInN1YnNjcmlwdGlvbnNcIiwgaWQsICgpID0+IGdldChpZCwgLi4uYXJncykpO1xuXHQgICAgfSxcblx0ICAgIGxpc3QsXG5cdCAgICBnZXRDbGVhbkRhdGEoZGF0YSkge1xuXHQgICAgICBpZiAoZGF0YSAmJiBkYXRhLm9wdGlvbnMpIHtcblx0ICAgICAgICBkYXRhLm9wdGlvbnMgPSBjbGVhblByb2R1Y3RPcHRpb25zKGRhdGEub3B0aW9ucyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGRhdGEuaXRlbXMgJiYgZGF0YS5pdGVtcy5tYXApIHtcblx0ICAgICAgICBkYXRhLml0ZW1zID0gZGF0YS5pdGVtcy5tYXAoKGl0ZW0pID0+IHtcblx0ICAgICAgICAgIGlmIChpdGVtLm9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgaXRlbS5vcHRpb25zID0gY2xlYW5Qcm9kdWN0T3B0aW9ucyhpdGVtLm9wdGlvbnMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICB9LFxuXHQgICAgY3JlYXRlKGRhdGEpIHtcblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJwb3N0XCIsIFwiL3N1YnNjcmlwdGlvbnNcIiwgdGhpcy5nZXRDbGVhbkRhdGEoZGF0YSkpO1xuXHQgICAgfSxcblx0ICAgIHVwZGF0ZShpZCwgZGF0YSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcInB1dFwiLCBgL3N1YnNjcmlwdGlvbnMvJHtpZH1gLCB0aGlzLmdldENsZWFuRGF0YShkYXRhKSk7XG5cdCAgICB9LFxuXHQgICAgYWRkSXRlbShpZCwgaXRlbSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcblx0ICAgICAgICBcInBvc3RcIixcblx0ICAgICAgICBgL3N1YnNjcmlwdGlvbnMvJHtpZH0vaXRlbXNgLFxuXHQgICAgICAgIHRoaXMuZ2V0Q2xlYW5EYXRhKGl0ZW0pXG5cdCAgICAgICk7XG5cdCAgICB9LFxuXHQgICAgc2V0SXRlbXMoaWQsIGl0ZW1zKSB7XG5cdCAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5tYXApIHtcblx0ICAgICAgICBpdGVtcyA9IGl0ZW1zLm1hcCh0aGlzLmdldENsZWFuRGF0YSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJwdXRcIiwgYC9zdWJzY3JpcHRpb25zLyR7aWR9L2l0ZW1zYCwgaXRlbXMpO1xuXHQgICAgfSxcblx0ICAgIHVwZGF0ZUl0ZW0oaWQsIGl0ZW1JZCwgaXRlbSkge1xuXHQgICAgICByZXR1cm4gcmVxdWVzdChcblx0ICAgICAgICBcInB1dFwiLFxuXHQgICAgICAgIGAvc3Vic2NyaXB0aW9ucy8ke2lkfS9pdGVtcy8ke2l0ZW1JZH1gLFxuXHQgICAgICAgIHRoaXMuZ2V0Q2xlYW5EYXRhKGl0ZW0pXG5cdCAgICAgICk7XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlSXRlbShpZCwgaXRlbUlkKSB7XG5cdCAgICAgIHJldHVybiByZXF1ZXN0KFwiZGVsZXRlXCIsIGAvc3Vic2NyaXB0aW9ucy8ke2lkfS9pdGVtcy8ke2l0ZW1JZH1gKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0dmFyIF9fZGVmUHJvcCQ1ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHR2YXIgX19nZXRPd25Qcm9wU3ltYm9scyQ1ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblx0dmFyIF9faGFzT3duUHJvcCQ1ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIF9fcHJvcElzRW51bSQ1ID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIF9fZGVmTm9ybWFsUHJvcCQ1ID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQ1KG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcblx0dmFyIF9fc3ByZWFkVmFsdWVzJDUgPSAoYSwgYikgPT4ge1xuXHQgIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcblx0ICAgIGlmIChfX2hhc093blByb3AkNS5jYWxsKGIsIHByb3ApKVxuXHQgICAgICBfX2RlZk5vcm1hbFByb3AkNShhLCBwcm9wLCBiW3Byb3BdKTtcblx0ICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQ1KVxuXHQgICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDUoYikpIHtcblx0ICAgICAgaWYgKF9fcHJvcElzRW51bSQ1LmNhbGwoYiwgcHJvcCkpXG5cdCAgICAgICAgX19kZWZOb3JtYWxQcm9wJDUoYSwgcHJvcCwgYltwcm9wXSk7XG5cdCAgICB9XG5cdCAgcmV0dXJuIGE7XG5cdH07XG5cdGZ1bmN0aW9uIG1ldGhvZHMkNChyZXF1ZXN0LCBvcHQpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgZ2V0OiAodHlwZSwgaWQsIHF1ZXJ5KSA9PiB7XG5cdCAgICAgIHJldHVybiBjYWNoZUFwaS5nZXRGZXRjaChcblx0ICAgICAgICBgY29udGVudF8ke3R5cGV9YCxcblx0ICAgICAgICBpZCxcblx0ICAgICAgICAoKSA9PiByZXF1ZXN0KFwiZ2V0XCIsIGAvY29udGVudC8ke3R5cGV9YCwgaWQsIF9fc3ByZWFkVmFsdWVzJDUoe1xuXHQgICAgICAgICAgJHByZXZpZXc6IG9wdC5wcmV2aWV3Q29udGVudFxuXHQgICAgICAgIH0sIHF1ZXJ5IHx8IHt9KSlcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgICBsaXN0OiAodHlwZSwgcXVlcnkpID0+IHJlcXVlc3QoXCJnZXRcIiwgYC9jb250ZW50LyR7dHlwZX1gLCB2b2lkIDAsIHF1ZXJ5KVxuXHQgIH07XG5cdH1cblxuXHR2YXIgX19kZWZQcm9wJDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdHZhciBfX2RlZlByb3BzJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0dmFyIF9fZ2V0T3duUHJvcERlc2NzJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcblx0dmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMkNCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdHZhciBfX2hhc093blByb3AkNCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBfX3Byb3BJc0VudW0kNCA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBfX2RlZk5vcm1hbFByb3AkNCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG5cdHZhciBfX3NwcmVhZFZhbHVlcyQ0ID0gKGEsIGIpID0+IHtcblx0ICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG5cdCAgICBpZiAoX19oYXNPd25Qcm9wJDQuY2FsbChiLCBwcm9wKSlcblx0ICAgICAgX19kZWZOb3JtYWxQcm9wJDQoYSwgcHJvcCwgYltwcm9wXSk7XG5cdCAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkNClcblx0ICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQ0KGIpKSB7XG5cdCAgICAgIGlmIChfX3Byb3BJc0VudW0kNC5jYWxsKGIsIHByb3ApKVxuXHQgICAgICAgIF9fZGVmTm9ybWFsUHJvcCQ0KGEsIHByb3AsIGJbcHJvcF0pO1xuXHQgICAgfVxuXHQgIHJldHVybiBhO1xuXHR9O1xuXHR2YXIgX19zcHJlYWRQcm9wcyQyID0gKGEsIGIpID0+IF9fZGVmUHJvcHMkMihhLCBfX2dldE93blByb3BEZXNjcyQyKGIpKTtcblx0ZnVuY3Rpb24gbWV0aG9kcyQzKHJlcXVlc3QsIG9wdCkge1xuXHQgIHJldHVybiB7XG5cdCAgICBzdGF0ZTogbnVsbCxcblx0ICAgIG1lbnVTdGF0ZTogbnVsbCxcblx0ICAgIHBheW1lbnRTdGF0ZTogbnVsbCxcblx0ICAgIHN1YnNjcmlwdGlvblN0YXRlOiBudWxsLFxuXHQgICAgc2Vzc2lvblN0YXRlOiBudWxsLFxuXHQgICAgbG9jYWxpemVkU3RhdGU6IHt9LFxuXHQgICAgcmVmcmVzaCgpIHtcblx0ICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cdCAgICAgIHRoaXMubWVudVN0YXRlID0gbnVsbDtcblx0ICAgICAgdGhpcy5wYXltZW50U3RhdGUgPSBudWxsO1xuXHQgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlID0gbnVsbDtcblx0ICAgICAgdGhpcy5zZXNzaW9uU3RhdGUgPSBudWxsO1xuXHQgICAgICB0aGlzLmxvY2FsaXplZFN0YXRlID0ge307XG5cdCAgICAgIHJldHVybiB0aGlzLmdldCgpO1xuXHQgICAgfSxcblx0ICAgIGdldFN0YXRlKHVyaSwgc3RhdGVOYW1lLCB7IGlkID0gdm9pZCAwLCBkZWYgPSB2b2lkIDAsIHJlZnJlc2ggPSBmYWxzZSB9ID0ge30pIHtcblx0ICAgICAgaWYgKCF0aGlzW3N0YXRlTmFtZV0gfHwgcmVmcmVzaCkge1xuXHQgICAgICAgIHRoaXNbc3RhdGVOYW1lXSA9IHJlcXVlc3QoXCJnZXRcIiwgdXJpKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpc1tzdGF0ZU5hbWVdICYmIHR5cGVvZiB0aGlzW3N0YXRlTmFtZV0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXNbc3RhdGVOYW1lXS50aGVuKChzdGF0ZSkgPT4ge1xuXHQgICAgICAgICAgdGhpc1tzdGF0ZU5hbWVdID0gc3RhdGU7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2NhbGl6ZWRTdGF0ZShzdGF0ZU5hbWUsIGlkLCBkZWYpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLmdldExvY2FsaXplZFN0YXRlKHN0YXRlTmFtZSwgaWQsIGRlZik7XG5cdCAgICB9LFxuXHQgICAgZ2V0TG9jYWxpemVkU3RhdGUoc3RhdGVOYW1lLCBpZCwgZGVmKSB7XG5cdCAgICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuZ2V0Q3VycmVudExvY2FsZSgpO1xuXHQgICAgICBjb25zdCBscyA9IHRoaXMubG9jYWxpemVkU3RhdGU7XG5cdCAgICAgIGlmIChscy5jb2RlICE9PSBsb2NhbGUpIHtcblx0ICAgICAgICBscy5jb2RlID0gbG9jYWxlO1xuXHQgICAgICAgIGRlbGV0ZSBsc1tsb2NhbGVdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghbHNbbG9jYWxlXSkge1xuXHQgICAgICAgIGxzW2xvY2FsZV0gPSB7fTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWxzW2xvY2FsZV1bc3RhdGVOYW1lXSkge1xuXHQgICAgICAgIGxzW2xvY2FsZV1bc3RhdGVOYW1lXSA9IHRoaXMuZGVjb2RlTG9jYWxlKHRoaXNbc3RhdGVOYW1lXSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGlkID8gZ2V0KGxzW2xvY2FsZV1bc3RhdGVOYW1lXSwgaWQsIGRlZikgOiBsc1tsb2NhbGVdW3N0YXRlTmFtZV07XG5cdCAgICB9LFxuXHQgICAgZmluZFN0YXRlKHVyaSwgc3RhdGVOYW1lLCB7IHdoZXJlID0gdm9pZCAwLCBkZWYgPSB2b2lkIDAgfSA9IHt9KSB7XG5cdCAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSh1cmksIHN0YXRlTmFtZSk7XG5cdCAgICAgIGlmIChzdGF0ZSAmJiB0eXBlb2Ygc3RhdGUudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0YXRlLnRoZW4oKHN0YXRlMikgPT4gZmluZChzdGF0ZTIsIHdoZXJlKSB8fCBkZWYpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBmaW5kKHN0YXRlLCB3aGVyZSkgfHwgZGVmO1xuXHQgICAgfSxcblx0ICAgIGdldChpZCA9IHZvaWQgMCwgZGVmID0gdm9pZCAwKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKFwiL3NldHRpbmdzXCIsIFwic3RhdGVcIiwgeyBpZCwgZGVmIH0pO1xuXHQgICAgfSxcblx0ICAgIGdldEN1cnJlbnRMb2NhbGUoKSB7XG5cdCAgICAgIHJldHVybiBvcHQuYXBpLmxvY2FsZS5zZWxlY3RlZCgpO1xuXHQgICAgfSxcblx0ICAgIGdldFN0b3JlTG9jYWxlKCkge1xuXHQgICAgICByZXR1cm4gZ2V0KHRoaXMuc3RhdGUsIFwic3RvcmUubG9jYWxlXCIpO1xuXHQgICAgfSxcblx0ICAgIGdldFN0b3JlTG9jYWxlcygpIHtcblx0ICAgICAgcmV0dXJuIGdldCh0aGlzLnN0YXRlLCBcInN0b3JlLmxvY2FsZXNcIik7XG5cdCAgICB9LFxuXHQgICAgc2V0KHsgbW9kZWwsIHBhdGgsIHZhbHVlIH0pIHtcblx0ICAgICAgY29uc3QgbG9jYWxlID0gdGhpcy5nZXRDdXJyZW50TG9jYWxlKCk7XG5cdCAgICAgIGNvbnN0IHN0YXRlTmFtZSA9IG1vZGVsID8gYCR7bW9kZWwucmVwbGFjZSgvcyQvLCBcIlwiKX1TdGF0ZWAgOiBcInN0YXRlXCI7XG5cdCAgICAgIGNvbnN0IHsgdXNlQ2FtZWxDYXNlIH0gPSBvcHQ7XG5cdCAgICAgIGxldCBtZXJnZURhdGEgPSB7fTtcblx0ICAgICAgaWYgKHBhdGgpXG5cdCAgICAgICAgc2V0KG1lcmdlRGF0YSwgcGF0aCwgdmFsdWUpO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgbWVyZ2VEYXRhID0gdmFsdWU7XG5cdCAgICAgIGlmICh1c2VDYW1lbENhc2UpIHtcblx0ICAgICAgICBtZXJnZURhdGEgPSB0b0NhbWVsKG1lcmdlRGF0YSk7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpc1tzdGF0ZU5hbWVdID0gbWVyZ2UodGhpc1tzdGF0ZU5hbWVdIHx8IHt9LCBtZXJnZURhdGEpO1xuXHQgICAgICBpZiAodGhpcy5sb2NhbGl6ZWRTdGF0ZVtsb2NhbGVdKSB7XG5cdCAgICAgICAgdGhpcy5sb2NhbGl6ZWRTdGF0ZVtsb2NhbGVdW3N0YXRlTmFtZV0gPSB0aGlzLmRlY29kZUxvY2FsZShcblx0ICAgICAgICAgIHRoaXNbc3RhdGVOYW1lXVxuXHQgICAgICAgICk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBtZW51cyhpZCA9IHZvaWQgMCwgZGVmID0gdm9pZCAwKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmZpbmRTdGF0ZShcIi9zZXR0aW5ncy9tZW51c1wiLCBcIm1lbnVTdGF0ZVwiLCB7XG5cdCAgICAgICAgd2hlcmU6IHsgaWQgfSxcblx0ICAgICAgICBkZWZcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgcGF5bWVudHMoaWQgPSB2b2lkIDAsIGRlZiA9IHZvaWQgMCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZShcIi9zZXR0aW5ncy9wYXltZW50c1wiLCBcInBheW1lbnRTdGF0ZVwiLCB7IGlkLCBkZWYgfSk7XG5cdCAgICB9LFxuXHQgICAgc3Vic2NyaXB0aW9ucyhpZCA9IHZvaWQgMCwgZGVmID0gdm9pZCAwKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKFwiL3NldHRpbmdzL3N1YnNjcmlwdGlvbnNcIiwgXCJzdWJzY3JpcHRpb25TdGF0ZVwiLCB7XG5cdCAgICAgICAgaWQsXG5cdCAgICAgICAgZGVmXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIHNlc3Npb24oaWQgPSB2b2lkIDAsIGRlZiA9IHZvaWQgMCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZShcIi9zZXNzaW9uXCIsIFwic2Vzc2lvblN0YXRlXCIsIHsgaWQsIGRlZiB9KTtcblx0ICAgIH0sXG5cdCAgICBkZWNvZGVMb2NhbGUodmFsdWVzKSB7XG5cdCAgICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuZ2V0Q3VycmVudExvY2FsZSgpO1xuXHQgICAgICBpZiAoIXZhbHVlcyB8fCB0eXBlb2YgdmFsdWVzICE9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlcztcblx0ICAgICAgfVxuXHQgICAgICBsZXQgY29uZmlncyA9IHRoaXMuZ2V0U3RvcmVMb2NhbGVzKCk7XG5cdCAgICAgIGlmIChjb25maWdzKSB7XG5cdCAgICAgICAgY29uZmlncyA9IGNvbmZpZ3MucmVkdWNlKFxuXHQgICAgICAgICAgKGFjYywgY29uZmlnKSA9PiBfX3NwcmVhZFByb3BzJDIoX19zcHJlYWRWYWx1ZXMkNCh7fSwgYWNjKSwge1xuXHQgICAgICAgICAgICBbY29uZmlnLmNvZGVdOiBjb25maWdcblx0ICAgICAgICAgIH0pLFxuXHQgICAgICAgICAge31cblx0ICAgICAgICApO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNvbmZpZ3MgPSB7fTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZGVjb2RlTG9jYWxlT2JqZWN0cyhjbG9uZURlZXAodmFsdWVzKSwgbG9jYWxlLCBjb25maWdzLCBvcHQpO1xuXHQgICAgfSxcblx0ICAgIGFzeW5jIGxvYWQoKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgY29uc3QgeyBzZXR0aW5ncywgbWVudXMsIHBheW1lbnRzLCBzdWJzY3JpcHRpb25zLCBzZXNzaW9uIH0gPSBhd2FpdCByZXF1ZXN0KFwiZ2V0XCIsIFwiL3NldHRpbmdzL2FsbFwiKTtcblx0ICAgICAgICB0aGlzLmxvY2FsaXplZFN0YXRlID0ge307XG5cdCAgICAgICAgdGhpcy5zZXQoe1xuXHQgICAgICAgICAgdmFsdWU6IHNldHRpbmdzXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5zZXQoe1xuXHQgICAgICAgICAgbW9kZWw6IFwibWVudXNcIixcblx0ICAgICAgICAgIHZhbHVlOiBtZW51c1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuc2V0KHtcblx0ICAgICAgICAgIG1vZGVsOiBcInBheW1lbnRzXCIsXG5cdCAgICAgICAgICB2YWx1ZTogcGF5bWVudHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLnNldCh7XG5cdCAgICAgICAgICBtb2RlbDogXCJzdWJzY3JpcHRpb25zXCIsXG5cdCAgICAgICAgICB2YWx1ZTogc3Vic2NyaXB0aW9uc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuc2V0KHtcblx0ICAgICAgICAgIG1vZGVsOiBcInNlc3Npb25cIixcblx0ICAgICAgICAgIHZhbHVlOiBzZXNzaW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN3ZWxsOiB1bmFibGUgdG8gbG9hZGluZyBzZXR0aW5ncyAoJHtlcnJ9KWApO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXHRmdW5jdGlvbiBkZWNvZGVMb2NhbGVPYmplY3RzKHZhbHVlcywgbG9jYWxlLCBjb25maWdzLCBvcHQpIHtcblx0ICBpZiAoaXNPYmplY3QodmFsdWVzKSkge1xuXHQgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG5cdCAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuXHQgICAgICBpZiAoa2V5ID09PSBcIiRsb2NhbGVcIikge1xuXHQgICAgICAgIGRlY29kZUxvY2FsZVZhbHVlKGxvY2FsZSwgdmFsdWVzLCBrZXksIGNvbmZpZ3MsIG9wdCk7XG5cdCAgICAgICAgZGVsZXRlIHZhbHVlcy4kbG9jYWxlO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh2YWx1ZXNba2V5XSAhPT0gdm9pZCAwKSB7XG5cdCAgICAgICAgdmFsdWVzW2tleV0gPSBkZWNvZGVMb2NhbGVPYmplY3RzKHZhbHVlc1trZXldLCBsb2NhbGUsIGNvbmZpZ3MsIG9wdCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGVsc2UgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YWx1ZXNbaV0gPSBkZWNvZGVMb2NhbGVPYmplY3RzKHZhbHVlc1tpXSwgbG9jYWxlLCBjb25maWdzLCBvcHQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdmFsdWVzO1xuXHR9XG5cdGZ1bmN0aW9uIGRlY29kZUxvY2FsZVZhbHVlKGxvY2FsZSwgdmFsdWVzLCBrZXksIGNvbmZpZ3MsIG9wdCkge1xuXHQgIGlmICghbG9jYWxlIHx8ICFpc09iamVjdCh2YWx1ZXNba2V5XSkpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgbGV0IHJldHVybkxvY2FsZUtleTtcblx0ICBsZXQgcmV0dXJuTG9jYWxlQ29uZmlnO1xuXHQgIGNvbnN0IGxvY2FsZUtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXNba2V5XSk7XG5cdCAgZm9yIChsZXQgbG9jYWxlS2V5IG9mIGxvY2FsZUtleXMpIHtcblx0ICAgIGNvbnN0IHNob3J0S2V5ID0gbG9jYWxlS2V5LnJlcGxhY2UoL1xcLS4rJC8sIFwiXCIpO1xuXHQgICAgY29uc3QgdHJhbnNmb3JtZWRMb2NhbGUgPSBvcHQudXNlQ2FtZWxDYXNlID8gY2FtZWxDYXNlKGxvY2FsZSkgOiBsb2NhbGU7XG5cdCAgICBpZiAobG9jYWxlS2V5ID09PSBsb2NhbGUgfHwgbG9jYWxlS2V5ID09PSB0cmFuc2Zvcm1lZExvY2FsZSB8fCBzaG9ydEtleSA9PT0gdHJhbnNmb3JtZWRMb2NhbGUpIHtcblx0ICAgICAgcmV0dXJuTG9jYWxlS2V5ID0gbG9jYWxlO1xuXHQgICAgICByZXR1cm5Mb2NhbGVDb25maWcgPSBjb25maWdzW2xvY2FsZV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICghcmV0dXJuTG9jYWxlS2V5ICYmIGlzT2JqZWN0KGNvbmZpZ3MpKSB7XG5cdCAgICBjb25zdCBsb2NhbGVLZXlzMiA9IE9iamVjdC5rZXlzKGNvbmZpZ3MpO1xuXHQgICAgZm9yIChsZXQgbG9jYWxlS2V5IG9mIGxvY2FsZUtleXMyKSB7XG5cdCAgICAgIGNvbnN0IHNob3J0S2V5ID0gbG9jYWxlS2V5LnJlcGxhY2UoL1xcLS4rJC8sIFwiXCIpO1xuXHQgICAgICBpZiAobG9jYWxlS2V5ID09PSBsb2NhbGUgfHwgc2hvcnRLZXkgPT09IGxvY2FsZSkge1xuXHQgICAgICAgIHJldHVybkxvY2FsZUtleSA9IGxvY2FsZUtleTtcblx0ICAgICAgICByZXR1cm5Mb2NhbGVDb25maWcgPSBjb25maWdzW2xvY2FsZUtleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgbGV0IGZhbGxiYWNrS2V5cztcblx0ICBsZXQgZmFsbGJhY2tWYWx1ZXMgPSB7fTtcblx0ICBpZiAocmV0dXJuTG9jYWxlQ29uZmlnKSB7XG5cdCAgICBsZXQgZmFsbGJhY2tLZXkgPSByZXR1cm5Mb2NhbGVDb25maWcuZmFsbGJhY2s7XG5cdCAgICBjb25zdCBvcmlnRmFsbGJhY2tLZXkgPSBmYWxsYmFja0tleTtcblx0ICAgIHdoaWxlIChmYWxsYmFja0tleSkge1xuXHQgICAgICBmYWxsYmFja0tleXMgPSBmYWxsYmFja0tleXMgfHwgW107XG5cdCAgICAgIGZhbGxiYWNrS2V5cy5wdXNoKGZhbGxiYWNrS2V5KTtcblx0ICAgICAgZmFsbGJhY2tWYWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyQ0KF9fc3ByZWFkVmFsdWVzJDQoe30sIHZhbHVlc1trZXldW2ZhbGxiYWNrS2V5XSB8fCB7fSksIGZhbGxiYWNrVmFsdWVzKTtcblx0ICAgICAgZmFsbGJhY2tLZXkgPSBjb25maWdzW2ZhbGxiYWNrS2V5XSAmJiBjb25maWdzW2ZhbGxiYWNrS2V5XS5mYWxsYmFjaztcblx0ICAgICAgaWYgKG9yaWdGYWxsYmFja0tleSA9PT0gZmFsbGJhY2tLZXkpIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICBsZXQgbG9jYWxlVmFsdWVzID0gX19zcHJlYWRWYWx1ZXMkNChfX3NwcmVhZFZhbHVlcyQ0KHt9LCBmYWxsYmFja1ZhbHVlcyksIHZhbHVlc1trZXldW3JldHVybkxvY2FsZUtleV0gfHwge30pO1xuXHQgIGNvbnN0IHZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsZVZhbHVlcyk7XG5cdCAgZm9yIChsZXQgdmFsdWVLZXkgb2YgdmFsdWVLZXlzKSB7XG5cdCAgICBjb25zdCBoYXNWYWx1ZSA9IGxvY2FsZVZhbHVlc1t2YWx1ZUtleV0gIT09IG51bGwgJiYgbG9jYWxlVmFsdWVzW3ZhbHVlS2V5XSAhPT0gXCJcIjtcblx0ICAgIGxldCBzaG91bGRGYWxsYmFjayA9IGZhbGxiYWNrS2V5cyAmJiAhaGFzVmFsdWU7XG5cdCAgICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcblx0ICAgICAgZm9yIChsZXQgZmFsbGJhY2tLZXkgb2YgZmFsbGJhY2tLZXlzKSB7XG5cdCAgICAgICAgc2hvdWxkRmFsbGJhY2sgPSAhdmFsdWVzW2tleV1bZmFsbGJhY2tLZXldIHx8IHZhbHVlc1trZXldW2ZhbGxiYWNrS2V5XVt2YWx1ZUtleV0gPT09IG51bGwgfHwgdmFsdWVzW2tleV1bZmFsbGJhY2tLZXldW3ZhbHVlS2V5XSA9PT0gXCJcIjtcblx0ICAgICAgICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcblx0ICAgICAgICAgIGlmIChmYWxsYmFja0tleSA9PT0gXCJub25lXCIpIHtcblx0ICAgICAgICAgICAgdmFsdWVzW3ZhbHVlS2V5XSA9IG51bGw7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhbHVlc1t2YWx1ZUtleV0gPSB2YWx1ZXNba2V5XVtmYWxsYmFja0tleV1bdmFsdWVLZXldO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoaGFzVmFsdWUpIHtcblx0ICAgICAgICB2YWx1ZXNbdmFsdWVLZXldID0gbG9jYWxlVmFsdWVzW3ZhbHVlS2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2Vcblx0ICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuXHQgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG5cdCAqXG5cdCAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG5cdCAqIC8vID0+ICdmb29iYXInXG5cdCAqXG5cdCAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcblx0ICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuXHQgKi9cblx0ZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuXHQgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3Jcblx0ICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG5cdCAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG5cdCAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcblx0ICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG5cdCAgfVxuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG5cdCAgfVxuXHQgIHJldHVybiBhY2N1bXVsYXRvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuXHQgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuXHQgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcblx0ICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG5cdCAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdCAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuXHQgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBvYmplY3Q7XG5cdCAgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuXHQgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cblx0ICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgKi9cblx0dmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG5cdCAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuXHQgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuXHQgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gY29sbGVjdGlvbjtcblx0ICAgIH1cblx0ICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcblx0ICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcblx0ICAgIH1cblx0ICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0ICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuXHQgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG5cdCAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuXHQgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29sbGVjdGlvbjtcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cblx0ICovXG5cdHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuXHQgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2Zcblx0ICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG5cdCAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG5cdCAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuXHQgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG5cdCAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG5cdCAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcblx0ICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuXHQgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG5cdCAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuXHQgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgKlxuXHQgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2Vcblx0ICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cblx0ICpcblx0ICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG5cdCAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuXHQgKiBhbmQgYHNvcnRCeWBcblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG5cdCAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuXHQgKiAgIHJldHVybiBzdW0gKyBuO1xuXHQgKiB9LCAwKTtcblx0ICogLy8gPT4gM1xuXHQgKlxuXHQgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG5cdCAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcblx0ICogICByZXR1cm4gcmVzdWx0O1xuXHQgKiB9LCB7fSk7XG5cdCAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICovXG5cdGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcblx0ICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG5cdCAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG5cdCAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlKSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuXHR9XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG5cdCAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuXHQgKlxuXHQgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcblx0ICogcHJvcGVydGllcy5cblx0ICpcblx0ICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG5cdCAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cblx0ICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzRW1wdHkobnVsbCk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0VtcHR5KHRydWUpO1xuXHQgKiAvLyA9PiB0cnVlXG5cdCAqXG5cdCAqIF8uaXNFbXB0eSgxKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICpcblx0ICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuXHQgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuXHQgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuXHQgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcblx0ICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuXHQgIH1cblx0ICB2YXIgdGFnID0gZ2V0VGFnJDEodmFsdWUpO1xuXHQgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcblx0ICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcblx0ICB9XG5cdCAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuXHQgIH1cblx0ICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0ICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG5cdCAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuXHQgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuXHQgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcblx0ICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgKlxuXHQgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2Vcblx0ICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG5cdCAqXG5cdCAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuXHQgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuXHQgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcblx0ICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuXHQgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcblx0ICogICByZXR1cm4gbiAqIG47XG5cdCAqIH1cblx0ICpcblx0ICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuXHQgKiAvLyA9PiBbMTYsIDY0XVxuXHQgKlxuXHQgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG5cdCAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG5cdCAqXG5cdCAqIHZhciB1c2VycyA9IFtcblx0ICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcblx0ICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cblx0ICogXTtcblx0ICpcblx0ICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG5cdCAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuXHQgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuXHQgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcblx0ICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUpKTtcblx0fVxuXG5cdHZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0dmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMkMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdHZhciBfX2hhc093blByb3AkMyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBfX3Byb3BJc0VudW0kMyA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG5cdHZhciBfX3NwcmVhZFZhbHVlcyQzID0gKGEsIGIpID0+IHtcblx0ICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG5cdCAgICBpZiAoX19oYXNPd25Qcm9wJDMuY2FsbChiLCBwcm9wKSlcblx0ICAgICAgX19kZWZOb3JtYWxQcm9wJDMoYSwgcHJvcCwgYltwcm9wXSk7XG5cdCAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMylcblx0ICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQzKGIpKSB7XG5cdCAgICAgIGlmIChfX3Byb3BJc0VudW0kMy5jYWxsKGIsIHByb3ApKVxuXHQgICAgICAgIF9fZGVmTm9ybWFsUHJvcCQzKGEsIHByb3AsIGJbcHJvcF0pO1xuXHQgICAgfVxuXHQgIHJldHVybiBhO1xuXHR9O1xuXHRjb25zdCBhZGRyZXNzRmllbGRzTWFwJDEgPSB7XG5cdCAgY2l0eTogXCJjaXR5XCIsXG5cdCAgY291bnRyeTogXCJjb3VudHJ5XCIsXG5cdCAgbGluZTE6IFwiYWRkcmVzczFcIixcblx0ICBsaW5lMjogXCJhZGRyZXNzMlwiLFxuXHQgIHBvc3RhbF9jb2RlOiBcInppcFwiLFxuXHQgIHN0YXRlOiBcInN0YXRlXCJcblx0fTtcblx0Y29uc3QgYmlsbGluZ0ZpZWxkc01hcCA9IHtcblx0ICBuYW1lOiBcIm5hbWVcIixcblx0ICBwaG9uZTogXCJwaG9uZVwiXG5cdH07XG5cdGZ1bmN0aW9uIG1hcFZhbHVlcyhmaWVsZHNNYXAsIGRhdGEpIHtcblx0ICBjb25zdCByZXN1bHQgPSB7fTtcblx0ICBmb3IgKGNvbnN0IFtkZXN0aW5hdGlvbktleSwgc291cmNlS2V5XSBvZiBPYmplY3QuZW50cmllcyhmaWVsZHNNYXApKSB7XG5cdCAgICBjb25zdCB2YWx1ZSA9IGRhdGFbc291cmNlS2V5XTtcblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICByZXN1bHRbZGVzdGluYXRpb25LZXldID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0QmlsbGluZ0RldGFpbHMoY2FydCkge1xuXHQgIGNvbnN0IGRldGFpbHMgPSBfX3NwcmVhZFZhbHVlcyQzKHt9LCBtYXBWYWx1ZXMoYmlsbGluZ0ZpZWxkc01hcCwgY2FydC5iaWxsaW5nKSk7XG5cdCAgaWYgKGNhcnQuYWNjb3VudCAmJiBjYXJ0LmFjY291bnQuZW1haWwpIHtcblx0ICAgIGRldGFpbHMuZW1haWwgPSBjYXJ0LmFjY291bnQuZW1haWw7XG5cdCAgfVxuXHQgIGNvbnN0IGFkZHJlc3MgPSBtYXBWYWx1ZXMoYWRkcmVzc0ZpZWxkc01hcCQxLCBjYXJ0LmJpbGxpbmcpO1xuXHQgIGlmICghaXNFbXB0eShhZGRyZXNzKSkge1xuXHQgICAgZGV0YWlscy5hZGRyZXNzID0gYWRkcmVzcztcblx0ICB9XG5cdCAgcmV0dXJuIGRldGFpbHM7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2xhcm5hSXRlbXMoY2FydCkge1xuXHQgIGNvbnN0IGN1cnJlbmN5ID0gdG9Mb3dlcihnZXQoY2FydCwgXCJjdXJyZW5jeVwiLCBcImV1clwiKSk7XG5cdCAgY29uc3QgaXRlbXMgPSBtYXAoY2FydC5pdGVtcywgKGl0ZW0pID0+ICh7XG5cdCAgICB0eXBlOiBcInNrdVwiLFxuXHQgICAgZGVzY3JpcHRpb246IGl0ZW0ucHJvZHVjdC5uYW1lLFxuXHQgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXG5cdCAgICBjdXJyZW5jeSxcblx0ICAgIGFtb3VudDogTWF0aC5yb3VuZCh0b051bWJlcihpdGVtLnByaWNlX3RvdGFsIC0gaXRlbS5kaXNjb3VudF90b3RhbCkgKiAxMDApXG5cdCAgfSkpO1xuXHQgIGNvbnN0IHRheCA9IGdldChjYXJ0LCBcInRheF9pbmNsdWRlZF90b3RhbFwiKTtcblx0ICBpZiAodGF4KSB7XG5cdCAgICBpdGVtcy5wdXNoKHtcblx0ICAgICAgdHlwZTogXCJ0YXhcIixcblx0ICAgICAgZGVzY3JpcHRpb246IFwiVGF4ZXNcIixcblx0ICAgICAgY3VycmVuY3ksXG5cdCAgICAgIGFtb3VudDogTWF0aC5yb3VuZCh0b051bWJlcih0YXgpICogMTAwKVxuXHQgICAgfSk7XG5cdCAgfVxuXHQgIGNvbnN0IHNoaXBwaW5nID0gZ2V0KGNhcnQsIFwic2hpcHBpbmdcIiwge30pO1xuXHQgIGNvbnN0IHNoaXBwaW5nVG90YWwgPSBnZXQoY2FydCwgXCJzaGlwbWVudF90b3RhbFwiLCB7fSk7XG5cdCAgaWYgKHNoaXBwaW5nLnByaWNlKSB7XG5cdCAgICBpdGVtcy5wdXNoKHtcblx0ICAgICAgdHlwZTogXCJzaGlwcGluZ1wiLFxuXHQgICAgICBkZXNjcmlwdGlvbjogc2hpcHBpbmcuc2VydmljZV9uYW1lLFxuXHQgICAgICBjdXJyZW5jeSxcblx0ICAgICAgYW1vdW50OiBNYXRoLnJvdW5kKHRvTnVtYmVyKHNoaXBwaW5nVG90YWwpICogMTAwKVxuXHQgICAgfSk7XG5cdCAgfVxuXHQgIHJldHVybiBpdGVtcztcblx0fVxuXHRmdW5jdGlvbiBzZXRLbGFybmFCaWxsaW5nU2hpcHBpbmcoc291cmNlLCBkYXRhKSB7XG5cdCAgY29uc3Qgc2hpcHBpbmdOYW1lRmllbGRzTWFwID0ge1xuXHQgICAgc2hpcHBpbmdfZmlyc3RfbmFtZTogXCJmaXJzdF9uYW1lXCIsXG5cdCAgICBzaGlwcGluZ19sYXN0X25hbWU6IFwibGFzdF9uYW1lXCJcblx0ICB9O1xuXHQgIGNvbnN0IHNoaXBwaW5nRmllbGRzTWFwID0ge1xuXHQgICAgcGhvbmU6IFwicGhvbmVcIlxuXHQgIH07XG5cdCAgY29uc3QgYmlsbGluZ05hbWVGaWVsZHNNYXAgPSB7XG5cdCAgICBmaXJzdF9uYW1lOiBcImZpcnN0X25hbWVcIixcblx0ICAgIGxhc3RfbmFtZTogXCJsYXN0X25hbWVcIlxuXHQgIH07XG5cdCAgY29uc3QgYmlsbGluZ0ZpZWxkc01hcDIgPSB7XG5cdCAgICBlbWFpbDogXCJlbWFpbFwiXG5cdCAgfTtcblx0ICBjb25zdCBmaWxsVmFsdWVzID0gKGZpZWxkc01hcCwgZGF0YTIpID0+IHJlZHVjZShcblx0ICAgIGZpZWxkc01hcCxcblx0ICAgIChhY2MsIHNyY0tleSwgZGVzdEtleSkgPT4ge1xuXHQgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEyW3NyY0tleV07XG5cdCAgICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICAgIGFjY1tkZXN0S2V5XSA9IHZhbHVlO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhY2M7XG5cdCAgICB9LFxuXHQgICAge31cblx0ICApO1xuXHQgIHNvdXJjZS5rbGFybmEgPSBfX3NwcmVhZFZhbHVlcyQzKF9fc3ByZWFkVmFsdWVzJDMoe30sIHNvdXJjZS5rbGFybmEpLCBmaWxsVmFsdWVzKHNoaXBwaW5nTmFtZUZpZWxkc01hcCwgZGF0YS5zaGlwcGluZykpO1xuXHQgIGNvbnN0IHNoaXBwaW5nID0gZmlsbFZhbHVlcyhzaGlwcGluZ0ZpZWxkc01hcCwgZGF0YS5zaGlwcGluZyk7XG5cdCAgY29uc3Qgc2hpcHBpbmdBZGRyZXNzID0gZmlsbFZhbHVlcyhhZGRyZXNzRmllbGRzTWFwJDEsIGRhdGEuc2hpcHBpbmcpO1xuXHQgIGlmIChzaGlwcGluZyB8fCBzaGlwcGluZ0FkZHJlc3MpIHtcblx0ICAgIHNvdXJjZS5zb3VyY2Vfb3JkZXIuc2hpcHBpbmcgPSBfX3NwcmVhZFZhbHVlcyQzKF9fc3ByZWFkVmFsdWVzJDMoe30sIHNoaXBwaW5nID8gc2hpcHBpbmcgOiB7fSksIHNoaXBwaW5nQWRkcmVzcyA/IHsgYWRkcmVzczogc2hpcHBpbmdBZGRyZXNzIH0gOiB7fSk7XG5cdCAgfVxuXHQgIHNvdXJjZS5rbGFybmEgPSBfX3NwcmVhZFZhbHVlcyQzKF9fc3ByZWFkVmFsdWVzJDMoe30sIHNvdXJjZS5rbGFybmEpLCBmaWxsVmFsdWVzKFxuXHQgICAgYmlsbGluZ05hbWVGaWVsZHNNYXAsXG5cdCAgICBkYXRhLmJpbGxpbmcgfHwgZ2V0KGRhdGEsIFwiYWNjb3VudC5iaWxsaW5nXCIpIHx8IGRhdGEuc2hpcHBpbmdcblx0ICApKTtcblx0ICBjb25zdCBiaWxsaW5nID0gZmlsbFZhbHVlcyhiaWxsaW5nRmllbGRzTWFwMiwgZGF0YS5hY2NvdW50KTtcblx0ICBjb25zdCBiaWxsaW5nQWRkcmVzcyA9IGZpbGxWYWx1ZXMoXG5cdCAgICBhZGRyZXNzRmllbGRzTWFwJDEsXG5cdCAgICBkYXRhLmJpbGxpbmcgfHwgZ2V0KGRhdGEsIFwiYWNjb3VudC5iaWxsaW5nXCIpIHx8IGRhdGEuc2hpcHBpbmdcblx0ICApO1xuXHQgIGlmIChiaWxsaW5nIHx8IGJpbGxpbmdBZGRyZXNzKSB7XG5cdCAgICBzb3VyY2Uub3duZXIgPSBfX3NwcmVhZFZhbHVlcyQzKF9fc3ByZWFkVmFsdWVzJDMoe30sIGJpbGxpbmcgPyBiaWxsaW5nIDoge30pLCBiaWxsaW5nQWRkcmVzcyA/IHsgYWRkcmVzczogYmlsbGluZ0FkZHJlc3MgfSA6IHt9KTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QmFuY29udGFjdE93bmVyKHNvdXJjZSwgZGF0YSkge1xuXHQgIGNvbnN0IGZpbGxWYWx1ZXMgPSAoZmllbGRzTWFwLCBkYXRhMikgPT4gcmVkdWNlKFxuXHQgICAgZmllbGRzTWFwLFxuXHQgICAgKGFjYywgc3JjS2V5LCBkZXN0S2V5KSA9PiB7XG5cdCAgICAgIGNvbnN0IHZhbHVlID0gZGF0YTJbc3JjS2V5XTtcblx0ICAgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgYWNjW2Rlc3RLZXldID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFjYztcblx0ICAgIH0sXG5cdCAgICB7fVxuXHQgICk7XG5cdCAgY29uc3QgeyBhY2NvdW50ID0ge30sIGJpbGxpbmcsIHNoaXBwaW5nIH0gPSBkYXRhO1xuXHQgIGNvbnN0IGJpbGxpbmdEYXRhID0gX19zcHJlYWRWYWx1ZXMkMyhfX3NwcmVhZFZhbHVlcyQzKF9fc3ByZWFkVmFsdWVzJDMoX19zcHJlYWRWYWx1ZXMkMyh7fSwgYWNjb3VudC5zaGlwcGluZyksIGFjY291bnQuYmlsbGluZyksIHNoaXBwaW5nKSwgYmlsbGluZyk7XG5cdCAgY29uc3QgYmlsbGluZ0FkZHJlc3MgPSBmaWxsVmFsdWVzKGFkZHJlc3NGaWVsZHNNYXAkMSwgYmlsbGluZ0RhdGEpO1xuXHQgIHNvdXJjZS5vd25lciA9IF9fc3ByZWFkVmFsdWVzJDMoX19zcHJlYWRWYWx1ZXMkMyh7XG5cdCAgICBlbWFpbDogYWNjb3VudC5lbWFpbCxcblx0ICAgIG5hbWU6IGJpbGxpbmdEYXRhLm5hbWUgfHwgYWNjb3VudC5uYW1lXG5cdCAgfSwgYmlsbGluZ0RhdGEucGhvbmUgPyB7IHBob25lOiBiaWxsaW5nRGF0YS5waG9uZSB9IDogYWNjb3VudC5waG9uZSA/IHsgcGhvbmU6IGFjY291bnQucGhvbmUgfSA6IHt9KSwgIWlzRW1wdHkoYmlsbGluZ0FkZHJlc3MpID8geyBhZGRyZXNzOiBiaWxsaW5nQWRkcmVzcyB9IDoge30pO1xuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBheW1lbnRNZXRob2Qoc3RyaXBlLCBjYXJkRWxlbWVudCwgYXV0aG9yaXplLCBjYXJ0KSB7XG5cdCAgY29uc3QgYmlsbGluZ0RldGFpbHMgPSBnZXRCaWxsaW5nRGV0YWlscyhjYXJ0KTtcblx0ICBjb25zdCB7IHBheW1lbnRNZXRob2QsIGVycm9yOiBwYXltZW50TWV0aG9kRXJyb3IgfSA9IGF3YWl0IHN0cmlwZS5jcmVhdGVQYXltZW50TWV0aG9kKF9fc3ByZWFkVmFsdWVzJDMoe1xuXHQgICAgdHlwZTogXCJjYXJkXCIsXG5cdCAgICBjYXJkOiBjYXJkRWxlbWVudFxuXHQgIH0sICFpc0VtcHR5KGJpbGxpbmdEZXRhaWxzKSA/IHsgYmlsbGluZ19kZXRhaWxzOiBiaWxsaW5nRGV0YWlscyB9IDoge30pKTtcblx0ICBpZiAocGF5bWVudE1ldGhvZEVycm9yKSB7XG5cdCAgICByZXR1cm4geyBlcnJvcjogcGF5bWVudE1ldGhvZEVycm9yIH07XG5cdCAgfVxuXHQgIGNvbnN0IGN1c3RvbWVyID0gY2FydC5hY2NvdW50ICYmIGNhcnQuYWNjb3VudC5zdHJpcGVfY3VzdG9tZXI7XG5cdCAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGF3YWl0IGF1dGhvcml6ZSh7XG5cdCAgICBnYXRld2F5OiBcInN0cmlwZVwiLFxuXHQgICAgcGFyYW1zOiBfX3NwcmVhZFZhbHVlcyQzKHtcblx0ICAgICAgdXNhZ2U6IFwib2ZmX3Nlc3Npb25cIixcblx0ICAgICAgcGF5bWVudF9tZXRob2Q6IHBheW1lbnRNZXRob2QuaWRcblx0ICAgIH0sIGN1c3RvbWVyID8geyBjdXN0b21lciB9IDoge30pXG5cdCAgfSk7XG5cdCAgaWYgKCFhdXRob3JpemF0aW9uKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGNvbnN0IHsgZXJyb3I6IHNldHVwSW50ZW50RXJyb3IgfSA9IGF3YWl0IHN0cmlwZS5jb25maXJtQ2FyZFNldHVwKFxuXHQgICAgYXV0aG9yaXphdGlvbi5jbGllbnRfc2VjcmV0XG5cdCAgKTtcblx0ICByZXR1cm4gc2V0dXBJbnRlbnRFcnJvciA/IHsgZXJyb3I6IHNldHVwSW50ZW50RXJyb3IgfSA6IGF1dGhvcml6YXRpb24uY2FyZDtcblx0fVxuXHRhc3luYyBmdW5jdGlvbiBjcmVhdGVJRGVhbFBheW1lbnRNZXRob2Qoc3RyaXBlLCBlbGVtZW50LCBjYXJ0KSB7XG5cdCAgY29uc3QgYmlsbGluZ0RldGFpbHMgPSBnZXRCaWxsaW5nRGV0YWlscyhjYXJ0KTtcblx0ICByZXR1cm4gYXdhaXQgc3RyaXBlLmNyZWF0ZVBheW1lbnRNZXRob2QoX19zcHJlYWRWYWx1ZXMkMyh7XG5cdCAgICB0eXBlOiBcImlkZWFsXCIsXG5cdCAgICBpZGVhbDogZWxlbWVudFxuXHQgIH0sIGJpbGxpbmdEZXRhaWxzID8geyBiaWxsaW5nX2RldGFpbHM6IGJpbGxpbmdEZXRhaWxzIH0gOiB7fSkpO1xuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtsYXJuYVNvdXJjZShzdHJpcGUsIGNhcnQpIHtcblx0ICBjb25zdCBzb3VyY2VPYmplY3QgPSB7XG5cdCAgICB0eXBlOiBcImtsYXJuYVwiLFxuXHQgICAgZmxvdzogXCJyZWRpcmVjdFwiLFxuXHQgICAgYW1vdW50OiBNYXRoLnJvdW5kKGdldChjYXJ0LCBcImdyYW5kX3RvdGFsXCIsIDApICogMTAwKSxcblx0ICAgIGN1cnJlbmN5OiB0b0xvd2VyKGdldChjYXJ0LCBcImN1cnJlbmN5XCIsIFwiZXVyXCIpKSxcblx0ICAgIGtsYXJuYToge1xuXHQgICAgICBwcm9kdWN0OiBcInBheW1lbnRcIixcblx0ICAgICAgcHVyY2hhc2VfY291bnRyeTogZ2V0KGNhcnQsIFwic2V0dGluZ3MuY291bnRyeVwiLCBcIkRFXCIpXG5cdCAgICB9LFxuXHQgICAgc291cmNlX29yZGVyOiB7XG5cdCAgICAgIGl0ZW1zOiBnZXRLbGFybmFJdGVtcyhjYXJ0KVxuXHQgICAgfSxcblx0ICAgIHJlZGlyZWN0OiB7XG5cdCAgICAgIHJldHVybl91cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG5cdCAgICB9XG5cdCAgfTtcblx0ICBzZXRLbGFybmFCaWxsaW5nU2hpcHBpbmcoc291cmNlT2JqZWN0LCBjYXJ0KTtcblx0ICByZXR1cm4gYXdhaXQgc3RyaXBlLmNyZWF0ZVNvdXJjZShzb3VyY2VPYmplY3QpO1xuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUJhbmNvbnRhY3RTb3VyY2Uoc3RyaXBlLCBjYXJ0KSB7XG5cdCAgY29uc3Qgc291cmNlT2JqZWN0ID0ge1xuXHQgICAgdHlwZTogXCJiYW5jb250YWN0XCIsXG5cdCAgICBhbW91bnQ6IE1hdGgucm91bmQoZ2V0KGNhcnQsIFwiZ3JhbmRfdG90YWxcIiwgMCkgKiAxMDApLFxuXHQgICAgY3VycmVuY3k6IHRvTG93ZXIoZ2V0KGNhcnQsIFwiY3VycmVuY3lcIiwgXCJldXJcIikpLFxuXHQgICAgcmVkaXJlY3Q6IHtcblx0ICAgICAgcmV0dXJuX3VybDogd2luZG93LmxvY2F0aW9uLmhyZWZcblx0ICAgIH1cblx0ICB9O1xuXHQgIHNldEJhbmNvbnRhY3RPd25lcihzb3VyY2VPYmplY3QsIGNhcnQpO1xuXHQgIHJldHVybiBhd2FpdCBzdHJpcGUuY3JlYXRlU291cmNlKHNvdXJjZU9iamVjdCk7XG5cdH1cblx0ZnVuY3Rpb24gc3RyaXBlQW1vdW50QnlDdXJyZW5jeShjdXJyZW5jeSwgYW1vdW50KSB7XG5cdCAgY29uc3QgemVyb0RlY2ltYWxDdXJyZW5jaWVzID0gW1xuXHQgICAgXCJCSUZcIixcblx0ICAgIFwiREpGXCIsXG5cdCAgICBcIkpQWVwiLFxuXHQgICAgXCJLUldcIixcblx0ICAgIFwiUFlHXCIsXG5cdCAgICBcIlZORFwiLFxuXHQgICAgXCJYQUZcIixcblx0ICAgIFwiWFBGXCIsXG5cdCAgICBcIkNMUFwiLFxuXHQgICAgXCJHTkZcIixcblx0ICAgIFwiS01GXCIsXG5cdCAgICBcIk1HQVwiLFxuXHQgICAgXCJSV0ZcIixcblx0ICAgIFwiVlVWXCIsXG5cdCAgICBcIlhPRlwiXG5cdCAgXTtcblx0ICBpZiAoemVyb0RlY2ltYWxDdXJyZW5jaWVzLmluY2x1ZGVzKGN1cnJlbmN5LnRvVXBwZXJDYXNlKCkpKSB7XG5cdCAgICByZXR1cm4gYW1vdW50O1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChhbW91bnQgKiAxMDApO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlT3JkZXJJZCgpIHtcblx0ICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpO1xuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVF1aWNrcGF5Q2FyZChhdXRob3JpemUpIHtcblx0ICBjb25zdCByZXR1cm5VcmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuXHQgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBhd2FpdCBhdXRob3JpemUoe1xuXHQgICAgZ2F0ZXdheTogXCJxdWlja3BheVwiLFxuXHQgICAgcGFyYW1zOiB7XG5cdCAgICAgIGFjdGlvbjogXCJjcmVhdGVcIixcblx0ICAgICAgY29udGludWV1cmw6IGAke3JldHVyblVybH0/Z2F0ZXdheT1xdWlja3BheSZyZWRpcmVjdF9zdGF0dXM9c3VjY2VlZGVkYCxcblx0ICAgICAgY2FuY2VsdXJsOiBgJHtyZXR1cm5Vcmx9P2dhdGV3YXk9cXVpY2twYXkmcmVkaXJlY3Rfc3RhdHVzPWNhbmNlbGVkYFxuXHQgICAgfVxuXHQgIH0pO1xuXHQgIGlmIChhdXRob3JpemF0aW9uICYmIGF1dGhvcml6YXRpb24udXJsKSB7XG5cdCAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShhdXRob3JpemF0aW9uLnVybCk7XG5cdCAgfVxuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIGdldFF1aWNrcGF5Q2FyZERldGFpcyhpZCwgYXV0aG9yaXplKSB7XG5cdCAgcmV0dXJuIGF3YWl0IGF1dGhvcml6ZSh7XG5cdCAgICBnYXRld2F5OiBcInF1aWNrcGF5XCIsXG5cdCAgICBwYXJhbXM6IHsgYWN0aW9uOiBcImdldFwiLCBpZCB9XG5cdCAgfSk7XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gY3JlYXRlUXVpY2twYXlQYXltZW50KGNhcnQsIGNyZWF0ZUludGVudCkge1xuXHQgIHJldHVybiBhd2FpdCBjcmVhdGVJbnRlbnQoe1xuXHQgICAgZ2F0ZXdheTogXCJxdWlja3BheVwiLFxuXHQgICAgaW50ZW50OiB7XG5cdCAgICAgIGN1cnJlbmN5OiBnZXQoY2FydCwgXCJjdXJyZW5jeVwiLCBcIlVTRFwiKSxcblx0ICAgICAgb3JkZXJfaWQ6IGdlbmVyYXRlT3JkZXJJZCgpXG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHRhc3luYyBmdW5jdGlvbiBjcmVhdGVQYXlzYWZlY2FyZFBheW1lbnQoY2FydCwgY3JlYXRlSW50ZW50KSB7XG5cdCAgY29uc3QgcmV0dXJuVXJsID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcblx0ICBjb25zdCB1cmwgPSBgJHtyZXR1cm5Vcmx9P2dhdGV3YXk9cGF5c2FmZWNhcmRgO1xuXHQgIHJldHVybiBhd2FpdCBjcmVhdGVJbnRlbnQoe1xuXHQgICAgZ2F0ZXdheTogXCJwYXlzYWZlY2FyZFwiLFxuXHQgICAgaW50ZW50OiB7XG5cdCAgICAgIHR5cGU6IFwiUEFZU0FGRUNBUkRcIixcblx0ICAgICAgYW1vdW50OiBjYXJ0LmdyYW5kX3RvdGFsLFxuXHQgICAgICByZWRpcmVjdDoge1xuXHQgICAgICAgIHN1Y2Nlc3NfdXJsOiB1cmwsXG5cdCAgICAgICAgZmFpbHVyZV91cmw6IHVybFxuXHQgICAgICB9LFxuXHQgICAgICBub3RpZmljYXRpb25fdXJsOiB1cmwsXG5cdCAgICAgIGN1c3RvbWVyOiB7XG5cdCAgICAgICAgaWQ6IGdldChjYXJ0LCBcImFjY291bnQuaWRcIilcblx0ICAgICAgfSxcblx0ICAgICAgY3VycmVuY3k6IGdldChjYXJ0LCBcImN1cnJlbmN5XCIsIFwiVVNEXCIpXG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHR2YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdHZhciBfX2RlZlByb3BzJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0dmFyIF9fZ2V0T3duUHJvcERlc2NzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcblx0dmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cdHZhciBfX2hhc093blByb3AkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBfX3Byb3BJc0VudW0kMiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBfX2RlZk5vcm1hbFByb3AkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMihvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG5cdHZhciBfX3NwcmVhZFZhbHVlcyQyID0gKGEsIGIpID0+IHtcblx0ICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG5cdCAgICBpZiAoX19oYXNPd25Qcm9wJDIuY2FsbChiLCBwcm9wKSlcblx0ICAgICAgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG5cdCAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMilcblx0ICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQyKGIpKSB7XG5cdCAgICAgIGlmIChfX3Byb3BJc0VudW0kMi5jYWxsKGIsIHByb3ApKVxuXHQgICAgICAgIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuXHQgICAgfVxuXHQgIHJldHVybiBhO1xuXHR9O1xuXHR2YXIgX19zcHJlYWRQcm9wcyQxID0gKGEsIGIpID0+IF9fZGVmUHJvcHMkMShhLCBfX2dldE93blByb3BEZXNjcyQxKGIpKTtcblx0Y29uc3QgYWRkcmVzc0ZpZWxkc01hcCA9IHtcblx0ICBnaXZlbl9uYW1lOiBcImZpcnN0X25hbWVcIixcblx0ICBmYW1pbHlfbmFtZTogXCJsYXN0X25hbWVcIixcblx0ICBjaXR5OiBcImNpdHlcIixcblx0ICBjb3VudHJ5OiBcImNvdW50cnlcIixcblx0ICBwaG9uZTogXCJwaG9uZVwiLFxuXHQgIHBvc3RhbF9jb2RlOiBcInppcFwiLFxuXHQgIHN0cmVldF9hZGRyZXNzOiBcImFkZHJlc3MxXCIsXG5cdCAgc3RyZWV0X2FkZHJlc3MyOiBcImFkZHJlc3MyXCIsXG5cdCAgcmVnaW9uOiBcInN0YXRlXCJcblx0fTtcblx0Y29uc3QgbWFwRmllbGRzID0gKGZpZWxkc01hcCwgZGF0YSkgPT4gcmVkdWNlKFxuXHQgIGZpZWxkc01hcCxcblx0ICAoYWNjLCBzcmNLZXksIGRlc3RLZXkpID0+IHtcblx0ICAgIGNvbnN0IHZhbHVlID0gZGF0YVtzcmNLZXldO1xuXHQgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgIGFjY1tkZXN0S2V5XSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFjYztcblx0ICB9LFxuXHQgIHt9XG5cdCk7XG5cdGNvbnN0IG1hcEFkZHJlc3NGaWVsZHMgPSAoY2FydCwgYWRkcmVzc0ZpZWxkKSA9PiBfX3NwcmVhZFByb3BzJDEoX19zcHJlYWRWYWx1ZXMkMih7fSwgbWFwRmllbGRzKGFkZHJlc3NGaWVsZHNNYXAsIGNhcnRbYWRkcmVzc0ZpZWxkXSkpLCB7XG5cdCAgZW1haWw6IGdldChjYXJ0LCBcImFjY291bnQuZW1haWxcIilcblx0fSk7XG5cdGZ1bmN0aW9uIGdldE9yZGVyTGluZXMoY2FydCkge1xuXHQgIGNvbnN0IGl0ZW1zID0gbWFwKGNhcnQuaXRlbXMsIChpdGVtKSA9PiAoe1xuXHQgICAgdHlwZTogXCJwaHlzaWNhbFwiLFxuXHQgICAgbmFtZTogZ2V0KGl0ZW0sIFwicHJvZHVjdC5uYW1lXCIpLFxuXHQgICAgcmVmZXJlbmNlOiBnZXQoaXRlbSwgXCJwcm9kdWN0LnNrdVwiKSB8fCBnZXQoaXRlbSwgXCJwcm9kdWN0LnNsdWdcIiksXG5cdCAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcblx0ICAgIHVuaXRfcHJpY2U6IE1hdGgucm91bmQodG9OdW1iZXIoaXRlbS5wcmljZSAtIGl0ZW0uZGlzY291bnRfZWFjaCkgKiAxMDApLFxuXHQgICAgdG90YWxfYW1vdW50OiBNYXRoLnJvdW5kKFxuXHQgICAgICB0b051bWJlcihpdGVtLnByaWNlX3RvdGFsIC0gaXRlbS5kaXNjb3VudF90b3RhbCkgKiAxMDBcblx0ICAgICksXG5cdCAgICB0YXhfcmF0ZTogMCxcblx0ICAgIHRvdGFsX3RheF9hbW91bnQ6IDBcblx0ICB9KSk7XG5cdCAgY29uc3QgdGF4ID0gZ2V0KGNhcnQsIFwidGF4X2luY2x1ZGVkX3RvdGFsXCIpO1xuXHQgIGNvbnN0IHRheEFtb3VudCA9IHRvTnVtYmVyKHRheCkgKiAxMDA7XG5cdCAgaWYgKHRheCkge1xuXHQgICAgaXRlbXMucHVzaCh7XG5cdCAgICAgIHR5cGU6IFwic2FsZXNfdGF4XCIsXG5cdCAgICAgIG5hbWU6IFwiVGF4ZXNcIixcblx0ICAgICAgcXVhbnRpdHk6IDEsXG5cdCAgICAgIHVuaXRfcHJpY2U6IHRheEFtb3VudCxcblx0ICAgICAgdG90YWxfYW1vdW50OiB0YXhBbW91bnQsXG5cdCAgICAgIHRheF9yYXRlOiAwLFxuXHQgICAgICB0b3RhbF90YXhfYW1vdW50OiAwXG5cdCAgICB9KTtcblx0ICB9XG5cdCAgY29uc3Qgc2hpcHBpbmcgPSBnZXQoY2FydCwgXCJzaGlwcGluZ1wiLCB7fSk7XG5cdCAgY29uc3Qgc2hpcHBpbmdUb3RhbCA9IGdldChjYXJ0LCBcInNoaXBtZW50X3RvdGFsXCIsIHt9KTtcblx0ICBjb25zdCBzaGlwcGluZ0Ftb3VudCA9IHRvTnVtYmVyKHNoaXBwaW5nVG90YWwpICogMTAwO1xuXHQgIGlmIChzaGlwcGluZy5wcmljZSkge1xuXHQgICAgaXRlbXMucHVzaCh7XG5cdCAgICAgIHR5cGU6IFwic2hpcHBpbmdfZmVlXCIsXG5cdCAgICAgIG5hbWU6IHNoaXBwaW5nLnNlcnZpY2VfbmFtZSxcblx0ICAgICAgcXVhbnRpdHk6IDEsXG5cdCAgICAgIHVuaXRfcHJpY2U6IHNoaXBwaW5nQW1vdW50LFxuXHQgICAgICB0b3RhbF9hbW91bnQ6IHNoaXBwaW5nQW1vdW50LFxuXHQgICAgICB0YXhfcmF0ZTogMCxcblx0ICAgICAgdG90YWxfdGF4X2Ftb3VudDogMFxuXHQgICAgfSk7XG5cdCAgfVxuXHQgIHJldHVybiBpdGVtcztcblx0fVxuXHRhc3luYyBmdW5jdGlvbiBjcmVhdGVLbGFybmFTZXNzaW9uKGNhcnQsIGNyZWF0ZUludGVudCkge1xuXHQgIGNvbnN0IHJldHVyblVybCA9IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59JHt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9P2dhdGV3YXk9a2xhcm5hX2RpcmVjdCZzaWQ9e3tzZXNzaW9uX2lkfX1gO1xuXHQgIGNvbnN0IHN1Y2Nlc3NVcmwgPSBgJHtyZXR1cm5Vcmx9JmF1dGhvcml6YXRpb25fdG9rZW49e3thdXRob3JpemF0aW9uX3Rva2VufX1gO1xuXHQgIHJldHVybiBjcmVhdGVJbnRlbnQoe1xuXHQgICAgZ2F0ZXdheTogXCJrbGFybmFcIixcblx0ICAgIGludGVudDoge1xuXHQgICAgICBsb2NhbGU6IGNhcnQuZGlzcGxheV9sb2NhbGUgfHwgZ2V0KGNhcnQsIFwic2V0dGluZ3MubG9jYWxlXCIpIHx8IFwiZW4tVVNcIixcblx0ICAgICAgcHVyY2hhc2VfY291bnRyeTogZ2V0KGNhcnQsIFwiYmlsbGluZy5jb3VudHJ5XCIpIHx8IGdldChjYXJ0LCBcInNoaXBwaW5nLmNvdW50cnlcIiksXG5cdCAgICAgIHB1cmNoYXNlX2N1cnJlbmN5OiBjYXJ0LmN1cnJlbmN5LFxuXHQgICAgICBiaWxsaW5nX2FkZHJlc3M6IG1hcEFkZHJlc3NGaWVsZHMoY2FydCwgXCJiaWxsaW5nXCIpLFxuXHQgICAgICBzaGlwcGluZ19hZGRyZXNzOiBtYXBBZGRyZXNzRmllbGRzKGNhcnQsIFwic2hpcHBpbmdcIiksXG5cdCAgICAgIG9yZGVyX2Ftb3VudDogTWF0aC5yb3VuZChnZXQoY2FydCwgXCJncmFuZF90b3RhbFwiLCAwKSAqIDEwMCksXG5cdCAgICAgIG9yZGVyX2xpbmVzOiBKU09OLnN0cmluZ2lmeShnZXRPcmRlckxpbmVzKGNhcnQpKSxcblx0ICAgICAgbWVyY2hhbnRfdXJsczoge1xuXHQgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3NVcmwsXG5cdCAgICAgICAgYmFjazogcmV0dXJuVXJsLFxuXHQgICAgICAgIGNhbmNlbDogcmV0dXJuVXJsLFxuXHQgICAgICAgIGVycm9yOiByZXR1cm5VcmwsXG5cdCAgICAgICAgZmFpbHVyZTogcmV0dXJuVXJsXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXG5cdHZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0dmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0dmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cdHZhciBfX2dldE93blByb3BTeW1ib2xzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXHR2YXIgX19oYXNPd25Qcm9wJDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgX19wcm9wSXNFbnVtJDEgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xuXHR2YXIgX19zcHJlYWRWYWx1ZXMkMSA9IChhLCBiKSA9PiB7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuXHQgICAgaWYgKF9faGFzT3duUHJvcCQxLmNhbGwoYiwgcHJvcCkpXG5cdCAgICAgIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuXHQgIGlmIChfX2dldE93blByb3BTeW1ib2xzJDEpXG5cdCAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMkMShiKSkge1xuXHQgICAgICBpZiAoX19wcm9wSXNFbnVtJDEuY2FsbChiLCBwcm9wKSlcblx0ICAgICAgICBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcblx0ICAgIH1cblx0ICByZXR1cm4gYTtcblx0fTtcblx0dmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5cdGNvbnN0IExPQURJTkdfU0NSSVBUUyA9IHt9O1xuXHRjb25zdCBDQVJEX0VMRU1FTlRTID0ge307XG5cdGNvbnN0IEFQSSA9IHt9O1xuXHRsZXQgb3B0aW9ucyQxID0gbnVsbDtcblx0ZnVuY3Rpb24gbWV0aG9kcyQyKHJlcXVlc3QsIG9wdHMpIHtcblx0ICBvcHRpb25zJDEgPSBvcHRzIHx8IG9wdGlvbnMkMTtcblx0ICByZXR1cm4ge1xuXHQgICAgcGFyYW1zOiBudWxsLFxuXHQgICAgbWV0aG9kU2V0dGluZ3M6IG51bGwsXG5cdCAgICBnZXQoaWQpIHtcblx0ICAgICAgcmV0dXJuIHJlcXVlc3QoXCJnZXRcIiwgXCIvcGF5bWVudHNcIiwgaWQpO1xuXHQgICAgfSxcblx0ICAgIGFzeW5jIG1ldGhvZHMoKSB7XG5cdCAgICAgIGlmICh0aGlzLm1ldGhvZFNldHRpbmdzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kU2V0dGluZ3M7XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdChcImdldFwiLCBcIi9wYXltZW50L21ldGhvZHNcIik7XG5cdCAgICAgIHJldHVybiB0aGlzLm1ldGhvZFNldHRpbmdzID0gcmVzdWx0O1xuXHQgICAgfSxcblx0ICAgIGFzeW5jIGNyZWF0ZUVsZW1lbnRzKGVsZW1lbnRQYXJhbXMpIHtcblx0ICAgICAgdGhpcy5wYXJhbXMgPSBlbGVtZW50UGFyYW1zIHx8IHt9O1xuXHQgICAgICBjb25zdCBjYXJ0ID0gdG9TbmFrZShhd2FpdCBtZXRob2RzJDgocmVxdWVzdCwgb3B0aW9ucyQxKS5nZXQoKSk7XG5cdCAgICAgIGlmICghY2FydCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhcnQgbm90IGZvdW5kXCIpO1xuXHQgICAgICB9XG5cdCAgICAgIGNvbnN0IHBheU1ldGhvZHMgPSB0b1NuYWtlKFxuXHQgICAgICAgIGF3YWl0IG1ldGhvZHMkMyhyZXF1ZXN0LCBvcHRpb25zJDEpLnBheW1lbnRzKClcblx0ICAgICAgKTtcblx0ICAgICAgaWYgKHBheU1ldGhvZHMuZXJyb3IpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGF5TWV0aG9kcy5lcnJvcik7XG5cdCAgICAgIH1cblx0ICAgICAgYXdhaXQgcmVuZGVyKHJlcXVlc3QsIGNhcnQsIHBheU1ldGhvZHMsIHRoaXMucGFyYW1zKTtcblx0ICAgIH0sXG5cdCAgICBhc3luYyB0b2tlbml6ZShwYXJhbXMpIHtcblx0ICAgICAgY29uc3QgY2FydCA9IHRvU25ha2UoYXdhaXQgbWV0aG9kcyQ4KHJlcXVlc3QsIG9wdGlvbnMkMSkuZ2V0KCkpO1xuXHQgICAgICBpZiAoIWNhcnQpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYXJ0IG5vdCBmb3VuZFwiKTtcblx0ICAgICAgfVxuXHQgICAgICBjb25zdCBwYXlNZXRob2RzID0gdG9TbmFrZShcblx0ICAgICAgICBhd2FpdCBtZXRob2RzJDMocmVxdWVzdCwgb3B0aW9ucyQxKS5wYXltZW50cygpXG5cdCAgICAgICk7XG5cdCAgICAgIGlmIChwYXlNZXRob2RzLmVycm9yKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBheU1ldGhvZHMuZXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhd2FpdCBwYXltZW50VG9rZW5pemUoXG5cdCAgICAgICAgcmVxdWVzdCxcblx0ICAgICAgICBwYXJhbXMgfHwgdGhpcy5wYXJhbXMsXG5cdCAgICAgICAgcGF5TWV0aG9kcyxcblx0ICAgICAgICBjYXJ0XG5cdCAgICAgICk7XG5cdCAgICB9LFxuXHQgICAgYXN5bmMgaGFuZGxlUmVkaXJlY3QocGFyYW1zKSB7XG5cdCAgICAgIGNvbnN0IGNhcnQgPSB0b1NuYWtlKGF3YWl0IG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zJDEpLmdldCgpKTtcblx0ICAgICAgaWYgKCFjYXJ0KSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FydCBub3QgZm91bmRcIik7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZVJlZGlyZWN0KHJlcXVlc3QsIHBhcmFtcyB8fCB0aGlzLnBhcmFtcywgY2FydCk7XG5cdCAgICB9LFxuXHQgICAgYXN5bmMgYXV0aGVudGljYXRlKGlkKSB7XG5cdCAgICAgIGNvbnN0IHBheW1lbnQgPSBhd2FpdCB0aGlzLmdldChpZCk7XG5cdCAgICAgIGlmICghcGF5bWVudCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBheW1lbnQgbm90IGZvdW5kXCIpO1xuXHQgICAgICB9XG5cdCAgICAgIGNvbnN0IHBheU1ldGhvZHMgPSB0b1NuYWtlKFxuXHQgICAgICAgIGF3YWl0IG1ldGhvZHMkMyhyZXF1ZXN0LCBvcHRpb25zJDEpLnBheW1lbnRzKClcblx0ICAgICAgKTtcblx0ICAgICAgaWYgKHBheU1ldGhvZHMuZXJyb3IpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGF5TWV0aG9kcy5lcnJvcik7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGF3YWl0IGF1dGhlbnRpY2F0ZShyZXF1ZXN0LCBwYXltZW50LCBwYXlNZXRob2RzKTtcblx0ICAgIH0sXG5cdCAgICBhc3luYyBjcmVhdGVJbnRlbnQoZGF0YSkge1xuXHQgICAgICBjb25zdCBpbnRlbnQgPSBhd2FpdCB2YXVsdFJlcXVlc3QoXCJwb3N0XCIsIFwiL2ludGVudFwiLCBkYXRhKTtcblx0ICAgICAgaWYgKGludGVudC5lcnJvcnMpIHtcblx0ICAgICAgICBjb25zdCBwYXJhbSA9IE9iamVjdC5rZXlzKGludGVudC5lcnJvcnMpWzBdO1xuXHQgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihpbnRlbnQuZXJyb3JzW3BhcmFtXS5tZXNzYWdlIHx8IFwiVW5rbm93biBlcnJvclwiKTtcblx0ICAgICAgICBlcnIuY29kZSA9IFwidmF1bHRfZXJyb3JcIjtcblx0ICAgICAgICBlcnIuc3RhdHVzID0gNDAyO1xuXHQgICAgICAgIGVyci5wYXJhbSA9IHBhcmFtO1xuXHQgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaW50ZW50O1xuXHQgICAgfSxcblx0ICAgIGFzeW5jIHVwZGF0ZUludGVudChkYXRhKSB7XG5cdCAgICAgIGNvbnN0IGludGVudCA9IGF3YWl0IHZhdWx0UmVxdWVzdChcInB1dFwiLCBcIi9pbnRlbnRcIiwgZGF0YSk7XG5cdCAgICAgIGlmIChpbnRlbnQuZXJyb3JzKSB7XG5cdCAgICAgICAgY29uc3QgcGFyYW0gPSBPYmplY3Qua2V5cyhpbnRlbnQuZXJyb3JzKVswXTtcblx0ICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoaW50ZW50LmVycm9yc1twYXJhbV0ubWVzc2FnZSB8fCBcIlVua25vd24gZXJyb3JcIik7XG5cdCAgICAgICAgZXJyLmNvZGUgPSBcInZhdWx0X2Vycm9yXCI7XG5cdCAgICAgICAgZXJyLnN0YXR1cyA9IDQwMjtcblx0ICAgICAgICBlcnIucGFyYW0gPSBwYXJhbTtcblx0ICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGludGVudDtcblx0ICAgIH0sXG5cdCAgICBhc3luYyBhdXRob3JpemVHYXRld2F5KGRhdGEpIHtcblx0ICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGF3YWl0IHZhdWx0UmVxdWVzdChcInBvc3RcIiwgXCIvYXV0aG9yaXphdGlvblwiLCBkYXRhKTtcblx0ICAgICAgaWYgKGF1dGhvcml6YXRpb24uZXJyb3JzKSB7XG5cdCAgICAgICAgY29uc3QgcGFyYW0gPSBPYmplY3Qua2V5cyhhdXRob3JpemF0aW9uLmVycm9ycylbMF07XG5cdCAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuXHQgICAgICAgICAgYXV0aG9yaXphdGlvbi5lcnJvcnNbcGFyYW1dLm1lc3NhZ2UgfHwgXCJVbmtub3duIGVycm9yXCJcblx0ICAgICAgICApO1xuXHQgICAgICAgIGVyci5jb2RlID0gXCJ2YXVsdF9lcnJvclwiO1xuXHQgICAgICAgIGVyci5zdGF0dXMgPSA0MDI7XG5cdCAgICAgICAgZXJyLnBhcmFtID0gcGFyYW07XG5cdCAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhdXRob3JpemF0aW9uO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gcmVuZGVyKHJlcXVlc3QsIGNhcnQsIHBheU1ldGhvZHMsIHBhcmFtcykge1xuXHQgIGlmIChwYXJhbXMuY2FyZCkge1xuXHQgICAgaWYgKCFwYXlNZXRob2RzLmNhcmQpIHtcblx0ICAgICAgY29uc29sZS5lcnJvcihcblx0ICAgICAgICBgUGF5bWVudCBlbGVtZW50IGVycm9yOiBjcmVkaXQgY2FyZCBwYXltZW50cyBhcmUgZGlzYWJsZWQuIFNlZSBQYXltZW50IHNldHRpbmdzIGluIHRoZSBTd2VsbCBkYXNoYm9hcmQgZm9yIGRldGFpbHMuYFxuXHQgICAgICApO1xuXHQgICAgfSBlbHNlIGlmIChwYXlNZXRob2RzLmNhcmQuZ2F0ZXdheSA9PT0gXCJicmFpbnRyZWVcIikge1xuXHQgICAgICBpZiAoIXdpbmRvdy5icmFpbnRyZWUpIHtcblx0ICAgICAgICBhd2FpdCBsb2FkU2NyaXB0KFxuXHQgICAgICAgICAgXCJicmFpbnRyZWUtd2ViXCIsXG5cdCAgICAgICAgICBcImh0dHBzOi8vanMuYnJhaW50cmVlZ2F0ZXdheS5jb20vd2ViLzMuNTcuMC9qcy9jbGllbnQubWluLmpzXCJcblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHBheU1ldGhvZHMuY2FyZC5nYXRld2F5ID09PSBcInN0cmlwZVwiKSB7XG5cdCAgICAgIGlmICghd2luZG93LlN0cmlwZSkge1xuXHQgICAgICAgIGF3YWl0IGxvYWRTY3JpcHQoXCJzdHJpcGUtanNcIiwgXCJodHRwczovL2pzLnN0cmlwZS5jb20vdjMvXCIpO1xuXHQgICAgICB9XG5cdCAgICAgIGF3YWl0IHN0cmlwZUVsZW1lbnRzKHJlcXVlc3QsIHBheU1ldGhvZHMsIHBhcmFtcyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmIChwYXJhbXMuaWRlYWwpIHtcblx0ICAgIGlmICghcGF5TWV0aG9kcy5jYXJkKSB7XG5cdCAgICAgIGNvbnNvbGUuZXJyb3IoXG5cdCAgICAgICAgYFBheW1lbnQgZWxlbWVudCBlcnJvcjogY3JlZGl0IGNhcmQgcGF5bWVudHMgYXJlIGRpc2FibGVkLiBTZWUgUGF5bWVudCBzZXR0aW5ncyBpbiB0aGUgU3dlbGwgZGFzaGJvYXJkIGZvciBkZXRhaWxzLmBcblx0ICAgICAgKTtcblx0ICAgIH0gZWxzZSBpZiAoIXBheU1ldGhvZHMuaWRlYWwpIHtcblx0ICAgICAgY29uc29sZS5lcnJvcihcblx0ICAgICAgICBgUGF5bWVudCBlbGVtZW50IGVycm9yOiBpREVBTCBwYXltZW50cyBhcmUgZGlzYWJsZWQuIFNlZSBQYXltZW50IHNldHRpbmdzIGluIHRoZSBTd2VsbCBkYXNoYm9hcmQgZm9yIGRldGFpbHMuYFxuXHQgICAgICApO1xuXHQgICAgfSBlbHNlIGlmIChwYXlNZXRob2RzLmNhcmQuZ2F0ZXdheSA9PT0gXCJzdHJpcGVcIikge1xuXHQgICAgICBpZiAoIXdpbmRvdy5TdHJpcGUpIHtcblx0ICAgICAgICBhd2FpdCBsb2FkU2NyaXB0KFwic3RyaXBlLWpzXCIsIFwiaHR0cHM6Ly9qcy5zdHJpcGUuY29tL3YzL1wiKTtcblx0ICAgICAgfVxuXHQgICAgICBhd2FpdCBzdHJpcGVFbGVtZW50cyhyZXF1ZXN0LCBwYXlNZXRob2RzLCBwYXJhbXMpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAocGFyYW1zLnBheXBhbCkge1xuXHQgICAgaWYgKCFwYXlNZXRob2RzLnBheXBhbCkge1xuXHQgICAgICBjb25zb2xlLmVycm9yKFxuXHQgICAgICAgIGBQYXltZW50IGVsZW1lbnQgZXJyb3I6IFBheVBhbCBwYXltZW50cyBhcmUgZGlzYWJsZWQuIFNlZSBQYXltZW50IHNldHRpbmdzIGluIHRoZSBTd2VsbCBkYXNoYm9hcmQgZm9yIGRldGFpbHMuYFxuXHQgICAgICApO1xuXHQgICAgfSBlbHNlIGlmIChwYXlNZXRob2RzLmNhcmQgJiYgcGF5TWV0aG9kcy5jYXJkLmdhdGV3YXkgPT09IFwiYnJhaW50cmVlXCIgJiYgcGF5TWV0aG9kcy5wYXlwYWwuZ2F0ZXdheSA9PT0gXCJicmFpbnRyZWVcIikge1xuXHQgICAgICBpZiAoIXdpbmRvdy5wYXlwYWwpIHtcblx0ICAgICAgICBhd2FpdCBsb2FkU2NyaXB0KFxuXHQgICAgICAgICAgXCJwYXlwYWwtc2RrXCIsXG5cdCAgICAgICAgICBgaHR0cHM6Ly93d3cucGF5cGFsLmNvbS9zZGsvanM/Y3VycmVuY3k9JHtjYXJ0LmN1cnJlbmN5fSZjbGllbnQtaWQ9JHtwYXlNZXRob2RzLnBheXBhbC5jbGllbnRfaWR9Jm1lcmNoYW50LWlkPSR7cGF5TWV0aG9kcy5wYXlwYWwubWVyY2hhbnRfaWR9JnZhdWx0PXRydWVgXG5cdCAgICAgICAgKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIXdpbmRvdy5icmFpbnRyZWUpIHtcblx0ICAgICAgICBhd2FpdCBsb2FkU2NyaXB0KFxuXHQgICAgICAgICAgXCJicmFpbnRyZWUtd2ViXCIsXG5cdCAgICAgICAgICBcImh0dHBzOi8vanMuYnJhaW50cmVlZ2F0ZXdheS5jb20vd2ViLzMuNTcuMC9qcy9jbGllbnQubWluLmpzXCJcblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh3aW5kb3cuYnJhaW50cmVlICYmICF3aW5kb3cuYnJhaW50cmVlLnBheXBhbENoZWNrb3V0KSB7XG5cdCAgICAgICAgYXdhaXQgbG9hZFNjcmlwdChcblx0ICAgICAgICAgIFwiYnJhaW50cmVlLXdlYi1wYXlwYWwtY2hlY2tvdXRcIixcblx0ICAgICAgICAgIFwiaHR0cHM6Ly9qcy5icmFpbnRyZWVnYXRld2F5LmNvbS93ZWIvMy41Ny4wL2pzL3BheXBhbC1jaGVja291dC5taW4uanNcIlxuXHQgICAgICAgICk7XG5cdCAgICAgIH1cblx0ICAgICAgYXdhaXQgYnJhaW50cmVlUGF5UGFsQnV0dG9uKHJlcXVlc3QsIGNhcnQsIHBheU1ldGhvZHMsIHBhcmFtcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoIXdpbmRvdy5wYXlwYWwpIHtcblx0ICAgICAgICBhd2FpdCBsb2FkU2NyaXB0KFxuXHQgICAgICAgICAgXCJwYXlwYWwtc2RrXCIsXG5cdCAgICAgICAgICBgaHR0cHM6Ly93d3cucGF5cGFsLmNvbS9zZGsvanM/Y3VycmVuY3k9JHtjYXJ0LmN1cnJlbmN5fSZjbGllbnQtaWQ9JHtwYXlNZXRob2RzLnBheXBhbC5jbGllbnRfaWR9Jm1lcmNoYW50LWlkPSR7cGF5TWV0aG9kcy5wYXlwYWwubWVyY2hhbnRfaWR9JmludGVudD1hdXRob3JpemUmY29tbWl0PWZhbHNlYFxuXHQgICAgICAgICk7XG5cdCAgICAgIH1cblx0ICAgICAgYXdhaXQgcGF5UGFsQnV0dG9uKHJlcXVlc3QsIGNhcnQsIHBheU1ldGhvZHMsIHBhcmFtcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGNvbnN0IGxvYWRTY3JpcHQgPSBhc3luYyAoaWQsIHNyYykgPT4ge1xuXHQgIExPQURJTkdfU0NSSVBUU1tpZF0gPSBMT0FESU5HX1NDUklQVFNbaWRdIHx8IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdCAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHQgICAgc2NyaXB0LmlkID0gaWQ7XG5cdCAgICBzY3JpcHQuc3JjID0gc3JjO1xuXHQgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0ICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0ICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFxuXHQgICAgICBcImxvYWRcIixcblx0ICAgICAgKCkgPT4ge1xuXHQgICAgICAgIHJlc29sdmUoKTtcblx0ICAgICAgICBMT0FESU5HX1NDUklQVFNbaWRdID0gbnVsbDtcblx0ICAgICAgfSxcblx0ICAgICAge1xuXHQgICAgICAgIG9uY2U6IHRydWVcblx0ICAgICAgfVxuXHQgICAgKTtcblx0ICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0ICB9KTtcblx0ICByZXR1cm4gTE9BRElOR19TQ1JJUFRTW2lkXTtcblx0fTtcblx0YXN5bmMgZnVuY3Rpb24gc3RyaXBlRWxlbWVudHMocmVxdWVzdCwgcGF5TWV0aG9kcywgcGFyYW1zKSB7XG5cdCAgY29uc3QgeyBwdWJsaXNoYWJsZV9rZXkgfSA9IHBheU1ldGhvZHMuY2FyZDtcblx0ICBjb25zdCBzdHJpcGUgPSB3aW5kb3cuU3RyaXBlKHB1Ymxpc2hhYmxlX2tleSk7XG5cdCAgY29uc3QgZWxlbWVudHMgPSBzdHJpcGUuZWxlbWVudHMocGFyYW1zLmNvbmZpZyk7XG5cdCAgY29uc3QgY3JlYXRlRWxlbWVudCA9ICh0eXBlKSA9PiB7XG5cdCAgICBjb25zdCBlbGVtZW50UGFyYW1zID0gZ2V0KHBhcmFtcywgYGNhcmRbJHt0eXBlfV1gKSB8fCBwYXJhbXMuY2FyZCB8fCBwYXJhbXMuaWRlYWw7XG5cdCAgICBjb25zdCBlbGVtZW50T3B0aW9ucyA9IGVsZW1lbnRQYXJhbXMub3B0aW9ucyB8fCB7fTtcblx0ICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50cy5jcmVhdGUodHlwZSwgZWxlbWVudE9wdGlvbnMpO1xuXHQgICAgZWxlbWVudC5tb3VudChlbGVtZW50UGFyYW1zLmVsZW1lbnRJZCB8fCBgIyR7dHlwZX0tZWxlbWVudGApO1xuXHQgICAgZWxlbWVudFBhcmFtcy5vbkNoYW5nZSAmJiBlbGVtZW50Lm9uKFwiY2hhbmdlXCIsIGVsZW1lbnRQYXJhbXMub25DaGFuZ2UpO1xuXHQgICAgZWxlbWVudFBhcmFtcy5vblJlYWR5ICYmIGVsZW1lbnQub24oXCJyZWFkeVwiLCBlbGVtZW50UGFyYW1zLm9uUmVhZHkpO1xuXHQgICAgZWxlbWVudFBhcmFtcy5vbkZvY3VzICYmIGVsZW1lbnQub24oXCJmb2N1c1wiLCBlbGVtZW50UGFyYW1zLm9uRm9jdXMpO1xuXHQgICAgZWxlbWVudFBhcmFtcy5vbkJsdXIgJiYgZWxlbWVudC5vbihcImJsdXJcIiwgZWxlbWVudFBhcmFtcy5vbkJsdXIpO1xuXHQgICAgZWxlbWVudFBhcmFtcy5vbkVzY2FwZSAmJiBlbGVtZW50Lm9uKFwiZXNjYXBlXCIsIGVsZW1lbnRQYXJhbXMub25Fc2NhcGUpO1xuXHQgICAgZWxlbWVudFBhcmFtcy5vbkNsaWNrICYmIGVsZW1lbnQub24oXCJjbGlja1wiLCBlbGVtZW50UGFyYW1zLm9uQ2xpY2spO1xuXHQgICAgaWYgKHR5cGUgPT09IFwiY2FyZFwiIHx8IHR5cGUgPT09IFwiY2FyZE51bWJlclwiIHx8IHR5cGUgPT09IFwiaWRlYWxCYW5rXCIpIHtcblx0ICAgICAgQ0FSRF9FTEVNRU5UUy5zdHJpcGUgPSBlbGVtZW50O1xuXHQgICAgfVxuXHQgIH07XG5cdCAgQVBJLnN0cmlwZSA9IHN0cmlwZTtcblx0ICBpZiAocGFyYW1zLmlkZWFsKSB7XG5cdCAgICBjcmVhdGVFbGVtZW50KFwiaWRlYWxCYW5rXCIpO1xuXHQgIH0gZWxzZSBpZiAocGFyYW1zLmNhcmQuc2VwYXJhdGVFbGVtZW50cykge1xuXHQgICAgY3JlYXRlRWxlbWVudChcImNhcmROdW1iZXJcIik7XG5cdCAgICBjcmVhdGVFbGVtZW50KFwiY2FyZEV4cGlyeVwiKTtcblx0ICAgIGNyZWF0ZUVsZW1lbnQoXCJjYXJkQ3ZjXCIpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBjcmVhdGVFbGVtZW50KFwiY2FyZFwiKTtcblx0ICB9XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gc2hvdWxkVXNlUGF5UGFsRW1haWwoZ3Vlc3QsIHJlcXVlc3QsIG9wdGlvbnMyKSB7XG5cdCAgaWYgKCFndWVzdClcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICBjb25zdCB1cGRhdGVkQ2FydCA9IGF3YWl0IG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zMikuZ2V0KCk7XG5cdCAgY29uc3QgY3VycmVudEVtYWlsID0gZ2V0KHVwZGF0ZWRDYXJ0LCBcImFjY291bnQuZW1haWxcIik7XG5cdCAgaWYgKCFjdXJyZW50RW1haWwpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIHBheVBhbEJ1dHRvbihyZXF1ZXN0LCBjYXJ0LCBwYXlNZXRob2RzLCBwYXJhbXMpIHtcblx0ICBjb25zdCBwYXlwYWwgPSB3aW5kb3cucGF5cGFsO1xuXHQgIGNvbnN0IHsgcGF5cGFsOiB7IGxvY2FsZSwgc3R5bGUsIGVsZW1lbnRJZCB9ID0ge30gfSA9IHBhcmFtcztcblx0ICBjb25zdCB7IGNhcHR1cmVfdG90YWwsIGN1cnJlbmN5LCBndWVzdCB9ID0gY2FydDtcblx0ICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG5cdCAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBnZXQocGFyYW1zLCBcInBheXBhbC5vbkVycm9yXCIpO1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oZXJyb3JIYW5kbGVyKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGVycm9yKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcblx0ICB9O1xuXHQgIGNvbnN0IG9uU3VjY2VzcyA9ICgpID0+IHtcblx0ICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gZ2V0KHBhcmFtcywgXCJwYXlwYWwub25TdWNjZXNzXCIpO1xuXHQgICAgcmV0dXJuIGlzRnVuY3Rpb24oc3VjY2Vzc0hhbmRsZXIpICYmIHN1Y2Nlc3NIYW5kbGVyKCk7XG5cdCAgfTtcblx0ICBpZiAoIShjYXB0dXJlX3RvdGFsID4gMCkpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgXCJJbnZhbGlkIFBheVBhbCBidXR0b24gYW1vdW50LiBWYWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8uXCJcblx0ICAgICk7XG5cdCAgfVxuXHQgIHBheXBhbC5CdXR0b25zKFxuXHQgICAge1xuXHQgICAgICBsb2NhbGU6IGxvY2FsZSB8fCBcImVuX1VTXCIsXG5cdCAgICAgIHN0eWxlOiBzdHlsZSB8fCB7XG5cdCAgICAgICAgbGF5b3V0OiBcImhvcml6b250YWxcIixcblx0ICAgICAgICBoZWlnaHQ6IDQ1LFxuXHQgICAgICAgIGNvbG9yOiBcImdvbGRcIixcblx0ICAgICAgICBzaGFwZTogXCJyZWN0XCIsXG5cdCAgICAgICAgbGFiZWw6IFwicGF5cGFsXCIsXG5cdCAgICAgICAgdGFnbGluZTogZmFsc2Vcblx0ICAgICAgfSxcblx0ICAgICAgY3JlYXRlT3JkZXI6IChkYXRhLCBhY3Rpb25zKSA9PiBhY3Rpb25zLm9yZGVyLmNyZWF0ZSh7XG5cdCAgICAgICAgaW50ZW50OiBcIkFVVEhPUklaRVwiLFxuXHQgICAgICAgIHB1cmNoYXNlX3VuaXRzOiBbXG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIGFtb3VudDoge1xuXHQgICAgICAgICAgICAgIHZhbHVlOiArY2FwdHVyZV90b3RhbC50b0ZpeGVkKDIpLFxuXHQgICAgICAgICAgICAgIGN1cnJlbmN5X2NvZGU6IGN1cnJlbmN5XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICBdXG5cdCAgICAgIH0pLFxuXHQgICAgICBvbkFwcHJvdmU6IChkYXRhLCBhY3Rpb25zKSA9PiBhY3Rpb25zLm9yZGVyLmdldCgpLnRoZW4oYXN5bmMgKG9yZGVyKSA9PiB7XG5cdCAgICAgICAgY29uc3Qgb3JkZXJJZCA9IG9yZGVyLmlkO1xuXHQgICAgICAgIGNvbnN0IHBheWVyID0gb3JkZXIucGF5ZXI7XG5cdCAgICAgICAgY29uc3Qgc2hpcHBpbmcgPSBnZXQob3JkZXIsIFwicHVyY2hhc2VfdW5pdHNbMF0uc2hpcHBpbmdcIik7XG5cdCAgICAgICAgY29uc3QgdXNlUGF5UGFsRW1haWwgPSBhd2FpdCBzaG91bGRVc2VQYXlQYWxFbWFpbChcblx0ICAgICAgICAgIGd1ZXN0LFxuXHQgICAgICAgICAgcmVxdWVzdCxcblx0ICAgICAgICAgIG9wdGlvbnMkMVxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIG1ldGhvZHMkOChyZXF1ZXN0KS51cGRhdGUoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyQxKHt9LCB1c2VQYXlQYWxFbWFpbCAmJiB7XG5cdCAgICAgICAgICBhY2NvdW50OiB7XG5cdCAgICAgICAgICAgIGVtYWlsOiBwYXllci5lbWFpbF9hZGRyZXNzXG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSksIHtcblx0ICAgICAgICAgIGJpbGxpbmc6IHtcblx0ICAgICAgICAgICAgbWV0aG9kOiBcInBheXBhbFwiLFxuXHQgICAgICAgICAgICBwYXlwYWw6IHsgb3JkZXJfaWQ6IG9yZGVySWQgfVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIHNoaXBwaW5nOiB7XG5cdCAgICAgICAgICAgIG5hbWU6IHNoaXBwaW5nLm5hbWUuZnVsbF9uYW1lLFxuXHQgICAgICAgICAgICBhZGRyZXNzMTogc2hpcHBpbmcuYWRkcmVzcy5hZGRyZXNzX2xpbmVfMSxcblx0ICAgICAgICAgICAgYWRkcmVzczI6IHNoaXBwaW5nLmFkZHJlc3MuYWRkcmVzc19saW5lXzIsXG5cdCAgICAgICAgICAgIHN0YXRlOiBzaGlwcGluZy5hZGRyZXNzLmFkbWluX2FyZWFfMSxcblx0ICAgICAgICAgICAgY2l0eTogc2hpcHBpbmcuYWRkcmVzcy5hZG1pbl9hcmVhXzIsXG5cdCAgICAgICAgICAgIHppcDogc2hpcHBpbmcuYWRkcmVzcy5wb3N0YWxfY29kZSxcblx0ICAgICAgICAgICAgY291bnRyeTogc2hpcHBpbmcuYWRkcmVzcy5jb3VudHJ5X2NvZGVcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KSk7XG5cdCAgICAgIH0pLnRoZW4ob25TdWNjZXNzKS5jYXRjaChvbkVycm9yKVxuXHQgICAgfSxcblx0ICAgIG9uRXJyb3Jcblx0ICApLnJlbmRlcihlbGVtZW50SWQgfHwgXCIjcGF5cGFsLWJ1dHRvblwiKTtcblx0fVxuXHRhc3luYyBmdW5jdGlvbiBicmFpbnRyZWVQYXlQYWxCdXR0b24ocmVxdWVzdCwgY2FydCwgcGF5TWV0aG9kcywgcGFyYW1zKSB7XG5cdCAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGF3YWl0IHZhdWx0UmVxdWVzdChcInBvc3RcIiwgXCIvYXV0aG9yaXphdGlvblwiLCB7XG5cdCAgICBnYXRld2F5OiBcImJyYWludHJlZVwiXG5cdCAgfSk7XG5cdCAgaWYgKGF1dGhvcml6YXRpb24uZXJyb3IpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihhdXRob3JpemF0aW9uLmVycm9yKTtcblx0ICB9XG5cdCAgY29uc3QgYnJhaW50cmVlID0gd2luZG93LmJyYWludHJlZTtcblx0ICBjb25zdCBwYXlwYWwgPSB3aW5kb3cucGF5cGFsO1xuXHQgIGJyYWludHJlZS5jbGllbnQuY3JlYXRlKHtcblx0ICAgIGF1dGhvcml6YXRpb25cblx0ICB9KS50aGVuKFxuXHQgICAgKGNsaWVudCkgPT4gYnJhaW50cmVlLnBheXBhbENoZWNrb3V0LmNyZWF0ZSh7XG5cdCAgICAgIGNsaWVudFxuXHQgICAgfSlcblx0ICApLnRoZW4oKHBheXBhbENoZWNrb3V0SW5zdGFuY2UpID0+IHtcblx0ICAgIHJldHVybiBwYXlwYWwuQnV0dG9ucyh7XG5cdCAgICAgIHN0eWxlOiBwYXJhbXMucGF5cGFsLnN0eWxlIHx8IHt9LFxuXHQgICAgICBjcmVhdGVCaWxsaW5nQWdyZWVtZW50OiAoKSA9PiBwYXlwYWxDaGVja291dEluc3RhbmNlLmNyZWF0ZVBheW1lbnQoe1xuXHQgICAgICAgIGZsb3c6IFwidmF1bHRcIixcblx0ICAgICAgICBjdXJyZW5jeTogY2FydC5jdXJyZW5jeSxcblx0ICAgICAgICBhbW91bnQ6IGNhcnQuZ3JhbmRfdG90YWxcblx0ICAgICAgfSksXG5cdCAgICAgIG9uQXBwcm92ZTogKGRhdGEsIGFjdGlvbnMpID0+IHBheXBhbENoZWNrb3V0SW5zdGFuY2UudG9rZW5pemVQYXltZW50KGRhdGEpLnRoZW4oXG5cdCAgICAgICAgKHsgbm9uY2UgfSkgPT4gbWV0aG9kcyQ4KHJlcXVlc3QsIG9wdGlvbnMkMSkudXBkYXRlKHtcblx0ICAgICAgICAgIGJpbGxpbmc6IHsgcGF5cGFsOiB7IG5vbmNlIH0gfVxuXHQgICAgICAgIH0pXG5cdCAgICAgICkudGhlbihcblx0ICAgICAgICAoKSA9PiBpc0Z1bmN0aW9uKHBhcmFtcy5wYXlwYWwub25TdWNjZXNzKSAmJiBwYXJhbXMucGF5cGFsLm9uU3VjY2VzcyhkYXRhLCBhY3Rpb25zKVxuXHQgICAgICApLmNhdGNoKFxuXHQgICAgICAgIGlzRnVuY3Rpb24ocGFyYW1zLnBheXBhbC5vbkVycm9yKSA/IHBhcmFtcy5wYXlwYWwub25FcnJvciA6IChlcnIpID0+IGNvbnNvbGUuZXJyb3IoXCJQYXlQYWwgZXJyb3JcIiwgZXJyKVxuXHQgICAgICApLFxuXHQgICAgICBvbkNhbmNlbDogaXNGdW5jdGlvbihwYXJhbXMucGF5cGFsLm9uQ2FuY2VsKSA/ICgpID0+IHBhcmFtcy5wYXlwYWwub25DYW5jZWwoKSA6ICgpID0+IGNvbnNvbGUubG9nKFwiUGF5UGFsIHBheW1lbnQgY2FuY2VsbGVkXCIpLFxuXHQgICAgICBvbkVycm9yOiBpc0Z1bmN0aW9uKHBhcmFtcy5wYXlwYWwub25FcnJvcikgPyAoZXJyKSA9PiBwYXJhbXMucGF5cGFsLm9uRXJyb3IoZXJyKSA6IChlcnIpID0+IGNvbnNvbGUuZXJyb3IoXCJQYXlQYWwgZXJyb3JcIiwgZXJyKVxuXHQgICAgfSkucmVuZGVyKHBhcmFtcy5wYXlwYWwuZWxlbWVudElkIHx8IFwiI3BheXBhbC1idXR0b25cIik7XG5cdCAgfSkuY2F0Y2goXG5cdCAgICBpc0Z1bmN0aW9uKHBhcmFtcy5wYXlwYWwub25FcnJvcikgPyBwYXJhbXMucGF5cGFsLm9uRXJyb3IgOiAoZXJyKSA9PiBjb25zb2xlLmVycm9yKFwiUGF5UGFsIGVycm9yXCIsIGVycilcblx0ICApO1xuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIHBheW1lbnRUb2tlbml6ZShyZXF1ZXN0LCBwYXJhbXMsIHBheU1ldGhvZHMsIGNhcnQpIHtcblx0ICBjb25zdCB7IGNhcHR1cmVfdG90YWwsIGF1dGhfdG90YWwgfSA9IGNhcnQ7XG5cdCAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuXHQgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gZ2V0KHBhcmFtcywgXCJjYXJkLm9uRXJyb3JcIikgfHwgZ2V0KHBhcmFtcywgXCJpZGVhbC5vbkVycm9yXCIpIHx8IGdldChwYXJhbXMsIFwia2xhcm5hLm9uRXJyb3JcIikgfHwgZ2V0KHBhcmFtcywgXCJiYW5jb250YWN0Lm9uRXJyb3JcIikgfHwgZ2V0KHBhcmFtcywgXCJwYXlzYWZlY2FyZC5vbkVycm9yXCIpO1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oZXJyb3JIYW5kbGVyKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGVycm9yKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcblx0ICB9O1xuXHQgIGNvbnN0IG9uU3VjY2VzcyA9IChyZXN1bHQpID0+IHtcblx0ICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gZ2V0KHBhcmFtcywgXCJjYXJkLm9uU3VjY2Vzc1wiKSB8fCBnZXQocGFyYW1zLCBcImlkZWFsLm9uU3VjY2Vzc1wiKTtcblx0ICAgIGlmIChpc0Z1bmN0aW9uKHN1Y2Nlc3NIYW5kbGVyKSkge1xuXHQgICAgICByZXR1cm4gc3VjY2Vzc0hhbmRsZXIocmVzdWx0KTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIGlmICghcGFyYW1zKSB7XG5cdCAgICByZXR1cm4gb25FcnJvcih7IG1lc3NhZ2U6IFwiVG9rZW5pemF0aW9uIHBhcmFtZXRlcnMgbm90IHBhc3NlZFwiIH0pO1xuXHQgIH1cblx0ICBpZiAocGFyYW1zLmNhcmQgJiYgcGF5TWV0aG9kcy5jYXJkKSB7XG5cdCAgICBpZiAocGF5TWV0aG9kcy5jYXJkLmdhdGV3YXkgPT09IFwic3RyaXBlXCIgJiYgQ0FSRF9FTEVNRU5UUy5zdHJpcGUgJiYgQVBJLnN0cmlwZSkge1xuXHQgICAgICBjb25zdCBzdHJpcGUgPSBBUEkuc3RyaXBlO1xuXHQgICAgICBjb25zdCBwYXltZW50TWV0aG9kID0gYXdhaXQgY3JlYXRlUGF5bWVudE1ldGhvZChcblx0ICAgICAgICBzdHJpcGUsXG5cdCAgICAgICAgQ0FSRF9FTEVNRU5UUy5zdHJpcGUsXG5cdCAgICAgICAgbWV0aG9kcyQyKHJlcXVlc3QpLmF1dGhvcml6ZUdhdGV3YXksXG5cdCAgICAgICAgY2FydFxuXHQgICAgICApLmNhdGNoKG9uRXJyb3IpO1xuXHQgICAgICBpZiAoIXBheW1lbnRNZXRob2QpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH0gZWxzZSBpZiAocGF5bWVudE1ldGhvZC5lcnJvcikge1xuXHQgICAgICAgIHJldHVybiBvbkVycm9yKHBheW1lbnRNZXRob2QuZXJyb3IpO1xuXHQgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVfdG90YWwgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zJDEpLnVwZGF0ZSh7XG5cdCAgICAgICAgICBiaWxsaW5nOiB7XG5cdCAgICAgICAgICAgIG1ldGhvZDogXCJjYXJkXCIsXG5cdCAgICAgICAgICAgIGNhcmQ6IHBheW1lbnRNZXRob2Rcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KS50aGVuKG9uU3VjY2VzcykuY2F0Y2gob25FcnJvcik7XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3QgY3VycmVuY3kgPSB0b0xvd2VyKGdldChjYXJ0LCBcImN1cnJlbmN5XCIsIFwidXNkXCIpKTtcblx0ICAgICAgY29uc3QgYW1vdW50ID0gc3RyaXBlQW1vdW50QnlDdXJyZW5jeShcblx0ICAgICAgICBjdXJyZW5jeSxcblx0ICAgICAgICBjYXB0dXJlX3RvdGFsICsgYXV0aF90b3RhbFxuXHQgICAgICApO1xuXHQgICAgICBjb25zdCBzdHJpcGVDdXN0b21lciA9IGdldChjYXJ0LCBcImFjY291bnQuc3RyaXBlX2N1c3RvbWVyXCIpO1xuXHQgICAgICBjb25zdCBpbnRlbnQgPSB0b1NuYWtlKFxuXHQgICAgICAgIGF3YWl0IG1ldGhvZHMkMihyZXF1ZXN0KS5jcmVhdGVJbnRlbnQoe1xuXHQgICAgICAgICAgZ2F0ZXdheTogXCJzdHJpcGVcIixcblx0ICAgICAgICAgIGludGVudDogX19zcHJlYWRWYWx1ZXMkMSh7XG5cdCAgICAgICAgICAgIHBheW1lbnRfbWV0aG9kOiBwYXltZW50TWV0aG9kLnRva2VuLFxuXHQgICAgICAgICAgICBhbW91bnQsXG5cdCAgICAgICAgICAgIGN1cnJlbmN5LFxuXHQgICAgICAgICAgICBjYXB0dXJlX21ldGhvZDogXCJtYW51YWxcIixcblx0ICAgICAgICAgICAgb2ZmX3Nlc3Npb246IHRydWUsXG5cdCAgICAgICAgICAgIGNvbmZpcm06IHRydWVcblx0ICAgICAgICAgIH0sIHN0cmlwZUN1c3RvbWVyID8geyBjdXN0b21lcjogc3RyaXBlQ3VzdG9tZXIgfSA6IHt9KVxuXHQgICAgICAgIH0pLmNhdGNoKG9uRXJyb3IpXG5cdCAgICAgICk7XG5cdCAgICAgIGlmIChpbnRlbnQgJiYgaW50ZW50LnN0YXR1cyA9PT0gXCJyZXF1aXJlc19jb25maXJtYXRpb25cIikge1xuXHQgICAgICAgIGNvbnN0IHsgcGF5bWVudEludGVudCwgZXJyb3IgfSA9IGF3YWl0IHN0cmlwZS5jb25maXJtQ2FyZFBheW1lbnQoXG5cdCAgICAgICAgICBpbnRlbnQuY2xpZW50X3NlY3JldFxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yID8gb25FcnJvcihlcnJvcikgOiBhd2FpdCBtZXRob2RzJDgocmVxdWVzdCwgb3B0aW9ucyQxKS51cGRhdGUoe1xuXHQgICAgICAgICAgYmlsbGluZzoge1xuXHQgICAgICAgICAgICBtZXRob2Q6IFwiY2FyZFwiLFxuXHQgICAgICAgICAgICBjYXJkOiBwYXltZW50TWV0aG9kLFxuXHQgICAgICAgICAgICBpbnRlbnQ6IHtcblx0ICAgICAgICAgICAgICBzdHJpcGU6IF9fc3ByZWFkVmFsdWVzJDEoe1xuXHQgICAgICAgICAgICAgICAgaWQ6IHBheW1lbnRJbnRlbnQuaWRcblx0ICAgICAgICAgICAgICB9LCAhIWF1dGhfdG90YWwgJiYge1xuXHQgICAgICAgICAgICAgICAgYXV0aF9hbW91bnQ6IGF1dGhfdG90YWxcblx0ICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSkudGhlbihvblN1Y2Nlc3MpLmNhdGNoKG9uRXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHBheU1ldGhvZHMuY2FyZC5nYXRld2F5ID09PSBcInF1aWNrcGF5XCIpIHtcblx0ICAgICAgY29uc3QgaW50ZW50ID0gYXdhaXQgY3JlYXRlUXVpY2twYXlQYXltZW50KFxuXHQgICAgICAgIGNhcnQsXG5cdCAgICAgICAgbWV0aG9kcyQyKHJlcXVlc3QpLmNyZWF0ZUludGVudFxuXHQgICAgICApLmNhdGNoKG9uRXJyb3IpO1xuXHQgICAgICBpZiAoIWludGVudCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfSBlbHNlIGlmIChpbnRlbnQuZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gb25FcnJvcihpbnRlbnQuZXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICAgIGF3YWl0IG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zJDEpLnVwZGF0ZSh7XG5cdCAgICAgICAgYmlsbGluZzoge1xuXHQgICAgICAgICAgbWV0aG9kOiBcImNhcmRcIixcblx0ICAgICAgICAgIGludGVudDoge1xuXHQgICAgICAgICAgICBxdWlja3BheToge1xuXHQgICAgICAgICAgICAgIGlkOiBpbnRlbnRcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIGNyZWF0ZVF1aWNrcGF5Q2FyZChtZXRob2RzJDIocmVxdWVzdCkuYXV0aG9yaXplR2F0ZXdheSkuY2F0Y2gob25FcnJvcik7XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmIChwYXJhbXMuaWRlYWwgJiYgcGF5TWV0aG9kcy5pZGVhbCkge1xuXHQgICAgaWYgKHBheU1ldGhvZHMuY2FyZCAmJiBwYXlNZXRob2RzLmNhcmQuZ2F0ZXdheSA9PT0gXCJzdHJpcGVcIiAmJiBDQVJEX0VMRU1FTlRTLnN0cmlwZSAmJiBBUEkuc3RyaXBlKSB7XG5cdCAgICAgIGNvbnN0IHsgZXJyb3IsIHBheW1lbnRNZXRob2QgfSA9IGF3YWl0IGNyZWF0ZUlEZWFsUGF5bWVudE1ldGhvZChcblx0ICAgICAgICBBUEkuc3RyaXBlLFxuXHQgICAgICAgIENBUkRfRUxFTUVOVFMuc3RyaXBlLFxuXHQgICAgICAgIGNhcnRcblx0ICAgICAgKTtcblx0ICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICAgIGNvbnN0IGN1cnJlbmN5ID0gdG9Mb3dlcihnZXQoY2FydCwgXCJjdXJyZW5jeVwiLCBcImV1clwiKSk7XG5cdCAgICAgIGNvbnN0IGFtb3VudCA9IHN0cmlwZUFtb3VudEJ5Q3VycmVuY3koY3VycmVuY3ksIGNhcHR1cmVfdG90YWwpO1xuXHQgICAgICBjb25zdCBpbnRlbnQgPSB0b1NuYWtlKFxuXHQgICAgICAgIGF3YWl0IG1ldGhvZHMkMihyZXF1ZXN0KS5jcmVhdGVJbnRlbnQoe1xuXHQgICAgICAgICAgZ2F0ZXdheTogXCJzdHJpcGVcIixcblx0ICAgICAgICAgIGludGVudDoge1xuXHQgICAgICAgICAgICBwYXltZW50X21ldGhvZDogcGF5bWVudE1ldGhvZC5pZCxcblx0ICAgICAgICAgICAgYW1vdW50LFxuXHQgICAgICAgICAgICBjdXJyZW5jeSxcblx0ICAgICAgICAgICAgcGF5bWVudF9tZXRob2RfdHlwZXM6IFwiaWRlYWxcIixcblx0ICAgICAgICAgICAgY29uZmlybWF0aW9uX21ldGhvZDogXCJtYW51YWxcIixcblx0ICAgICAgICAgICAgY29uZmlybTogdHJ1ZSxcblx0ICAgICAgICAgICAgcmV0dXJuX3VybDogd2luZG93LmxvY2F0aW9uLmhyZWZcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KS5jYXRjaChvbkVycm9yKVxuXHQgICAgICApO1xuXHQgICAgICBpZiAoaW50ZW50KSB7XG5cdCAgICAgICAgYXdhaXQgbWV0aG9kcyQ4KHJlcXVlc3QsIG9wdGlvbnMkMSkudXBkYXRlKHtcblx0ICAgICAgICAgIGJpbGxpbmc6IHtcblx0ICAgICAgICAgICAgbWV0aG9kOiBcImlkZWFsXCIsXG5cdCAgICAgICAgICAgIGlkZWFsOiB7XG5cdCAgICAgICAgICAgICAgdG9rZW46IHBheW1lbnRNZXRob2QuaWRcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgaW50ZW50OiB7IHN0cmlwZTogeyBpZDogaW50ZW50LmlkIH0gfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pLmNhdGNoKG9uRXJyb3IpO1xuXHQgICAgICAgIHJldHVybiAoaW50ZW50LnN0YXR1cyA9PT0gXCJyZXF1aXJlc19hY3Rpb25cIiB8fCBpbnRlbnQuc3RhdHVzID09PSBcInJlcXVpcmVzX3NvdXJjZV9hY3Rpb25cIikgJiYgYXdhaXQgQVBJLnN0cmlwZS5oYW5kbGVDYXJkQWN0aW9uKGludGVudC5jbGllbnRfc2VjcmV0KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAocGFyYW1zLmtsYXJuYSAmJiBwYXlNZXRob2RzLmtsYXJuYSkge1xuXHQgICAgaWYgKHBheU1ldGhvZHMua2xhcm5hLmdhdGV3YXkgPT09IFwia2xhcm5hXCIpIHtcblx0ICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGNyZWF0ZUtsYXJuYVNlc3Npb24oXG5cdCAgICAgICAgY2FydCxcblx0ICAgICAgICBtZXRob2RzJDIocmVxdWVzdCkuY3JlYXRlSW50ZW50XG5cdCAgICAgICkuY2F0Y2gob25FcnJvcik7XG5cdCAgICAgIHJldHVybiBzZXNzaW9uICYmIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHNlc3Npb24ucmVkaXJlY3RfdXJsKTtcblx0ICAgIH0gZWxzZSBpZiAocGF5TWV0aG9kcy5jYXJkICYmIHBheU1ldGhvZHMuY2FyZC5nYXRld2F5ID09PSBcInN0cmlwZVwiKSB7XG5cdCAgICAgIGlmICghd2luZG93LlN0cmlwZSkge1xuXHQgICAgICAgIGF3YWl0IGxvYWRTY3JpcHQoXCJzdHJpcGUtanNcIiwgXCJodHRwczovL2pzLnN0cmlwZS5jb20vdjMvXCIpO1xuXHQgICAgICB9XG5cdCAgICAgIGNvbnN0IHsgcHVibGlzaGFibGVfa2V5IH0gPSBwYXlNZXRob2RzLmNhcmQ7XG5cdCAgICAgIGNvbnN0IHN0cmlwZSA9IHdpbmRvdy5TdHJpcGUocHVibGlzaGFibGVfa2V5KTtcblx0ICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0b1NuYWtlKGF3YWl0IG1ldGhvZHMkMyhyZXF1ZXN0LCBvcHRpb25zJDEpLmdldCgpKTtcblx0ICAgICAgY29uc3QgeyBlcnJvciwgc291cmNlIH0gPSBhd2FpdCBjcmVhdGVLbGFybmFTb3VyY2Uoc3RyaXBlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzJDEoe30sIGNhcnQpLCB7XG5cdCAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzLnN0b3JlXG5cdCAgICAgIH0pKTtcblx0ICAgICAgcmV0dXJuIGVycm9yID8gb25FcnJvcihlcnJvcikgOiBtZXRob2RzJDgocmVxdWVzdCwgb3B0aW9ucyQxKS51cGRhdGUoe1xuXHQgICAgICAgIGJpbGxpbmc6IHtcblx0ICAgICAgICAgIG1ldGhvZDogXCJrbGFybmFcIlxuXHQgICAgICAgIH1cblx0ICAgICAgfSkudGhlbigoKSA9PiB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShzb3VyY2UucmVkaXJlY3QudXJsKSkuY2F0Y2gob25FcnJvcik7XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmIChwYXJhbXMuYmFuY29udGFjdCAmJiBwYXlNZXRob2RzLmJhbmNvbnRhY3QpIHtcblx0ICAgIGlmIChwYXlNZXRob2RzLmNhcmQgJiYgcGF5TWV0aG9kcy5jYXJkLmdhdGV3YXkgPT09IFwic3RyaXBlXCIpIHtcblx0ICAgICAgaWYgKCF3aW5kb3cuU3RyaXBlKSB7XG5cdCAgICAgICAgYXdhaXQgbG9hZFNjcmlwdChcInN0cmlwZS1qc1wiLCBcImh0dHBzOi8vanMuc3RyaXBlLmNvbS92My9cIik7XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3QgeyBwdWJsaXNoYWJsZV9rZXkgfSA9IHBheU1ldGhvZHMuY2FyZDtcblx0ICAgICAgY29uc3Qgc3RyaXBlID0gd2luZG93LlN0cmlwZShwdWJsaXNoYWJsZV9rZXkpO1xuXHQgICAgICBjb25zdCB7IGVycm9yLCBzb3VyY2UgfSA9IGF3YWl0IGNyZWF0ZUJhbmNvbnRhY3RTb3VyY2Uoc3RyaXBlLCBjYXJ0KTtcblx0ICAgICAgcmV0dXJuIGVycm9yID8gb25FcnJvcihlcnJvcikgOiBtZXRob2RzJDgocmVxdWVzdCwgb3B0aW9ucyQxKS51cGRhdGUoe1xuXHQgICAgICAgIGJpbGxpbmc6IHtcblx0ICAgICAgICAgIG1ldGhvZDogXCJiYW5jb250YWN0XCJcblx0ICAgICAgICB9XG5cdCAgICAgIH0pLnRoZW4oKCkgPT4gd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uoc291cmNlLnJlZGlyZWN0LnVybCkpLmNhdGNoKG9uRXJyb3IpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAocGFyYW1zLnBheXNhZmVjYXJkICYmIHBheU1ldGhvZHMucGF5c2FmZWNhcmQpIHtcblx0ICAgIGNvbnN0IGludGVudCA9IGF3YWl0IGNyZWF0ZVBheXNhZmVjYXJkUGF5bWVudChcblx0ICAgICAgY2FydCxcblx0ICAgICAgbWV0aG9kcyQyKHJlcXVlc3QpLmNyZWF0ZUludGVudFxuXHQgICAgKS5jYXRjaChvbkVycm9yKTtcblx0ICAgIGlmICghaW50ZW50KSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGF3YWl0IG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zJDEpLnVwZGF0ZSh7XG5cdCAgICAgIGJpbGxpbmc6IHtcblx0ICAgICAgICBtZXRob2Q6IFwicGF5c2FmZWNhcmRcIixcblx0ICAgICAgICBpbnRlbnQ6IHtcblx0ICAgICAgICAgIHBheXNhZmVjYXJkOiB7XG5cdCAgICAgICAgICAgIGlkOiBpbnRlbnQuaWRcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGludGVudC5yZWRpcmVjdC5hdXRoX3VybCk7XG5cdCAgfVxuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlZGlyZWN0KHJlcXVlc3QsIHBhcmFtcywgY2FydCkge1xuXHQgIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpID0+IHtcblx0ICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGdldChwYXJhbXMsIFwiY2FyZC5vbkVycm9yXCIpIHx8IGdldChwYXJhbXMsIFwicGF5c2FmZWNhcmQub25FcnJvclwiKSB8fCBnZXQocGFyYW1zLCBcImtsYXJuYS5vbkVycm9yXCIpO1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oZXJyb3JIYW5kbGVyKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGVycm9yKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcblx0ICB9O1xuXHQgIGNvbnN0IG9uU3VjY2VzcyA9IChyZXN1bHQyKSA9PiB7XG5cdCAgICBjb25zdCBzdWNjZXNzSGFuZGxlciA9IGdldChwYXJhbXMsIFwiY2FyZC5vblN1Y2Nlc3NcIikgfHwgZ2V0KHBhcmFtcywgXCJwYXlzYWZlY2FyZC5vblN1Y2Nlc3NcIikgfHwgZ2V0KHBhcmFtcywgXCJrbGFybmEub25TdWNjZXNzXCIpO1xuXHQgICAgaWYgKGlzRnVuY3Rpb24oc3VjY2Vzc0hhbmRsZXIpKSB7XG5cdCAgICAgIHJldHVybiBzdWNjZXNzSGFuZGxlcihyZXN1bHQyKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gZ2V0TG9jYXRpb25QYXJhbXMod2luZG93LmxvY2F0aW9uKTtcblx0ICByZW1vdmVVcmxQYXJhbXMoKTtcblx0ICBjb25zdCB7IGdhdGV3YXkgfSA9IHF1ZXJ5UGFyYW1zO1xuXHQgIGxldCByZXN1bHQ7XG5cdCAgaWYgKGdhdGV3YXkgPT09IFwicXVpY2twYXlcIikge1xuXHQgICAgcmVzdWx0ID0gYXdhaXQgaGFuZGxlUXVpY2twYXlSZWRpcmVjdEFjdGlvbihcblx0ICAgICAgcmVxdWVzdCxcblx0ICAgICAgY2FydCxcblx0ICAgICAgcGFyYW1zLFxuXHQgICAgICBxdWVyeVBhcmFtc1xuXHQgICAgKTtcblx0ICB9IGVsc2UgaWYgKGdhdGV3YXkgPT09IFwicGF5c2FmZWNhcmRcIikge1xuXHQgICAgcmVzdWx0ID0gYXdhaXQgaGFuZGxlUGF5c2FmZWNhcmRSZWRpcmVjdEFjdGlvbihcblx0ICAgICAgcmVxdWVzdCxcblx0ICAgICAgY2FydCk7XG5cdCAgfSBlbHNlIGlmIChnYXRld2F5ID09PSBcImtsYXJuYV9kaXJlY3RcIikge1xuXHQgICAgcmVzdWx0ID0gYXdhaXQgaGFuZGxlRGlyZWN0S2xhcm5hUmVkaXJlY3RBY3Rpb24oXG5cdCAgICAgIHJlcXVlc3QsXG5cdCAgICAgIGNhcnQsXG5cdCAgICAgIHBhcmFtcyxcblx0ICAgICAgcXVlcnlQYXJhbXNcblx0ICAgICk7XG5cdCAgfVxuXHQgIGlmICghcmVzdWx0KSB7XG5cdCAgICByZXR1cm47XG5cdCAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IpIHtcblx0ICAgIHJldHVybiBvbkVycm9yKHJlc3VsdC5lcnJvcik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBvblN1Y2Nlc3MocmVzdWx0KTtcblx0ICB9XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gaGFuZGxlUXVpY2twYXlSZWRpcmVjdEFjdGlvbihyZXF1ZXN0LCBjYXJ0LCBwYXJhbXMsIHF1ZXJ5UGFyYW1zKSB7XG5cdCAgY29uc3QgeyByZWRpcmVjdF9zdGF0dXM6IHN0YXR1cywgY2FyZF9pZDogaWQgfSA9IHF1ZXJ5UGFyYW1zO1xuXHQgIHN3aXRjaCAoc3RhdHVzKSB7XG5cdCAgICBjYXNlIFwic3VjY2VlZGVkXCI6XG5cdCAgICAgIGNvbnN0IGNhcmQgPSBhd2FpdCBnZXRRdWlja3BheUNhcmREZXRhaXMoXG5cdCAgICAgICAgaWQsXG5cdCAgICAgICAgbWV0aG9kcyQyKHJlcXVlc3QpLmF1dGhvcml6ZUdhdGV3YXlcblx0ICAgICAgKTtcblx0ICAgICAgaWYgKCFjYXJkKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9IGVsc2UgaWYgKGNhcmQuZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gY2FyZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBhd2FpdCBtZXRob2RzJDgocmVxdWVzdCwgb3B0aW9ucyQxKS51cGRhdGUoe1xuXHQgICAgICAgICAgYmlsbGluZzoge1xuXHQgICAgICAgICAgICBtZXRob2Q6IFwiY2FyZFwiLFxuXHQgICAgICAgICAgICBjYXJkXG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuXHQgICAgICB9XG5cdCAgICBjYXNlIFwiY2FuY2VsZWRcIjpcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBlcnJvcjoge1xuXHQgICAgICAgICAgbWVzc2FnZTogXCJXZSBhcmUgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSB5b3VyIHBheW1lbnQgbWV0aG9kLiBQbGVhc2UgY2hvb3NlIGEgZGlmZmVyZW50IHBheW1lbnQgbWV0aG9kIGFuZCB0cnkgYWdhaW4uXCJcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICByZXR1cm4geyBlcnJvcjogeyBtZXNzYWdlOiBgVW5rbm93biByZWRpcmVjdCBzdGF0dXM6ICR7c3RhdHVzfS5gIH0gfTtcblx0ICB9XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gaGFuZGxlUGF5c2FmZWNhcmRSZWRpcmVjdEFjdGlvbihyZXF1ZXN0LCBjYXJ0KSB7XG5cdCAgY29uc3QgcGF5bWVudElkID0gZ2V0KGNhcnQsIFwiYmlsbGluZy5pbnRlbnQucGF5c2FmZWNhcmQuaWRcIik7XG5cdCAgaWYgKCFwYXltZW50SWQpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGVycm9yOiB7XG5cdCAgICAgICAgbWVzc2FnZTogXCJQYXlzYWZlY2FyZCBwYXltZW50IElEIG5vdCBkZWZpbmVkLlwiXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHQgIGNvbnN0IGludGVudCA9IGF3YWl0IG1ldGhvZHMkMihyZXF1ZXN0KS51cGRhdGVJbnRlbnQoe1xuXHQgICAgZ2F0ZXdheTogXCJwYXlzYWZlY2FyZFwiLFxuXHQgICAgaW50ZW50OiB7IHBheW1lbnRfaWQ6IHBheW1lbnRJZCB9XG5cdCAgfSk7XG5cdCAgaWYgKCFpbnRlbnQpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgc3dpdGNoIChpbnRlbnQuc3RhdHVzKSB7XG5cdCAgICBjYXNlIFwiQVVUSE9SSVpFRFwiOlxuXHQgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG5cdCAgICBjYXNlIFwiQ0FOQ0VMRURfQ1VTVE9NRVJcIjpcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBlcnJvcjoge1xuXHQgICAgICAgICAgbWVzc2FnZTogXCJXZSBhcmUgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSB5b3VyIHBheW1lbnQgbWV0aG9kLiBQbGVhc2UgY2hvb3NlIGEgZGlmZmVyZW50IHBheW1lbnQgbWV0aG9kIGFuZCB0cnkgYWdhaW4uXCJcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6IGBVbmtub3duIHJlZGlyZWN0IHN0YXR1czogJHtpbnRlbnQuc3RhdHVzfS5gIH1cblx0ICAgICAgfTtcblx0ICB9XG5cdH1cblx0YXN5bmMgZnVuY3Rpb24gaGFuZGxlRGlyZWN0S2xhcm5hUmVkaXJlY3RBY3Rpb24ocmVxdWVzdCwgY2FydCwgcGFyYW1zLCBxdWVyeVBhcmFtcykge1xuXHQgIGNvbnN0IHsgYXV0aG9yaXphdGlvbl90b2tlbiB9ID0gcXVlcnlQYXJhbXM7XG5cdCAgaWYgKCFhdXRob3JpemF0aW9uX3Rva2VuKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBlcnJvcjoge1xuXHQgICAgICAgIG1lc3NhZ2U6IFwiV2UgYXJlIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgeW91ciBwYXltZW50IG1ldGhvZC4gUGxlYXNlIGNob29zZSBhIGRpZmZlcmVudCBwYXltZW50IG1ldGhvZCBhbmQgdHJ5IGFnYWluLlwiXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHQgIGF3YWl0IG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zJDEpLnVwZGF0ZSh7XG5cdCAgICBiaWxsaW5nOiB7XG5cdCAgICAgIG1ldGhvZDogXCJrbGFybmFcIixcblx0ICAgICAga2xhcm5hOiB7XG5cdCAgICAgICAgdG9rZW46IGF1dGhvcml6YXRpb25fdG9rZW5cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcblx0fVxuXHRhc3luYyBmdW5jdGlvbiBhdXRoZW50aWNhdGUocmVxdWVzdCwgcGF5bWVudCwgcGF5TWV0aG9kcykge1xuXHQgIGNvbnN0IHsgbWV0aG9kLCBnYXRld2F5IH0gPSBwYXltZW50O1xuXHQgIGlmIChtZXRob2QgPT09IFwiY2FyZFwiKSB7XG5cdCAgICBjb25zdCBjYXJkTWV0aG9kID0gcGF5TWV0aG9kcy5jYXJkO1xuXHQgICAgaWYgKCFjYXJkTWV0aG9kKSB7XG5cdCAgICAgIGNvbnNvbGUuZXJyb3IoXG5cdCAgICAgICAgYEF1dGhlbnRpY2F0ZSBlcnJvcjogY3JlZGl0IGNhcmQgcGF5bWVudHMgYXJlIGRpc2FibGVkLiBTZWUgUGF5bWVudCBzZXR0aW5ncyBpbiB0aGUgU3dlbGwgZGFzaGJvYXJkIGZvciBkZXRhaWxzLmBcblx0ICAgICAgKTtcblx0ICAgIH0gZWxzZSBpZiAoZ2F0ZXdheSA9PT0gXCJzdHJpcGVcIiAmJiBjYXJkTWV0aG9kLmdhdGV3YXkgPT09IFwic3RyaXBlXCIpIHtcblx0ICAgICAgaWYgKCF3aW5kb3cuU3RyaXBlKSB7XG5cdCAgICAgICAgYXdhaXQgbG9hZFNjcmlwdChcInN0cmlwZS1qc1wiLCBcImh0dHBzOi8vanMuc3RyaXBlLmNvbS92My9cIik7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0ZVN0cmlwZUNhcmQocmVxdWVzdCwgcGF5bWVudCwgcGF5TWV0aG9kcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGFzeW5jIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZVN0cmlwZUNhcmQocmVxdWVzdCwgcGF5bWVudCwgcGF5TWV0aG9kcykge1xuXHQgIGNvbnN0IHsgdHJhbnNhY3Rpb25faWQ6IGlkLCBjYXJkOiB7IHRva2VuIH0gPSB7fSB9ID0gcGF5bWVudDtcblx0ICBjb25zdCB7IHB1Ymxpc2hhYmxlX2tleSB9ID0gcGF5TWV0aG9kcy5jYXJkO1xuXHQgIGNvbnN0IGludGVudCA9IGF3YWl0IG1ldGhvZHMkMihyZXF1ZXN0LCBvcHRpb25zJDEpLnVwZGF0ZUludGVudCh7XG5cdCAgICBnYXRld2F5OiBcInN0cmlwZVwiLFxuXHQgICAgaW50ZW50OiB7IGlkLCBwYXltZW50X21ldGhvZDogdG9rZW4gfVxuXHQgIH0pLmNhdGNoKChlcnJvcikgPT4gKHtcblx0ICAgIGVycm9yXG5cdCAgfSkpO1xuXHQgIGlmIChpbnRlbnQuZXJyb3IpIHtcblx0ICAgIHJldHVybiBpbnRlbnQ7XG5cdCAgfVxuXHQgIGNvbnN0IHN0cmlwZSA9IHdpbmRvdy5TdHJpcGUocHVibGlzaGFibGVfa2V5KTtcblx0ICBjb25zdCBhY3Rpb25SZXN1bHQgPSBhd2FpdCBzdHJpcGUuY29uZmlybUNhcmRQYXltZW50KGludGVudC5jbGllbnRfc2VjcmV0KTtcblx0ICByZXR1cm4gYWN0aW9uUmVzdWx0LmVycm9yID8ge1xuXHQgICAgZXJyb3I6IHtcblx0ICAgICAgbWVzc2FnZTogYWN0aW9uUmVzdWx0LmVycm9yLm1lc3NhZ2UsXG5cdCAgICAgIGNvZGU6IGFjdGlvblJlc3VsdC5lcnJvci5jb2RlXG5cdCAgICB9XG5cdCAgfSA6IHsgc3RhdHVzOiBhY3Rpb25SZXN1bHQuc3RhdHVzIH07XG5cdH1cblxuXHRmdW5jdGlvbiBtZXRob2RzJDEocmVxdWVzdCwgb3B0KSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGNvZGU6IG51bGwsXG5cdCAgICBzdGF0ZTogbnVsbCxcblx0ICAgIGxpc3QoKSB7XG5cdCAgICAgIHJldHVybiBvcHQuYXBpLnNldHRpbmdzLmdldChcInN0b3JlLmxvY2FsZXNcIiwgW10pO1xuXHQgICAgfSxcblx0ICAgIGFzeW5jIHNlbGVjdChsb2NhbGUpIHtcblx0ICAgICAgdGhpcy5zZXQobG9jYWxlKTtcblx0ICAgICAgc2V0Q29va2llKFwic3dlbGwtbG9jYWxlXCIsIGxvY2FsZSk7XG5cdCAgICAgIG9wdC5hcGkuc2V0dGluZ3MubG9jYWxlID0gbG9jYWxlO1xuXHQgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdChcInB1dFwiLCBcIi9zZXNzaW9uXCIsIHsgbG9jYWxlIH0pO1xuXHQgICAgfSxcblx0ICAgIHNlbGVjdGVkKCkge1xuXHQgICAgICBpZiAodGhpcy5jb2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuY29kZTtcblx0ICAgICAgfVxuXHQgICAgICBjb25zdCBzdG9yZUxvY2FsZSA9IG9wdC5hcGkuc2V0dGluZ3MuZ2V0U3RvcmVMb2NhbGUoKTtcblx0ICAgICAgY29uc3QgY29va2llTG9jYWxlID0gZ2V0Q29va2llKFwic3dlbGwtbG9jYWxlXCIpO1xuXHQgICAgICBvcHQuYXBpLnNldHRpbmdzLmxvY2FsZSA9IGNvb2tpZUxvY2FsZSB8fCBzdG9yZUxvY2FsZTtcblx0ICAgICAgcmV0dXJuIGNvb2tpZUxvY2FsZSB8fCBzdG9yZUxvY2FsZTtcblx0ICAgIH0sXG5cdCAgICBnZXQoKSB7XG5cdCAgICAgIGlmICghdGhpcy5jb2RlKSB7XG5cdCAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5zZWxlY3RlZCgpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghdGhpcy5zdGF0ZSkge1xuXHQgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnNldCh0aGlzLmNvZGUpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuXHQgICAgfSxcblx0ICAgIHNldChjb2RlKSB7XG5cdCAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG5cdCAgICAgIHRoaXMuc3RhdGUgPSBmaW5kKHRoaXMubGlzdCgpLCB7IGNvZGUgfSkgfHwge307XG5cdCAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuXHRjb25zdCBGT1JNQVRURVJTID0ge307XG5cdGZ1bmN0aW9uIG1ldGhvZHMocmVxdWVzdCwgb3B0KSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGNvZGU6IG51bGwsXG5cdCAgICBzdGF0ZTogbnVsbCxcblx0ICAgIGxvY2FsZTogbnVsbCxcblx0ICAgIGxpc3QoKSB7XG5cdCAgICAgIHJldHVybiBvcHQuYXBpLnNldHRpbmdzLmdldChcInN0b3JlLmN1cnJlbmNpZXNcIiwgW10pO1xuXHQgICAgfSxcblx0ICAgIGFzeW5jIHNlbGVjdChjdXJyZW5jeSkge1xuXHQgICAgICB0aGlzLnNldChjdXJyZW5jeSk7XG5cdCAgICAgIHJldHVybiByZXF1ZXN0KFwicHV0XCIsIFwiL3Nlc3Npb25cIiwgeyBjdXJyZW5jeSB9KTtcblx0ICAgIH0sXG5cdCAgICBzZWxlY3RlZCgpIHtcblx0ICAgICAgaWYgKCF0aGlzLmNvZGUpIHtcblx0ICAgICAgICB0aGlzLnNldChcblx0ICAgICAgICAgIGdldENvb2tpZShcInN3ZWxsLWN1cnJlbmN5XCIpIHx8IG9wdC5hcGkuc2V0dGluZ3MuZ2V0KFwic3RvcmUuY3VycmVuY3lcIilcblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLmNvZGU7XG5cdCAgICB9LFxuXHQgICAgZ2V0KCkge1xuXHQgICAgICBpZiAoIXRoaXMuY29kZSkge1xuXHQgICAgICAgIHRoaXMuY29kZSA9IHRoaXMuc2VsZWN0ZWQoKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIXRoaXMuc3RhdGUpIHtcblx0ICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zZXQodGhpcy5jb2RlKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcblx0ICAgIH0sXG5cdCAgICBzZXQoY29kZSA9IFwiVVNEXCIpIHtcblx0ICAgICAgdGhpcy5jb2RlID0gY29kZTtcblx0ICAgICAgdGhpcy5zdGF0ZSA9IGZpbmQodGhpcy5saXN0KCksIHsgY29kZSB9KSB8fCB7IGNvZGUgfTtcblx0ICAgICAgdGhpcy5sb2NhbGUgPSBTdHJpbmcoXG5cdCAgICAgICAgb3B0LmFwaS5zZXR0aW5ncy5nZXQoXG5cdCAgICAgICAgICBcInN0b3JlLmxvY2FsZVwiLFxuXHQgICAgICAgICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiA/IG5hdmlnYXRvci5sYW5ndWFnZSA6IFwiZW4tVVNcIlxuXHQgICAgICAgIClcblx0ICAgICAgKTtcblx0ICAgICAgc2V0Q29va2llKFwic3dlbGwtY3VycmVuY3lcIiwgY29kZSk7XG5cdCAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuXHQgICAgfSxcblx0ICAgIGZvcm1hdChhbW91bnQsIHBhcmFtcyA9IHt9KSB7XG5cdCAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG5cdCAgICAgIGlmIChwYXJhbXMuY29kZSAmJiBwYXJhbXMuY29kZSAhPT0gc3RhdGUuY29kZSkge1xuXHQgICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmxpc3QoKTtcblx0ICAgICAgICBzdGF0ZSA9IGZpbmQobGlzdCwgeyBjb2RlOiBwYXJhbXMuY29kZSB9KSB8fCB7IGNvZGU6IHBhcmFtcy5jb2RlIH07XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3QgeyBjb2RlID0gXCJVU0RcIiwgdHlwZSwgZGVjaW1hbHMsIHJhdGUgfSA9IHN0YXRlO1xuXHQgICAgICBjb25zdCBmb3JtYXRDb2RlID0gcGFyYW1zLmNvZGUgfHwgY29kZTtcblx0ICAgICAgY29uc3QgZm9ybWF0UmF0ZSA9IHBhcmFtcy5yYXRlIHx8IHJhdGU7XG5cdCAgICAgIGNvbnN0IGZvcm1hdExvY2FsZSA9IHBhcmFtcy5sb2NhbGUgfHwgdGhpcy5sb2NhbGU7XG5cdCAgICAgIGNvbnN0IGZvcm1hdERlY2ltYWxzID0gdHlwZW9mIHBhcmFtcy5kZWNpbWFscyA9PT0gXCJudW1iZXJcIiA/IHBhcmFtcy5kZWNpbWFscyA6IGRlY2ltYWxzO1xuXHQgICAgICBjb25zdCB7IGNvbnZlcnQgPSB0cnVlIH0gPSBwYXJhbXM7XG5cdCAgICAgIGxldCBmb3JtYXRBbW91bnQgPSBhbW91bnQ7XG5cdCAgICAgIGlmIChjb252ZXJ0ICYmICh0eXBlID09PSBcImRpc3BsYXlcIiB8fCBwYXJhbXMucmF0ZSkgJiYgdHlwZW9mIGZvcm1hdEFtb3VudCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZm9ybWF0UmF0ZSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgIGZvcm1hdEFtb3VudCA9IHRoaXMuYXBwbHlSb3VuZGluZyhhbW91bnQgKiBmb3JtYXRSYXRlLCBzdGF0ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3QgZm9ybWF0dGVyID0gdGhpcy5mb3JtYXR0ZXIoe1xuXHQgICAgICAgIGNvZGU6IGZvcm1hdENvZGUsXG5cdCAgICAgICAgbG9jYWxlOiBmb3JtYXRMb2NhbGUsXG5cdCAgICAgICAgZGVjaW1hbHM6IGZvcm1hdERlY2ltYWxzXG5cdCAgICAgIH0pO1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0QW1vdW50ID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChmb3JtYXRBbW91bnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjb25zdCBzeW1ib2wgPSBnZXQoZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoMCksIFwiMC52YWx1ZVwiLCBcIiRcIik7XG5cdCAgICAgICAgICByZXR1cm4gc3ltYm9sICE9PSBmb3JtYXRDb2RlID8gc3ltYm9sIDogXCJcIjtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBTdHJpbmcoYW1vdW50KTtcblx0ICAgIH0sXG5cdCAgICBmb3JtYXR0ZXIoeyBjb2RlLCBsb2NhbGUsIGRlY2ltYWxzIH0pIHtcblx0ICAgICAgbG9jYWxlID0gU3RyaW5nKGxvY2FsZSB8fCBcIlwiKS5yZXBsYWNlKFwiX1wiLCBcIi1cIik7XG5cdCAgICAgIGNvbnN0IGtleSA9IFtjb2RlLCBsb2NhbGUsIGRlY2ltYWxzXS5qb2luKFwifFwiKTtcblx0ICAgICAgaWYgKEZPUk1BVFRFUlNba2V5XSkge1xuXHQgICAgICAgIHJldHVybiBGT1JNQVRURVJTW2tleV07XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3QgZm9ybWF0TG9jYWxlcyA9IFtdO1xuXHQgICAgICBpZiAobG9jYWxlKSB7XG5cdCAgICAgICAgZm9ybWF0TG9jYWxlcy5wdXNoKGxvY2FsZSk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9ybWF0TG9jYWxlcy5wdXNoKFwiZW4tVVNcIik7XG5cdCAgICAgIGNvbnN0IGZvcm1hdERlY2ltYWxzID0gdHlwZW9mIGRlY2ltYWxzID09PSBcIm51bWJlclwiID8gZGVjaW1hbHMgOiB2b2lkIDA7XG5cdCAgICAgIGNvbnN0IHByb3BzID0ge1xuXHQgICAgICAgIHN0eWxlOiBcImN1cnJlbmN5XCIsXG5cdCAgICAgICAgY3VycmVuY3k6IGNvZGUsXG5cdCAgICAgICAgY3VycmVuY3lEaXNwbGF5OiBcInN5bWJvbFwiLFxuXHQgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogZm9ybWF0RGVjaW1hbHMsXG5cdCAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBmb3JtYXREZWNpbWFsc1xuXHQgICAgICB9O1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBGT1JNQVRURVJTW2tleV0gPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoZm9ybWF0TG9jYWxlcywgcHJvcHMpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJJbnZhbGlkIGxhbmd1YWdlIHRhZ1wiKSA+PSAwKSB7XG5cdCAgICAgICAgICAgIEZPUk1BVFRFUlNba2V5XSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIsIHByb3BzKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBGT1JNQVRURVJTW2tleV07XG5cdCAgICB9LFxuXHQgICAgYXBwbHlSb3VuZGluZyh2YWx1ZSwgY29uZmlnKSB7XG5cdCAgICAgIGlmICghY29uZmlnIHx8ICFjb25maWcucm91bmQpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3Qgc2NhbGUgPSBjb25maWcuZGVjaW1hbHM7XG5cdCAgICAgIGNvbnN0IGZyYWN0aW9uID0gY29uZmlnLnJvdW5kX2ludGVydmFsID09PSBcImZyYWN0aW9uXCIgPyBjb25maWcucm91bmRfZnJhY3Rpb24gfHwgMCA6IDA7XG5cdCAgICAgIGxldCByb3VuZFZhbHVlID0gfn52YWx1ZTtcblx0ICAgICAgbGV0IGRlY2ltYWxWYWx1ZSA9IHRoaXMucm91bmQodmFsdWUsIHNjYWxlKTtcblx0ICAgICAgaWYgKGRlY2ltYWxWYWx1ZSA9PT0gZnJhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gcm91bmRWYWx1ZSArIGRlY2ltYWxWYWx1ZTtcblx0ICAgICAgfVxuXHQgICAgICBjb25zdCBkaWZmID0gdGhpcy5yb3VuZChkZWNpbWFsVmFsdWUgLSBmcmFjdGlvbiwgMSk7XG5cdCAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNvbmZpZy5yb3VuZCA9PT0gXCJuZWFyZXN0XCIgPyBkaWZmID4gMCA/IGRpZmYgPj0gMC41ID8gXCJ1cFwiIDogXCJkb3duXCIgOiBkaWZmIDw9IC0wLjUgPyBcImRvd25cIiA6IFwidXBcIiA6IGNvbmZpZy5yb3VuZDtcblx0ICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcblx0ICAgICAgICBjYXNlIFwiZG93blwiOlxuXHQgICAgICAgICAgcm91bmRWYWx1ZSA9IHJvdW5kVmFsdWUgKyBmcmFjdGlvbiAtIChkZWNpbWFsVmFsdWUgPiBmcmFjdGlvbiA/IDAgOiAxKTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgXCJ1cFwiOlxuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICByb3VuZFZhbHVlID0gcm91bmRWYWx1ZSArIGZyYWN0aW9uICsgKGRlY2ltYWxWYWx1ZSA+IGZyYWN0aW9uID8gMSA6IDApO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMucm91bmQocm91bmRWYWx1ZSwgc2NhbGUpO1xuXHQgICAgfSxcblx0ICAgIHJvdW5kXG5cdCAgfTtcblx0fVxuXG5cdHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdHZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblx0dmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG5cdHZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG5cdCAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuXHQgICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuXHQgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG5cdCAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG5cdCAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcblx0ICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuXHQgICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcblx0ICAgIH1cblx0ICByZXR1cm4gYTtcblx0fTtcblx0Y29uc3Qgb3B0aW9ucyA9IHtcblx0ICBzdG9yZTogbnVsbCxcblx0ICBrZXk6IG51bGwsXG5cdCAgdXJsOiBudWxsLFxuXHQgIHVzZUNhbWVsQ2FzZTogbnVsbCxcblx0ICBwcmV2aWV3Q29udGVudDogbnVsbFxuXHR9O1xuXHRjb25zdCBhcGkgPSB7XG5cdCAgdmVyc2lvbjogXCIzLjE4LjJcIixcblx0ICBvcHRpb25zLFxuXHQgIHJlcXVlc3QsXG5cdCAgaW5pdChzdG9yZSwga2V5LCBvcHQgPSB7fSkge1xuXHQgICAgb3B0aW9ucy5rZXkgPSBrZXk7XG5cdCAgICBvcHRpb25zLnN0b3JlID0gc3RvcmU7XG5cdCAgICBvcHRpb25zLnVybCA9IG9wdC51cmwgPyB0cmltRW5kKG9wdC51cmwpIDogYGh0dHBzOi8vJHtzdG9yZX0uc3dlbGwuc3RvcmVgO1xuXHQgICAgb3B0aW9ucy52YXVsdFVybCA9IG9wdC52YXVsdFVybCA/IHRyaW1FbmQob3B0LnZhdWx0VXJsKSA6IGBodHRwczovL3ZhdWx0LnNjaGVtYS5pb2A7XG5cdCAgICBvcHRpb25zLnRpbWVvdXQgPSBvcHQudGltZW91dCAmJiBwYXJzZUludChvcHQudGltZW91dCwgMTApIHx8IDJlNDtcblx0ICAgIG9wdGlvbnMudXNlQ2FtZWxDYXNlID0gb3B0LnVzZUNhbWVsQ2FzZSB8fCBmYWxzZTtcblx0ICAgIG9wdGlvbnMucHJldmlld0NvbnRlbnQgPSBvcHQucHJldmlld0NvbnRlbnQgfHwgZmFsc2U7XG5cdCAgICBvcHRpb25zLnNlc3Npb24gPSBvcHQuc2Vzc2lvbjtcblx0ICAgIG9wdGlvbnMubG9jYWxlID0gb3B0LmxvY2FsZTtcblx0ICAgIG9wdGlvbnMuY3VycmVuY3kgPSBvcHQuY3VycmVuY3k7XG5cdCAgICBvcHRpb25zLmFwaSA9IGFwaTtcblx0ICAgIHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdCAgfSxcblx0ICBhdXRoKC4uLmFyZ3MpIHtcblx0ICAgIHJldHVybiB0aGlzLmluaXQoLi4uYXJncyk7XG5cdCAgfSxcblx0ICBnZXQodXJsLCBxdWVyeSkge1xuXHQgICAgcmV0dXJuIHJlcXVlc3QoXCJnZXRcIiwgdXJsLCBxdWVyeSk7XG5cdCAgfSxcblx0ICBwdXQodXJsLCBkYXRhKSB7XG5cdCAgICByZXR1cm4gcmVxdWVzdChcInB1dFwiLCB1cmwsIGRhdGEpO1xuXHQgIH0sXG5cdCAgcG9zdCh1cmwsIGRhdGEpIHtcblx0ICAgIHJldHVybiByZXF1ZXN0KFwicG9zdFwiLCB1cmwsIGRhdGEpO1xuXHQgIH0sXG5cdCAgZGVsZXRlKHVybCwgZGF0YSkge1xuXHQgICAgcmV0dXJuIHJlcXVlc3QoXCJkZWxldGVcIiwgdXJsLCBkYXRhKTtcblx0ICB9LFxuXHQgIGNhY2hlOiBjYWNoZUFwaSxcblx0ICBjYXJkOiBjYXJkQXBpLFxuXHQgIGNhcnQ6IG1ldGhvZHMkOChyZXF1ZXN0LCBvcHRpb25zKSxcblx0ICBhY2NvdW50OiBtZXRob2RzJDcocmVxdWVzdCksXG5cdCAgcHJvZHVjdHM6IG1ldGhvZHMkOShyZXF1ZXN0LCBvcHRpb25zKSxcblx0ICBjYXRlZ29yaWVzOiBtZXRob2RzJDYocmVxdWVzdCksXG5cdCAgYXR0cmlidXRlczogbWV0aG9kcyRhKHJlcXVlc3QpLFxuXHQgIHN1YnNjcmlwdGlvbnM6IG1ldGhvZHMkNShyZXF1ZXN0KSxcblx0ICBjb250ZW50OiBtZXRob2RzJDQocmVxdWVzdCwgb3B0aW9ucyksXG5cdCAgc2V0dGluZ3M6IG1ldGhvZHMkMyhyZXF1ZXN0LCBvcHRpb25zKSxcblx0ICBwYXltZW50OiBtZXRob2RzJDIocmVxdWVzdCwgb3B0aW9ucyksXG5cdCAgbG9jYWxlOiBtZXRob2RzJDEocmVxdWVzdCwgb3B0aW9ucyksXG5cdCAgY3VycmVuY3k6IG1ldGhvZHMocmVxdWVzdCwgb3B0aW9ucyksXG5cdCAgdXRpbHNcblx0fTtcblx0YXN5bmMgZnVuY3Rpb24gcmVxdWVzdChtZXRob2QsIHVybCwgaWQgPSB2b2lkIDAsIGRhdGEgPSB2b2lkIDAsIG9wdCA9IHZvaWQgMCkge1xuXHQgIGNvbnN0IGFsbE9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIG9wdCk7XG5cdCAgY29uc3Qgc2Vzc2lvbiA9IGFsbE9wdGlvbnMuc2Vzc2lvbiB8fCBnZXRDb29raWUoXCJzd2VsbC1zZXNzaW9uXCIpO1xuXHQgIGNvbnN0IGxvY2FsZTIgPSBhbGxPcHRpb25zLmxvY2FsZSB8fCBnZXRDb29raWUoXCJzd2VsbC1sb2NhbGVcIik7XG5cdCAgY29uc3QgY3VycmVuY3kyID0gYWxsT3B0aW9ucy5jdXJyZW5jeSB8fCBnZXRDb29raWUoXCJzd2VsbC1jdXJyZW5jeVwiKTtcblx0ICBjb25zdCBiYXNlVXJsID0gYCR7YWxsT3B0aW9ucy51cmx9JHthbGxPcHRpb25zLmJhc2UgfHwgXCJcIn0vYXBpYDtcblx0ICBjb25zdCByZXFNZXRob2QgPSBTdHJpbmcobWV0aG9kKS50b0xvd2VyQ2FzZSgpO1xuXHQgIGxldCByZXFVcmwgPSB1cmw7XG5cdCAgbGV0IHJlcURhdGEgPSBpZDtcblx0ICBpZiAoZGF0YSAhPT0gdm9pZCAwIHx8IHR5cGVvZiBpZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgcmVxVXJsID0gW3RyaW1FbmQodXJsKSwgdHJpbVN0YXJ0KGlkKV0uam9pbihcIi9cIik7XG5cdCAgICByZXFEYXRhID0gZGF0YTtcblx0ICB9XG5cdCAgcmVxVXJsID0gYWxsT3B0aW9ucy5mdWxsVXJsIHx8IGAke2Jhc2VVcmx9LyR7dHJpbUJvdGgocmVxVXJsKX1gO1xuXHQgIHJlcURhdGEgPSBhbGxPcHRpb25zLnVzZUNhbWVsQ2FzZSA/IHRvU25ha2UocmVxRGF0YSkgOiByZXFEYXRhO1xuXHQgIGxldCByZXFCb2R5O1xuXHQgIGlmIChyZXFNZXRob2QgPT09IFwiZ2V0XCIpIHtcblx0ICAgIGxldCBleFF1ZXJ5O1xuXHQgICAgW3JlcVVybCwgZXhRdWVyeV0gPSByZXFVcmwuc3BsaXQoXCI/XCIpO1xuXHQgICAgY29uc3QgZnVsbFF1ZXJ5ID0gW2V4UXVlcnksIHN0cmluZ2lmeVF1ZXJ5KHJlcURhdGEpXS5qb2luKFwiJlwiKS5yZXBsYWNlKC9eJi8sIFwiXCIpO1xuXHQgICAgcmVxVXJsID0gYCR7cmVxVXJsfSR7ZnVsbFF1ZXJ5ID8gYD8ke2Z1bGxRdWVyeX1gIDogXCJcIn1gO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXFCb2R5ID0gSlNPTi5zdHJpbmdpZnkocmVxRGF0YSk7XG5cdCAgfVxuXHQgIGNvbnN0IHJlcUhlYWRlcnMgPSB7XG5cdCAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuXHQgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG5cdCAgICBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHtiYXNlNjRFbmNvZGUoU3RyaW5nKGFsbE9wdGlvbnMua2V5KSl9YFxuXHQgIH07XG5cdCAgaWYgKHNlc3Npb24pIHtcblx0ICAgIHJlcUhlYWRlcnNbXCJYLVNlc3Npb25cIl0gPSBzZXNzaW9uO1xuXHQgIH1cblx0ICBpZiAobG9jYWxlMikge1xuXHQgICAgcmVxSGVhZGVyc1tcIlgtTG9jYWxlXCJdID0gbG9jYWxlMjtcblx0ICB9XG5cdCAgaWYgKGN1cnJlbmN5Mikge1xuXHQgICAgcmVxSGVhZGVyc1tcIlgtQ3VycmVuY3lcIl0gPSBjdXJyZW5jeTI7XG5cdCAgfVxuXHQgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxVXJsLCB7XG5cdCAgICBtZXRob2Q6IHJlcU1ldGhvZCxcblx0ICAgIGhlYWRlcnM6IHJlcUhlYWRlcnMsXG5cdCAgICBib2R5OiByZXFCb2R5LFxuXHQgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuXHQgICAgbW9kZTogXCJjb3JzXCJcblx0ICB9KTtcblx0ICBjb25zdCByZXNwb25zZVNlc3Npb24gPSByZXNwb25zZS5oZWFkZXJzLmdldChcIlgtU2Vzc2lvblwiKTtcblx0ICBpZiAodHlwZW9mIHJlc3BvbnNlU2Vzc2lvbiA9PT0gXCJzdHJpbmdcIiAmJiBzZXNzaW9uICE9PSByZXNwb25zZVNlc3Npb24pIHtcblx0ICAgIHNldENvb2tpZShcInN3ZWxsLXNlc3Npb25cIiwgcmVzcG9uc2VTZXNzaW9uKTtcblx0ICB9XG5cdCAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXHQgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmVycm9yKSB7XG5cdCAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xuXHQgICAgZXJyLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcblx0ICAgIGVyci5jb2RlID0gcmVzdWx0LmVycm9yLmNvZGU7XG5cdCAgICBlcnIucGFyYW0gPSByZXN1bHQuZXJyb3IucGFyYW07XG5cdCAgICB0aHJvdyBlcnI7XG5cdCAgfSBlbHNlIGlmICghcmVzcG9uc2Uub2spIHtcblx0ICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcblx0ICAgICAgXCJBIGNvbm5lY3Rpb24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbWFraW5nIHRoZSByZXF1ZXN0XCJcblx0ICAgICk7XG5cdCAgICBlcnIuY29kZSA9IFwiY29ubmVjdGlvbl9lcnJvclwiO1xuXHQgICAgdGhyb3cgZXJyO1xuXHQgIH1cblx0ICByZXR1cm4gb3B0aW9ucy51c2VDYW1lbENhc2UgPyB0b0NhbWVsKHJlc3VsdCkgOiByZXN1bHQ7XG5cdH1cblxuXHRyZXR1cm4gYXBpO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2VsbC51bWQubWluLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/swell-js/dist/swell.umd.min.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=D%3A%5Cdev_test%5Csrc%5Cpages%5C%5Bslug%5D.tsx&page=%2F%5Bslug%5D!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);